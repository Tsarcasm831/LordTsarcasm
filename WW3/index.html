<html>
    <head>
        
            <meta charset="utf-8"/>
            <title>Keymaster!</title>
        <style>
            body { 
                margin: 0;
                overflow: hidden;
                font-family: Arial, sans-serif;
            }
            #instructions {
                position: fixed;
                top: 20px;
                left: 20px;
                color: white;
                background: rgba(0,0,0,0.7);
                padding: 15px;
                border-radius: 5px;
                z-index: 100;
                line-height: 1.4;
                max-width: 300px;
                border: 1px solid rgba(255,215,0,0.3);
            }
            #instructions-toggle {
                display: block;
                color: #FFD700;
                cursor: pointer;
                margin-top: 10px;
                text-align: center;
            }
            #instructions-toggle:hover {
                color: white;
            }
            #title-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: black;
                color: white;
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                z-index: 200;
                transition: opacity 1s;
                align-items: flex-start; /* Align items to the start */
                padding-top: 100px;      /* Add padding from the top to center other content */
            }
            #language-selector {
                position: absolute;
                top: 10%;
                background: #333;
                color: #FFD700;
                padding: 5px 10px;
                border: 2px solid #FFD700;
                border-radius: 5px;
                cursor: pointer;
            }
            #title {
                font-size: 48px;
                margin-bottom: 20px;
            }
            #caption span {
                opacity: 0;
                transition: opacity 0.5s;
            }
            .door-text {
                position: absolute;
                color: white;
                font-size: 18px;
                text-align: center;
                width: 100%;
                z-index: 100;
            }
            #room-position {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                color: white;
                background: rgba(0,0,0,0.5);
                padding: 10px;
                border-radius: 5px;
                z-index: 100;
            }
            #loading-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: black;
                color: white;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 300;
                font-size: 24px;
            }
            #key-display {
                position: fixed;
                top: 65px; 
                left: 50%;
                transform: translateX(-50%);
                color: #FFD700; 
                background: rgba(0,0,0,0.5);
                padding: 10px;
                border-radius: 5px;
                z-index: 100;
            }
            #shop-button {
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0,0,0,0.5);
                color: #FFD700;
                padding: 10px 20px;
                border: 2px solid #FFD700;
                border-radius: 5px;
                cursor: pointer;
                z-index: 100;
            }
            #map-button {
                position: fixed;
                top: 65px; /* Adjust as needed */
                right: 20px;
                background: rgba(0,0,0,0.5);
                color: #FFD700;
                padding: 10px 20px;
                border: 2px solid #FFD700;
                border-radius: 5px;
                cursor: pointer;
                z-index: 100;
            }
            #settings-button {
                position: fixed;
                top: 110px; /* Position under map button */
                right: 20px;
                background: rgba(0,0,0,0.5);
                color: #FFD700;
                padding: 10px 20px;
                border: 2px solid #FFD700;
                border-radius: 5px;
                cursor: pointer;
                z-index: 100;
            }
            #settings-modal {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 20px;
                border: 2px solid #FFD700;
                border-radius: 10px;
                z-index: 150;
            }
            .settings-item {
                margin: 15px 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
        
            #settings-modal h2 {
                color: #FFD700;
                margin-bottom: 20px;
                text-align: center;
            }
        
            #settings-modal button {
                background: #FFD700;
                color: black;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 15px;
                width: 100%;
            }
        
            #settings-modal input[type="range"] {
                width: 150px;
            }
        
            #settings-modal input[type="checkbox"] {
                width: 20px;
                height: 20px;
                cursor: pointer;
            }
        
            #settings-modal label {
                margin-right: 10px;
                color: #FFD700;
            }
            #shop-modal {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 20px;
                border: 2px solid #FFD700;
                border-radius: 10px;
                z-index: 150;
            }
            #shop-tabs {
                display: flex;
                margin-bottom: 10px;
            }
            .shop-tab {
                flex: 1;
                background: rgba(0,0,0,0.5);
                color: #FFD700;
                padding: 10px;
                border: 2px solid #FFD700;
                border-radius: 5px 5px 0 0;
                cursor: pointer;
                text-align: center;
            }
            .shop-tab.active {
                background: #FFD700;
                color: black;
            }
            #shop-content > div {
                display: none;
            }
            #shop-content > div.active {
                display: block;
            }
            #travel-menu {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 20px;
                border: 2px solid #FFD700;
                border-radius: 10px;
                z-index: 150;
            }
            #travel-menu input {
                background: rgba(255,215,0,0.1);
                border: 1px solid #FFD700;
                color: white;
                padding: 5px;
                margin: 5px;
            }
            #travel-menu button {
                background: #FFD700;
                color: black;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
                margin: 5px;
            }
            #travel-menu div {
                margin: 10px 0;
            }
            #travel-menu label {
                display: inline-block;
                width: 100px;
            }
            .upgrades-section {
                margin-top: 20px;
                padding-top: 20px;
                border-top: 1px solid #FFD700;
            }
            .shop-item {
                display: flex;
                justify-content: space-between;
                align-items: flex-start; 
                padding: 10px;
                border-bottom: 1px solid #FFD700;
                margin-bottom: 10px;
            }
            .upgrade-boxes {
                margin-top: 5px; 
                display: flex;
                gap: 10px;
                margin: 10px 0;
            }
            .upgrade-box {
                width: 40px;
                height: 40px;
                border: 1px solid #FFD700;
                background: rgba(255,215,0,0.1);
            }
            #inventory {
                position: fixed;
                bottom: 20px;
                left: 20px;
                display: flex;
                gap: 10px;
                z-index: 100;
            }
            .inventory-slot {
                width: 50px;
                height: 50px;
                background: rgba(0,0,0,0.5);
                border: 2px solid #FFD700;
                border-radius: 5px;
                display: flex;
                justify-content: center;
                align-items: center;
                color: white;
            }
            .inventory-slot.selected {
                background: rgba(255,215,0,0.2);
            }
            #shop-modal {
                min-width: 300px;
            }
            .shop-item button {
                background: #FFD700;
                color: black;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
            }
            #status-message {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                z-index: 400; /* Higher than loading screen */
                display: none;
                text-align: center;
            }
            /* Map UI */
            #map-ui {
                display: none; /* Hidden by default */
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                z-index: 500; /* Above other elements */
                overflow: hidden;
            }
            /* Map Container */
            #map-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 4000px; /* Adjust as needed */
                height: 4000px; /* Adjust as needed */
                cursor: grab;
                transform: translate(0px, 0px);
            }
            /* Room Boxes */
            #map-ui .room-box {
                position: absolute;
                width: 40px; /* Adjusted size to fit more boxes */
                height: 40px;
                border: 1px solid #333;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                color: white;
                background-size: cover;
                background-repeat: no-repeat;
                background-position: center;
                background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
            }
            /* Close Map Button */
            #close-map-button {
                position: fixed;
                top: 20px;
                right: 20px;
                background: #FFD700;
                color: black;
                padding: 5px 10px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }
            #death-screen {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: black;
                color: white;
                z-index: 1000;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            #death-screen h1 {
                font-size: 48px;
                margin-bottom: 20px;
            }
            #death-screen button {
                font-size: 24px;
                padding: 10px 20px;
                cursor: pointer;
            }
            /* Key Master button styling */
            #key-master-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: rgba(0,0,0,0.5);
                color: #FFD700;
                padding: 20px 30px; /* Increased padding */
                font-size: 24px;     /* Increased font size */
                border: 2px solid #FFD700;
                border-radius: 5px;
                cursor: pointer;
                z-index: 100;
            }
            /* Key Master modal styling */
            #key-master-modal {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 20px;
                border: 2px solid #FFD700;
                border-radius: 10px;
                z-index: 150;
            }
            #key-master-modal input {
                background: rgba(255,215,0,0.1);
                border: 1px solid #FFD700;
                color: white;
                padding: 5px;
                margin: 5px;
            }
            #key-master-modal button {
                background: #FFD700;
                color: black;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
                margin: 5px;
            }
            #key-master-modal p {
                margin-top: 10px;
            }
            /* Joystick Styles */
            .joystick-container {
                position: fixed;
                bottom: 100px;
                width: 120px;
                height: 120px;
                background: rgba(255,255,255,0.2);
                border-radius: 50%;
                display: none; /* Hidden by default, shown on mobile */
                touch-action: none;
                z-index: 1000;
            }
            #movement-joystick {
                left: 20px;
            }
            #camera-joystick {
                right: 20px;
            }
            .joystick-knob {
                position: absolute;
                width: 50px;
                height: 50px;
                background: rgba(255,215,0,0.5);
                border: 2px solid #FFD700;
                border-radius: 50%;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                pointer-events: none;
            }
            #mobile-jump-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 80px;
                height: 80px;
                background: rgba(255,215,0,0.3);
                border: 2px solid #FFD700;
                border-radius: 50%;
                color: white;
                font-size: 18px;
                display: none; /* Hidden by default, shown on mobile */
                z-index: 1000;
                touch-action: none;
            }
            /* Add to existing CSS */
            #fullscreen-button {
                background: #FFD700;
                color: black;
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
            }

            /* Inventory Modal Styling */
        #inventory-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2b2b2b, #3c3c3c);
            color: white;
            padding: 20px;
            border-radius: 12px;
            z-index: 150;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.9), inset 0 0 10px #000;
            font-family: 'Arial', sans-serif;
            border: 3px solid #FFD700; /* Gold border for a premium look */
        }

        /* Header Styling */
        #inventory-header {
            font-size: 26px;
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700; /* Gold color */
            font-weight: bold;
            text-shadow: 1px 1px 8px rgba(255, 215, 0, 0.8);
        }

        /* Section Styling */
        #equipment-section, #consumable-section, #grid-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        /* Slot Styling */
        .equipment-slot, .consumable-slot, .grid-slot {
            width: 55px;
            height: 55px;
            background: #1a1a1a;
            border: 2px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #aaa;
            font-size: 12px;
            text-align: center;
            border-radius: 6px;
            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.6), inset 0px 0px 8px rgba(255, 215, 0, 0.1);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        /* Highlighted Slot Styling */
        .equipment-slot:hover, .consumable-slot:hover, .grid-slot:hover {
            transform: scale(1.1);
            box-shadow: 0px 0px 10px rgba(255, 215, 0, 0.6), inset 0px 0px 12px rgba(255, 215, 0, 0.2);
        }

        /* Equipment Slot Specific Styling */
        .equipment-slot {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #2e2e2e, #444444);
            border: 2px solid #FFD700; /* Gold border for equipment */
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 5px #FFD700;
        }

        /* Consumable Slot Styling */
        #consumable-section .consumable-slot {
            width: 60px;
            height: 60px;
            background: #262626;
            border: 1px solid #FFD700;
            color: #FFD700;
        }

        /* Grid Slot Section Styling */
        #grid-section {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            border-top: 1px solid #555;
            padding-top: 15px;
            max-width: 350px;
            margin: auto;
        }

        /* Character Stats */
        #character-stats {
            text-align: center;
            font-size: 14px;
            color: #FFD700;
            padding-top: 10px;
            font-weight: bold;
            text-shadow: 0px 0px 5px rgba(255, 215, 0, 0.8);
        }

        /* Button Styling */
        #inventory-modal button {
            background: #FFD700;
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0px 0px 8px rgba(255, 215, 0, 0.5);
        }

        #inventory-modal button:hover {
            background: #fff;
            color: #FFD700;
            box-shadow: 0px 0px 12px rgba(255, 255, 255, 0.7);
        }

        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    </head>

    <body>
        <div id="loading-screen">
            <div id="loading-text">Loading...</div>
        </div>

        <div id="title-screen">
            <div id="title">Weird Walk 3!</div>
            <div id="caption">
                <span>Find the keys...</span><span></span><span>and bring them back...</span><span></span><span>to the keymaster.</span> <span></span>
            </div>
            <div id="caption" style="margin-top: 20px;">
                <span>Edited/Expanded by Lord Tsarcasm</span><span></span><span></span><br>
                <span>Inspired by GreenSkull AI</span> <span>Remixed from websim.ai</span>
            </div>
        </div>

        <div id="instructions">
            Movement Controls:<br>
            • WASD: Walk around<br>
            • Arrow Keys: Look around<br>
            • Space: Jump<br><br>
            Item Controls:<br>
            • E: Use selected item<br>
            • I: Open inventory<br>
            • Numbers 1-5: Select item slot<br><br>
            Game Tips:<br>
            • Walk into doors to explore new rooms<br>
            • Collect golden keys to buy items<br>
            • Return to room (0,0) to visit the Key Master
            <div id="instructions-toggle">/\</div>
        </div>

        <div id="room-position"></div>

        <div id="key-display">Keys: 0</div>

        <button id="shop-button">Shop</button>
        <button id="map-button">Map</button>
        <button id="settings-button">Settings</button>
        <button id="key-master-button" style="display: none;">Open Key Master Menu</button>

        <div id="inventory">
            <div class="inventory-slot" data-slot="0"></div>
            <div class="inventory-slot" data-slot="1"></div>
            <div class="inventory-slot" data-slot="2"></div>
            <div class="inventory-slot" data-slot="3"></div>
            <div class="inventory-slot" data-slot="4"></div>
        </div>

        <div id="settings-modal">
            <h2>Settings</h2>
            <div class="settings-item">
                <label for="ui-scale">UI Scale:</label>
                <input type="range" id="ui-scale" min="50" max="150" value="100">
            </div>
            <div class="settings-item">
                <label for="play-sfx">Play SFX:</label>
                <input type="checkbox" id="play-sfx" checked>
            </div>
            <div class="settings-item">
                <label for="show-instructions">Show Instructions:</label>
                <input type="checkbox" id="show-instructions" checked>
            </div>
            <div class="settings-item">
                <label for="fov">FOV:</label>
                <input type="range" id="fov" min="60" max="120" value="75">
            </div>
            <div class="settings-item">
                <label for="pointer-lock">Pointer Lock:</label>
                <input type="checkbox" id="pointer-lock">
            </div>
            <div class="settings-item">
                <label for="fullscreen">Fullscreen:</label>
                <button id="fullscreen-button">Toggle Fullscreen</button>
            </div>
            <button onclick="closeSettings()">Close</button>
        </div>

        <div id="shop-modal">
            <h2>Shop</h2>
            <div id="shop-tabs">
                <button class="shop-tab" onclick="showShopTab('items')">Items</button>
                <button class="shop-tab" onclick="showShopTab('upgrades')">Upgrades</button>
            </div>
            <div id="shop-content">
                <div id="shop-items" class="active">
                    <div class="shop-item">
                        <span>Key Magnet (10 keys)</span>
                        <button onclick="buyItem('keyMagnet', 10)">Buy</button>
                    </div>
                    <div class="shop-item">
                        <span>Travel Stone (25 keys)</span>
                        <button onclick="buyItem('travelStone', 25)">Buy</button>
                    </div>
                    <div class="shop-item">
                        <span>Speed Boost (15 keys)</span>
                        <button onclick="buyItem('speedBoost', 15)">Buy</button>
                    </div>
                    <div class="shop-item">
                        <span>Shield (20 keys)</span>
                        <button onclick="buyItem('shield', 20)">Buy</button>
                    </div>
                </div>
                <div id="shop-upgrades" style="display:none;">
                    <div class="shop-item">
                        <span>Pickup Radius (5 keys)</span>
                        <button onclick="buyUpgrade('pickupRadius')">Upgrade</button>
                    </div>
                    <div class="upgrade-boxes">
                        <div class="upgrade-box pickup-radius"></div>
                        <div class="upgrade-box pickup-radius"></div>
                        <div class="upgrade-box pickup-radius"></div>
                        <div class="upgrade-box pickup-radius"></div>
                        <div class="upgrade-box pickup-radius"></div>
                    </div>
                    <div class="shop-item">
                        <span>Speed (5 keys)</span>
                        <button onclick="buyUpgrade('speed')">Upgrade</button>
                    </div>
                    <div class="upgrade-boxes">
                        <div class="upgrade-box"></div>
                        <div class="upgrade-box"></div>
                        <div class="upgrade-box"></div>
                        <div class="upgrade-box"></div>
                        <div class="upgrade-box"></div>
                    </div>
                </div>
            </div>
            <button onclick="closeShop()">Close</button>
        </div>

        <div id="key-master-modal" style="display: none;">
            <h2>Key Master</h2>
            <p>You can donate keys to the Key Master.</p>
            <div>
                <label for="donation-amount">Amount of keys to donate:</label>
                <input type="number" id="donation-amount" min="1">
            </div>
            <button onclick="donateKeys()">Donate</button>
            <button onclick="closeKeyMaster()">Close</button>
            <p id="key-master-status"></p>
        </div>

        <div id="travel-menu">
            <h2>Travel Menu</h2>
            <div>
                <label for="travel-x">X coordinate:</label>
                <input type="number" id="travel-x">
            </div>
            <div>
                <label for="travel-y">Y coordinate:</label>
                <input type="number" id="travel-y">
            </div>
            <button onclick="executeTravel()">Travel</button>
            <button onclick="closeTravelMenu()">Cancel</button>
            <button onclick="setToSaveRoom()">Set to Save Room</button>
        </div>

        <div id="map-ui">
            <div id="map-container">
                <!-- Map grid will be generated here -->
            </div>
            <button id="close-map-button">Close Map</button>
        </div>

        <div id="status-message"></div>

        <div id="death-screen">
            <h1>You Died</h1>
            <button id="respawn-button">Respawn</button>
        </div>

        <div id="movement-joystick" class="joystick-container">
            <div class="joystick-knob"></div>
        </div>

        <div id="camera-joystick" class="joystick-container">
            <div class="joystick-knob"></div>
        </div>

        <div id="inventory-modal" style="display: none;">
            <div id="inventory-header">Inventory</div>
            <div id="equipment-section">
                <div class="equipment-slot" id="helmet-slot">Helmet</div>
                <div class="equipment-slot" id="chest-slot">Armor</div>
                <div class="equipment-slot" id="gloves-slot">Gloves</div>
                <div class="equipment-slot" id="boots-slot">Boots</div>
                <div class="equipment-slot" id="main-hand-slot">Main Hand</div>
                <div class="equipment-slot" id="off-hand-slot">Off Hand</div>
            </div>
            <div id="consumable-section">
                <div class="consumable-slot" id="potion-1">Potion 1</div>
                <div class="consumable-slot" id="potion-2">Potion 2</div>
                <div class="consumable-slot" id="potion-3">Potion 3</div>
                <div class="consumable-slot" id="potion-4">Potion 4</div>
                <div class="consumable-slot" id="potion-5">Potion 5</div>
            </div>
            <div id="grid-section">
                <!-- 60-slot grid for items -->
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <div class="grid-slot"></div>
                <!-- Repeat the slot div 60 times, or use JS to generate dynamically -->
            </div>
            <div id="character-stats">
                <div>Level: <span id="level">1</span></div>
                <div>Health: <span id="health">100</span></div>
                <div>Experience: <span id="experience">0</span></div>
            </div>
            <button onclick="closeInventory()">Close Inventory</button>
        </div>
        
        <button id="mobile-jump-button">JUMP</button>

        <script>
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            const roomWidth = 50;
            const roomHeight = 25;
            const roomDepth = 50;
            
            const textureLoader = new THREE.TextureLoader();
            
            const roomPrompts = {};
            roomPrompts['0,0'] = "A alien weird universe";
            
            const roomData = {};  
            let currentRoomPrompt = "A alien weird universe";
            let imagesLoaded = 0;
            const totalImages = 5; 
            
            let playerFrozen = true; // Start frozen
            let speedUpgradeLevel = 0;
            let pickupRadiusLevel = 0;
            const BASE_SPEED = 0.15;
            const BASE_PICKUP_RADIUS = 1;
            const turnSpeed = 0.03;
            
            let speed = BASE_SPEED * (1 + speedUpgradeLevel);
            
            let lookUp = false;
            let lookDown = false;
            const maxPitch = Math.PI / 4; // 45 degrees in radians
            
            // Distance threshold to show the shop popup
            const interactionThreshold = 2.5;
            let isShopOpen = false; // This keeps track of the shop’s open/close status

            // This function checks the distance to open or close the shop popup
            function checkShopInteraction() {
                if (currentShopCharacter && currentShopCharacter.mesh) {
                    const distance = camera.position.distanceTo(currentShopCharacter.mesh.position);
                    
                    if (distance < interactionThreshold) {
                        if (!isShopOpen) {
                            openShop();
                            displayShopCharacterMessage();
                        }
                    } else if (isShopOpen) {
                        closeShop();
                        hideStatusMessage();
                    }
                }
            }

            // Define 10 unique shop characters with additional appearance properties
            const shopCharacters = [
                {
                    name: "Grizzle the Trader",
                    message: "Looking for rare items?",
                    bodyType: "muscular",
                    clothingStyle: "armor",
                    accessories: ["helmet", "shield"]
                },
                {
                    name: "Fern the Forager",
                    message: "Only the finest herbs here.",
                    bodyType: "slim",
                    clothingStyle: "robe",
                    accessories: ["staff", "herbPouch"]
                },
                {
                    name: "Zog the Alchemist",
                    message: "Potions and brews for every need.",
                    bodyType: "average",
                    clothingStyle: "labCoat",
                    accessories: ["beaker", "goggles"]
                },
                {
                    name: "Mira the Mystic",
                    message: "I foresee a deal in your future.",
                    bodyType: "ethereal",
                    clothingStyle: "cloak",
                    accessories: ["crystalBall", "amulet"]
                },
                {
                    name: "Tarn the Tinkerer",
                    message: "Gadgets and gizmos aplenty!",
                    bodyType: "stocky",
                    clothingStyle: "toolBelt",
                    accessories: ["wrench", "gearHelmet"]
                },
                {
                    name: "Lira the Rogue",
                    message: "Found these items... somewhere.",
                    bodyType: "lean",
                    clothingStyle: "leatherArmor",
                    accessories: ["daggers", "mask"]
                },
                {
                    name: "Bard the Bard",
                    message: "Tunes and trinkets for the daring.",
                    bodyType: "average",
                    clothingStyle: "colorfulGarments",
                    accessories: ["lyre", "hat"]
                },
                {
                    name: "Zin the Warrior",
                    message: "Arm yourself for the battles ahead.",
                    bodyType: "muscular",
                    clothingStyle: "heavyArmor",
                    accessories: ["sword", "shield"]
                },
                {
                    name: "Nara the Herbalist",
                    message: "Essences and elixirs, fresh from the forest.",
                    bodyType: "slim",
                    clothingStyle: "flowingRobe",
                    accessories: ["herbBelt", "potionVials"]
                },
                {
                    name: "Slo the Smith",
                    message: "Weapons forged in the finest flames.",
                    bodyType: "stocky",
                    clothingStyle: "smithApron",
                    accessories: ["hammer", "anvil"]
                }
            ];

            let currentShopCharacter = null; // Holds the current room's shop character
            let currentShopTab = 'items'; // Default to items tab

            // Function to spawn a detailed, human-like shop character with a grounded position and unique attributes
            function spawnShopCharacter() {
                // Select a random character
                const randomCharacterIndex = Math.floor(Math.random() * shopCharacters.length);
                currentShopCharacter = shopCharacters[randomCharacterIndex];

                // Generate the character mesh with unique attributes
                createShopCharacterMesh(currentShopCharacter);

                // Load font and create name mesh
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const textGeometry = new THREE.TextGeometry(currentShopCharacter.name, {
                        font: font,
                        size: 0.15,
                        height: 0.02,
                        curveSegments: 8,
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);

                    // Position name directly above head
                    textMesh.position.set(0, 2.2, 0);

                    // Remove initial rotation to allow dynamic rotation towards camera
                    // textMesh.rotation.y = Math.PI + 13; // Removed this line

                    currentShopCharacter.nameMesh = textMesh;
                    currentShopCharacter.mesh.add(textMesh); // Add name to character mesh
                });

                // Add character mesh to scene
                scene.add(currentShopCharacter.mesh);
            }

            



            // Helper function to create a fully detailed, grounded shop character with clothing layers, body accessories, and varied posture
            function createShopCharacterMesh(character) {
                // Color palettes based on clothing styles
                const colorPalettes = {
                    armor: { primary: 0x555555, secondary: 0xFFD700 },
                    robe: { primary: 0x4B0082, secondary: 0xFFFFFF },
                    labCoat: { primary: 0xAAAAAA, secondary: 0x000000 },
                    cloak: { primary: 0x2E0854, secondary: 0x8A2BE2 },
                    toolBelt: { primary: 0x654321, secondary: 0xFFA500 },
                    leatherArmor: { primary: 0x8B4513, secondary: 0xDAA520 },
                    colorfulGarments: { primary: 0xFF69B4, secondary: 0x00FFFF },
                    heavyArmor: { primary: 0x000000, secondary: 0xFFD700 },
                    flowingRobe: { primary: 0x7B68EE, secondary: 0x00FF7F },
                    smithApron: { primary: 0xA0522D, secondary: 0xFF4500 }
                };

                // Select colors based on clothing style
                const primaryColor = colorPalettes[character.clothingStyle].primary;
                const secondaryColor = colorPalettes[character.clothingStyle].secondary;

                // Materials
                const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.8 });
                const clothingMaterial = new THREE.MeshStandardMaterial({ color: primaryColor, roughness: 0.6 });
                const accessoryMaterial = new THREE.MeshPhysicalMaterial({ color: secondaryColor, metalness: 0.3, roughness: 0.3 });

                // Create character group
                const shopCharacter = new THREE.Group();

                // Body Type Scaling
                let bodyScale = 1;
                switch (character.bodyType) {
                    case "muscular":
                        bodyScale = 1.2;
                        break;
                    case "slim":
                        bodyScale = 0.9;
                        break;
                    case "stocky":
                        bodyScale = 1.1;
                        break;
                    case "ethereal":
                        bodyScale = 1.0;
                        break;
                    case "lean":
                        bodyScale = 0.85;
                        break;
                    default:
                        bodyScale = 1.0;
                }

                // Torso
                const torsoGeometry = new THREE.CylinderGeometry(0.4 * bodyScale, 0.6 * bodyScale, 1.4 * bodyScale, 32);
                const torso = new THREE.Mesh(torsoGeometry, clothingMaterial);
                torso.position.set(0, 0, 0);
                shopCharacter.add(torso);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.3 * bodyScale, 32, 32);
                const head = new THREE.Mesh(headGeometry, skinMaterial);
                head.position.set(0, 1.0 * bodyScale, 0); // Above torso
                torso.add(head);

                // Hair (optional based on body type or accessories)
                const hairGeometry = new THREE.SphereGeometry(0.35 * bodyScale, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                const hair = new THREE.Mesh(hairGeometry, accessoryMaterial);
                // Position the hair higher to prevent covering the eyes
                hair.position.set(0, 0.3 * bodyScale, 0); // Increased Y position
                hair.renderOrder = 1; // Render before eyes
                head.add(hair);

                // Eyes and mouth
                const eyeGeometry = new THREE.SphereGeometry(0.04 * bodyScale, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x111111, 
                    
                    transparent: true
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1 * bodyScale, 0.1 * bodyScale, 0.25 * bodyScale);
                
                head.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1 * bodyScale, 0.1 * bodyScale, 0.25 * bodyScale);
                
                head.add(rightEye);
                const mouthGeometry = new THREE.BoxGeometry(0.15 * bodyScale, 0.05 * bodyScale, 0.05 * bodyScale);
                const mouth = new THREE.Mesh(mouthGeometry, eyeMaterial);
                mouth.position.set(0, -0.1 * bodyScale, 0.3 * bodyScale);
                mouth.renderOrder = 2; // Render after hair and helmet
                head.add(mouth);

                // Arms
                const armLength = 0.7 * bodyScale;
                const armGeometry = new THREE.CylinderGeometry(0.1 * bodyScale, 0.1 * bodyScale, armLength, 32);
                const leftArm = new THREE.Mesh(armGeometry, clothingMaterial);
                leftArm.position.set(-0.5 * bodyScale, 0.2 * bodyScale, 0);
                leftArm.rotation.z = Math.PI / 8;
                torso.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, clothingMaterial);
                rightArm.position.set(0.5 * bodyScale, 0.2 * bodyScale, 0);
                rightArm.rotation.z = -Math.PI / 8;
                torso.add(rightArm);

                // Legs
                const legLength = 0.9 * bodyScale;
                const legGeometry = new THREE.CylinderGeometry(0.15 * bodyScale, 0.15 * bodyScale, legLength, 32);
                const leftLeg = new THREE.Mesh(legGeometry, clothingMaterial);
                leftLeg.position.set(-0.25 * bodyScale, -1.15 * bodyScale, 0);
                torso.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeometry, clothingMaterial);
                rightLeg.position.set(0.25 * bodyScale, -1.15 * bodyScale, 0);
                torso.add(rightLeg);

                // Shoes
                const shoeGeometry = new THREE.BoxGeometry(0.2 * bodyScale, 0.1 * bodyScale, 0.3 * bodyScale);
                const leftShoe = new THREE.Mesh(shoeGeometry, accessoryMaterial);
                leftShoe.position.set(-0.25 * bodyScale, -1.6 * bodyScale, 0.15 * bodyScale);
                torso.add(leftShoe);
                const rightShoe = new THREE.Mesh(shoeGeometry, accessoryMaterial);
                rightShoe.position.set(0.25 * bodyScale, -1.6 * bodyScale, 0.15 * bodyScale);
                torso.add(rightShoe);

                // Optional Accessories based on character's accessories array
                character.accessories.forEach(accessoryName => {
                    switch (accessoryName) {
                        case "helmet":
                            addHelmet(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "shield":
                            addShield(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "staff":
                            addStaff(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "herbPouch":
                            addHerbPouch(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "beaker":
                            addBeaker(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "goggles":
                            addGoggles(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "crystalBall":
                            addCrystalBall(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "amulet":
                            addAmulet(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "wrench":
                            addWrench(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "gearHelmet":
                            addGearHelmet(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "daggers":
                            addDaggers(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "mask":
                            addMask(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "lyre":
                            addLyre(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "hat":
                            addHat(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "sword":
                            addSword(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "hammer":
                            addHammer(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "anvil":
                            addAnvil(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        case "potionVials":
                            addPotionVials(shopCharacter, accessoryMaterial, bodyScale);
                            break;
                        default:
                            console.warn(`Accessory "${accessoryName}" is not defined.`);
                    }
                });

                // Position the character in the room
                const charX = (Math.random() - 0.5) * (roomWidth - 4);
                const charZ = (Math.random() - 0.5) * (roomDepth - 4);
                shopCharacter.position.set(
                    charX,
                    FLOOR_HEIGHT - 0.3,
                    charZ
                );

                // Make the character face the center of the room (0,0,0)
                shopCharacter.lookAt(new THREE.Vector3(0, shopCharacter.position.y, 0));

                // Attach character to currentShopCharacter
                currentShopCharacter.mesh = shopCharacter;
            }

             // Helper functions to add accessories
            function addHelmet(characterGroup, material, scale) {
                const helmetGeometry = new THREE.SphereGeometry(0.35 * scale, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                const helmet = new THREE.Mesh(helmetGeometry, material);
                helmet.position.set(0, 1.05 * scale, 0);
                characterGroup.add(helmet);
            }

            function addShield(characterGroup, material, scale) {
                const shieldGeometry = new THREE.CircleGeometry(0.4 * scale, 32);
                const shield = new THREE.Mesh(shieldGeometry, material);
                shield.rotation.x = -Math.PI / 2;
                shield.position.set(-0.6 * scale, 0.5 * scale, 0);
                characterGroup.add(shield);
            }

            function addStaff(characterGroup, material, scale) {
                const staffGeometry = new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 1.0 * scale, 32);
                const staff = new THREE.Mesh(staffGeometry, material);
                staff.position.set(0.6 * scale, 0.5 * scale, 0);
                characterGroup.add(staff);
            }

            function addHerbPouch(characterGroup, material, scale) {
                const pouchGeometry = new THREE.SphereGeometry(0.15 * scale, 16, 16);
                const pouch = new THREE.Mesh(pouchGeometry, material);
                pouch.position.set(-0.4 * scale, 0.2 * scale, 0);
                characterGroup.add(pouch);
            }

            function addBeaker(characterGroup, material, scale) {
                const beakerGeometry = new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 0.5 * scale, 16);
                const beaker = new THREE.Mesh(beakerGeometry, material);
                beaker.rotation.z = Math.PI / 2;
                beaker.position.set(0.3 * scale, 0.8 * scale, 0);
                characterGroup.add(beaker);
            }

            function addGoggles(characterGroup, material, scale) {
                const gogglesGeometry = new THREE.SphereGeometry(0.05 * scale, 8, 8);
                const goggles = new THREE.Mesh(gogglesGeometry, material);
                goggles.position.set(-0.15 * scale, 0.05 * scale, 0.35 * scale);
                characterGroup.add(goggles);
            }

            function addCrystalBall(characterGroup, material, scale) {
                const crystalGeometry = new THREE.SphereGeometry(0.2 * scale, 32, 32);
                const crystal = new THREE.Mesh(crystalGeometry, material);
                crystal.position.set(0, 1.3 * scale, 0.1 * scale);
                characterGroup.add(crystal);
            }

            function addAmulet(characterGroup, material, scale) {
                const amuletGeometry = new THREE.TorusGeometry(0.1 * scale, 0.02 * scale, 16, 100);
                const amulet = new THREE.Mesh(amuletGeometry, material);
                amulet.position.set(0, 0.9 * scale, 0.3 * scale);
                characterGroup.add(amulet);
            }

            function addWrench(characterGroup, material, scale) {
                const wrenchGeometry = new THREE.BoxGeometry(0.2 * scale, 0.05 * scale, 0.05 * scale);
                const wrench = new THREE.Mesh(wrenchGeometry, material);
                wrench.position.set(-0.5 * scale, 0.3 * scale, 0.2 * scale);
                wrench.rotation.z = Math.PI / 4;
                characterGroup.add(wrench);
            }

            function addGearHelmet(characterGroup, material, scale) {
                const gearGeometry = new THREE.TorusGeometry(0.2 * scale, 0.05 * scale, 16, 100);
                const gearHelmet = new THREE.Mesh(gearGeometry, material);
                gearHelmet.position.set(0, 1.05 * scale, 0.1 * scale);
                gearHelmet.rotation.x = Math.PI / 2;
                characterGroup.add(gearHelmet);
            }

            function addDaggers(characterGroup, material, scale) {
                const daggerGeometry = new THREE.BoxGeometry(0.05 * scale, 0.5 * scale, 0.02 * scale);
                const dagger1 = new THREE.Mesh(daggerGeometry, material);
                dagger1.position.set(0.3 * scale, 0.5 * scale, 0.2 * scale);
                dagger1.rotation.z = Math.PI / 6;
                characterGroup.add(dagger1);

                const dagger2 = new THREE.Mesh(daggerGeometry, material);
                dagger2.position.set(-0.3 * scale, 0.5 * scale, 0.2 * scale);
                dagger2.rotation.z = -Math.PI / 6;
                characterGroup.add(dagger2);
            }

            function addMask(characterGroup, material, scale) {
                const maskGeometry = new THREE.BoxGeometry(0.3 * scale, 0.15 * scale, 0.05 * scale);
                const mask = new THREE.Mesh(maskGeometry, material);
                mask.position.set(0, 0.05 * scale, 0.35 * scale);
                characterGroup.add(mask);
            }

            function addLyre(characterGroup, material, scale) {
                const lyreGeometry = new THREE.TorusGeometry(0.2 * scale, 0.05 * scale, 16, 100);
                const lyre = new THREE.Mesh(lyreGeometry, material);
                lyre.position.set(0, 0.8 * scale, -0.3 * scale);
                characterGroup.add(lyre);
            }

            function addHat(characterGroup, material, scale) {
                const hatGeometry = new THREE.ConeGeometry(0.2 * scale, 0.3 * scale, 32);
                const hat = new THREE.Mesh(hatGeometry, material);
                hat.position.set(0, 0.55 * scale, 0);
                characterGroup.add(hat);
            }

            function addSword(characterGroup, material, scale) {
                const swordGeometry = new THREE.BoxGeometry(0.05 * scale, 0.7 * scale, 0.02 * scale);
                const sword = new THREE.Mesh(swordGeometry, material);
                sword.position.set(0.4 * scale, 0.4 * scale, 0.2 * scale);
                sword.rotation.z = Math.PI / 2;
                characterGroup.add(sword);
            }

            function addHammer(characterGroup, material, scale) {
                const hammerGeometry = new THREE.BoxGeometry(0.1 * scale, 0.5 * scale, 0.05 * scale);
                const hammer = new THREE.Mesh(hammerGeometry, material);
                hammer.position.set(-0.4 * scale, 0.4 * scale, 0.2 * scale);
                hammer.rotation.z = -Math.PI / 4;
                characterGroup.add(hammer);
            }

            function addAnvil(characterGroup, material, scale) {
                const anvilGeometry = new THREE.BoxGeometry(0.5 * scale, 0.2 * scale, 0.3 * scale);
                const anvil = new THREE.Mesh(anvilGeometry, material);
                anvil.position.set(0, -0.2 * scale, 0.2 * scale);
                characterGroup.add(anvil);
            }

            function addPotionVials(characterGroup, material, scale) {
                const vialGeometry = new THREE.SphereGeometry(0.05 * scale, 16, 16);
                const vial1 = new THREE.Mesh(vialGeometry, material);
                vial1.position.set(0.2 * scale, 0.5 * scale, -0.3 * scale);
                characterGroup.add(vial1);

                const vial2 = new THREE.Mesh(vialGeometry, material);
                vial2.position.set(-0.2 * scale, 0.5 * scale, -0.3 * scale);
                characterGroup.add(vial2);
            }

            // Check if the player is within interaction range of the shop character
            function checkShopInteraction() {
                if (currentShopCharacter && currentShopCharacter.mesh) {
                    const distance = camera.position.distanceTo(currentShopCharacter.mesh.position);

                    if (distance < interactionThreshold) {
                        if (!isShopOpen) {
                            openShop();
                            displayShopCharacterMessage();
                        }
                    } else {
                        if (isShopOpen) {
                            closeShop();
                            hideStatusMessage();
                        }
                    }
                }
            }


            // Display the shop character's unique message to the player
            function displayShopCharacterMessage() {
                if (currentShopCharacter) {
                    showStatusMessage(`${currentShopCharacter.name}: "${currentShopCharacter.message}"`);
                }
            }

            function createKeyMesh() {
                const keyGroup = new THREE.Group();

                // Shaft of the key
                const shaftGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
                const shaft = new THREE.Mesh(shaftGeometry, keyMaterial);
                shaft.rotation.z = Math.PI / 2;
                shaft.position.x = 0.4;
                keyGroup.add(shaft);

                // Bow of the key (handle)
                const bowGeometry = new THREE.TorusGeometry(0.2, 0.05, 8, 16);
                const bow = new THREE.Mesh(bowGeometry, keyMaterial);
                bow.position.x = 0;
                keyGroup.add(bow);

                // Teeth of the key
                const teethGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.05);
                const teeth = new THREE.Mesh(teethGeometry, keyMaterial);
                teeth.position.x = 0.8;
                teeth.position.y = -0.3;
                keyGroup.add(teeth);

                return keyGroup;
            }

            function showStatusMessage(message) {
                const statusEl = document.getElementById('status-message');
                statusEl.textContent = message;
                statusEl.style.display = 'block';
            }
                
            function hideStatusMessage() {
                document.getElementById('status-message').style.display = 'none';
            }
                
            function checkAllImagesLoaded() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    document.getElementById('loading-screen').style.display = 'none';
                    playerFrozen = false;
                    hideStatusMessage();
                }
            }
                
            const roomTextures = {};
                
            function loadRoomTextures(roomPrompt) {
                document.getElementById('loading-screen').style.display = 'flex'; 
                playerFrozen = true;
                showStatusMessage('Loading new room...');
                imagesLoaded = 0; 
                    
                const wallTexture = textureLoader.load('https://image.pollinations.ai/prompt/the%20wall%20texture%20to%20' + encodeURIComponent(roomPrompt), checkAllImagesLoaded);
                const floorTexture = textureLoader.load('https://image.pollinations.ai/prompt/the%20floor%20to%20' + encodeURIComponent(roomPrompt), checkAllImagesLoaded);
                const ceilingTexture = textureLoader.load('https://image.pollinations.ai/prompt/the%20ceiling%20to%20' + encodeURIComponent(roomPrompt), checkAllImagesLoaded);
                const doorTexture1 = textureLoader.load('https://image.pollinations.ai/prompt/a%20door%20to%20' + encodeURIComponent(roomPrompt), checkAllImagesLoaded);
                const doorTexture2 = textureLoader.load('https://image.pollinations.ai/prompt/another%20door%20to%20' + encodeURIComponent(roomPrompt), checkAllImagesLoaded);
                    
                return {
                    wall: wallTexture,
                    floor: floorTexture,
                    ceiling: ceilingTexture,
                    door1: doorTexture1,
                    door2: doorTexture2
                };
            }
                
            roomTextures['0,0'] = loadRoomTextures("A alien weird universe");
                
            let playerKeys = 0;
            let currentKeys = [];
            let isJumping = false;
            let yVelocity = 0;
            const GRAVITY = -0.09;
            const JUMP_POWER = 1.0;
            const FLOOR_HEIGHT = 2; // Ensure this matches the character's grounding
            
            const keyGeometry = new THREE.SphereGeometry(0.3);
            const keyMaterial = new THREE.MeshPhongMaterial({color: 0xFFD700});
            const landmineGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32);
            const landmineMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            let currentLandmines = [];
            let lastSavePosition = { x: 0, y: 0 };
            
            let inventory = new Array(5).fill(null);
            let selectedSlot = 0;
            let activeKeyMagnet = false;
            
            let isDragging = false;
            const mapOffset = { x: 0, y: 0 };
            const dragStart = { x: 0, y: 0 };
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            function playKeyCollectSound() {
                if (!playSfx) return;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 523.25; // C5 note
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            }
            
            function playSaveRoomSound() {
                if (!playSfx) return;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
            
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
            
                oscillator.type = 'triangle'; // Different waveform for a distinctive sound
                oscillator.frequency.value = 880; // A5 note
            
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            }
            
            function flashScreenGold() {
                const flashDiv = document.createElement('div');
                flashDiv.style.position = 'fixed';
                flashDiv.style.top = '0';
                flashDiv.style.left = '0';
                flashDiv.style.width = '100%';
                flashDiv.style.height = '100%';
                flashDiv.style.backgroundColor = 'rgba(255, 215, 0, 0.5)';
                flashDiv.style.zIndex = '1000';
                document.body.appendChild(flashDiv);
            
                setTimeout(() => {
                    flashDiv.style.transition = 'opacity 1s';
                    flashDiv.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(flashDiv);
                    }, 1000);
                }, 100);
            }
            
            function updateKeyDisplay() {
                const keyDisplay = document.getElementById('key-display');
                keyDisplay.textContent = `Keys: ${playerKeys}`;
            }
            
            function spawnKey() {
                const roomKey = `${roomPosition.x},${roomPosition.y}`;
                if (!roomData[roomKey]) {
                    roomData[roomKey] = {
                        keyPositions: [],
                        visited: false
                    };
                }
                if (!roomData[roomKey].visited) {
                    const numberOfKeys = 2 + Math.floor(Math.random() * 5);
                    for (let i = 0; i < numberOfKeys; i++) {
                        const isFloorKey = Math.random() < 0.5;
                        roomData[roomKey].keyPositions.push({
                            x: (Math.random() - 0.5) * (roomWidth - 4),
                            y: isFloorKey ? 1 : (2 + (Math.random() * 4)),
                            z: (Math.random() - 0.5) * (roomDepth - 4)
                        });
                    }
                    roomData[roomKey].visited = true;
                }
                currentKeys.forEach(key => scene.remove(key));
                currentKeys = [];
                roomData[roomKey].keyPositions.forEach(pos => {
                    const key = createKeyMesh();
                    key.position.set(pos.x, pos.y, pos.z);
                    scene.add(key);
                    currentKeys.push(key);
                });
            }

            function spawnLandmines() {
                const roomKey = `${roomPosition.x},${roomPosition.y}`;
                if (!roomData[roomKey].landminePositions) {
                    roomData[roomKey].landminePositions = [];
                    const numberOfLandmines = Math.floor(Math.random() * 3); // Up to 2 landmines per room
                    for (let i = 0; i < numberOfLandmines; i++) {
                        roomData[roomKey].landminePositions.push({
                            x: (Math.random() - 0.5) * (roomWidth - 4),
                            y: 0.1,
                            z: (Math.random() - 0.5) * (roomDepth - 4)
                        });
                    }
                }
            
                currentLandmines.forEach(mine => scene.remove(mine));
                currentLandmines = [];
            
                roomData[roomKey].landminePositions.forEach(pos => {
                    const mine = new THREE.Mesh(landmineGeometry, landmineMaterial);
                    mine.position.set(pos.x, pos.y, pos.z);
                    scene.add(mine);
                    currentLandmines.push(mine);
                });
            }
            
            function triggerDeath() {
                playerFrozen = true;
                document.getElementById('death-screen').style.display = 'flex';
            }
            
            document.getElementById('respawn-button').addEventListener('click', () => {
                document.getElementById('death-screen').style.display = 'none';
                playerFrozen = false;
                enterRoomAtPosition(lastSavePosition.x, lastSavePosition.y);
            });
            
            function enterRoomAtPosition(x, y) {
                currentKeys.forEach(key => scene.remove(key));
                currentKeys = [];
                currentLandmines.forEach(mine => scene.remove(mine));
                currentLandmines = [];

                if (currentShopCharacter && currentShopCharacter.mesh) {
                    scene.remove(currentShopCharacter.mesh);
                    if (currentShopCharacter.nameMesh) {
                        scene.remove(currentShopCharacter.nameMesh); // Remove name mesh as well
                    }
                    currentShopCharacter = null;
                }

                roomPosition.x = x;
                roomPosition.y = y;
            
                loadRoom();
            
                spawnKey();
                spawnLandmines();
                spawnShopCharacter(); // Spawn the enhanced shop character
            
                camera.position.set(0, FLOOR_HEIGHT, 0);
                document.getElementById('room-position').textContent = `Room (${roomPosition.x}, ${roomPosition.y})`;
            }
            
            function loadRoom() {
                const roomKey = `${roomPosition.x},${roomPosition.y}`;
                if (!roomPrompts[roomKey]) {
                    currentRoomPrompt = generateRandomRoomPrompt();
                    roomPrompts[roomKey] = currentRoomPrompt;
                    playerFrozen = true;
                    showStatusMessage('Loading new room...');
                    roomTextures[roomKey] = loadRoomTextures(currentRoomPrompt);
                } else {
                    currentRoomPrompt = roomPrompts[roomKey];
                    if (!roomTextures[roomKey]) {
                        playerFrozen = true;
                        showStatusMessage('Loading new room...');
                        roomTextures[roomKey] = loadRoomTextures(currentRoomPrompt);
                    }
                }
            
                if (roomTextures[roomKey]) {
                    updateRoomMaterials(roomTextures[roomKey]);
                }
                updateRoomDisplay();
                if (isSaveRoom()) {
                    lastSavePosition = { x: roomPosition.x, y: roomPosition.y };
                    playSaveRoomSound();
                    flashScreenGold();
                }
            }
            
            function isSaveRoom() {
                return (roomPosition.x % 20 === 0 && roomPosition.y % 20 === 0);
            }
            
            function generateRandomRoomPrompt() {
                if (isSaveRoom()) {
                    return "A shimmering golden sanctuary";
                } else {
                    const prompts = [
                        "An abandoned city overtaken by nature, where skyscrapers are draped in vines",
                        "A deserted underground bunker, echoing with the remnants of humanity's last hopes",
                        "A crumbling highway stretching through a wasteland of twisted metal and ash",
                        "A radioactive swamp glowing under a sickly moonlight",
                        "A ghost town once bustling with life, now haunted by the echoes of lost souls",
                        "A ruined library filled with burned books and forgotten knowledge, with only a few pages left intact",
                        "A rusted-out factory overrun by mutated creatures scavenging for scraps",
                        "A collapsed skyscraper turned into a dangerous maze of broken glass and crumbling walls",
                        "A decaying military base, now home to rogue scavengers and desperate survivors",
                        "A desolate suburban neighborhood, where the last signs of life are wild animals prowling",
                        "A cracked desert canyon, once a thriving metropolis, now nothing but dust and bones",
                        "A submerged city, its crumbled streets now teeming with dangerous sea life",
                        "A derelict train station where the last remaining trains rust in place, abandoned by the living",
                        "A rusted-out airship slowly drifting in the sky, its crew long dead or missing",
                        "A post-apocalyptic carnival, its rides long unmoving, but strange sounds still echo in the distance",
                        "The remnants of a futuristic research lab, now overrun by mutated creatures and glowing spores",
                        "An abandoned shopping mall, its once-bustling halls now a maze of wreckage and eerie silence",
                        "A silent forest of mutated trees that have adapted to the toxic air, casting unnatural shadows",
                        "An overgrown military graveyard, where soldiers' forgotten bones lie scattered among the weeds",
                        "The remains of a collapsed bridge, where once prosperous cities are now divided by a poisoned river",
                        "A hidden underground haven for survivors, surrounded by endless miles of hostile wilderness",
                        "A crumbled mansion where wealthy survivors once lived, now home to dangerous, wild animals",
                        "A lone survivor’s camp in the remains of a decimated city, surrounded by makeshift walls of scrap metal",
                        "A secret vault deep underground, its contents long forgotten, only guarded by strange robotic sentries",
                        "The last gas station on earth, its pumps rusted, and the land around it desolate and barren",
                        "A forgotten bunker for an ancient civilization, now a chilling reminder of their fall",
                        "A flooded subway system, where strange aquatic creatures swim beneath the broken tunnels",
                        "The remnants of a vast military compound, where dangerous experimental weapons were once tested",
                        "A crumbling theme park, its attractions overrun by mutated wildlife and the shadows of the past"
                    ];

                    return prompts[Math.floor(Math.random() * prompts.length)];
                }
            }
            
            function updateRoomMaterials(textures) { 
                frontWall.material = new THREE.MeshPhongMaterial({ map: textures.wall });
                backWall.material = new THREE.MeshPhongMaterial({ map: textures.wall }); 
                leftWall.material = new THREE.MeshPhongMaterial({ map: textures.wall });
                rightWall.material = new THREE.MeshPhongMaterial({ map: textures.wall });
                floor.material = new THREE.MeshPhongMaterial({ map: textures.floor });
                ceiling.material = new THREE.MeshPhongMaterial({ map: textures.ceiling });
                frontDoor.material = new THREE.MeshPhongMaterial({ map: textures.door1 });  
                backDoor.material = new THREE.MeshPhongMaterial({ map: textures.door2 });
                leftDoor.material = new THREE.MeshPhongMaterial({ map: textures.door1 });
                rightDoor.material = new THREE.MeshPhongMaterial({ map: textures.door2 });
            }
            
            const wallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
            const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const doorGeometry = new THREE.BoxGeometry(4, 8, 0.2);
            const floor = new THREE.Mesh(floorGeometry);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            const ceilingMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB });
            const ceiling = new THREE.Mesh(floorGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = roomHeight;
            scene.add(ceiling);
            
            const frontWall = new THREE.Mesh(wallGeometry); 
            frontWall.position.z = -roomDepth / 2;
            frontWall.position.y = roomHeight / 2;
            scene.add(frontWall);
            
            const backWall = new THREE.Mesh(wallGeometry);
            backWall.position.z = roomDepth / 2;
            backWall.position.y = roomHeight / 2;
            backWall.rotation.y = Math.PI;
            scene.add(backWall);
            
            const leftWall = new THREE.Mesh(wallGeometry);
            leftWall.position.x = -roomWidth / 2;
            leftWall.position.y = roomHeight / 2;
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeometry);
            rightWall.position.x = roomWidth / 2; 
            rightWall.position.y = roomHeight / 2;
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);
            
            const frontDoor = new THREE.Mesh(doorGeometry);
            frontDoor.position.z = -roomDepth / 2 + 0.1;
            frontDoor.position.y = 4;
            scene.add(frontDoor);
            
            const backDoor = new THREE.Mesh(doorGeometry);
            backDoor.position.z = roomDepth / 2 - 0.1;
            backDoor.position.y = 4;
            backDoor.rotation.y = Math.PI;
            scene.add(backDoor);
            
            const leftDoor = new THREE.Mesh(doorGeometry);
            leftDoor.position.x = -roomWidth / 2 + 0.1;
            leftDoor.position.y = 4;
            leftDoor.rotation.y = Math.PI / 2;
            scene.add(leftDoor);
            
            const rightDoor = new THREE.Mesh(doorGeometry);  
            rightDoor.position.x = roomWidth / 2 - 0.1;
            rightDoor.position.y = 4;
            rightDoor.rotation.y = -Math.PI / 2; 
            scene.add(rightDoor);
            
            updateRoomMaterials(roomTextures['0,0']);
            
            const light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(0, roomHeight / 2 - 1, 0);
            scene.add(light);
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            camera.position.y = FLOOR_HEIGHT;
            camera.rotation.order = 'YXZ';
            
            let moveForward = false;
            let moveBackward = false;
            let moveLeft = false;
            let moveRight = false;
            let turnLeft = false;
            let turnRight = false;
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            
            let roomPosition = {x: 0, y: 0};
            const visitedRooms = [];
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('shop-button').addEventListener('click', openShop);
            document.getElementById('settings-button').addEventListener('click', openSettings);
            document.getElementById('map-button').addEventListener('click', openMap);
            document.getElementById('close-map-button').addEventListener('click', closeMap);
            document.getElementById('key-master-button').addEventListener('click', openKeyMaster);
            document.getElementById('fullscreen-button').addEventListener('click', toggleFullscreen);
            
            // Fullscreen functionality
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        alert(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
            
            // Fullscreen change listener
            document.addEventListener('fullscreenchange', () => {
                const button = document.getElementById('fullscreen-button');
                button.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Enter Fullscreen';
            });
            
            // Initialize pointer lock status
            let isPointerLocked = false;
            let pendingPointerLock = false;  // Control pointer lock after settings
            
            // Function to request pointer lock
            function requestPointerLock() {
                if (!isPointerLocked) {
                    document.body.requestPointerLock();
                } else {
                    document.exitPointerLock();
                }
            }
            
            // Add event listener for pointer lock status changes
            document.addEventListener('pointerlockchange', () => {
                const pointerLockCheckbox = document.getElementById('pointer-lock');
                isPointerLocked = document.pointerLockElement === document.body;
                pointerLockCheckbox.checked = isPointerLocked; // Sync checkbox status
            });
            
            // Update camera rotation based on mouse movement
            document.addEventListener('mousemove', (event) => {
                if (isPointerLocked) {
                    const sensitivity = 0.002;
                    camera.rotation.y -= event.movementX * sensitivity;
                    camera.rotation.x -= event.movementY * sensitivity;
                    // Clamp pitch rotation
                    camera.rotation.x = Math.max(-maxPitch, Math.min(maxPitch, camera.rotation.x));
                }
            });
            
            // Add event listener for pointer lock toggle in settings
            document.getElementById('pointer-lock').addEventListener('change', (event) => {
                if (event.target.checked) {
                    pendingPointerLock = true;  // Set pending pointer lock
                } else {
                    document.exitPointerLock();
                }
            });
            
            // Mobile detection
            function isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            // Show joysticks and jump button if on mobile
            if (isMobile()) {
                document.querySelectorAll('.joystick-container').forEach(el => el.style.display = 'block');
                document.getElementById('mobile-jump-button').style.display = 'block';
            }
            
            // Joystick handling
            function handleJoystick(joystickEl, knobEl, callback) {
                let touchId = null;
                let startX, startY;
                const maxDistance = 35;
            
                function updateKnobPosition(x, y) {
                    const dx = x - startX;
                    const dy = y - startY;
                    const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
                    const angle = Math.atan2(dy, dx);
                    
                    const newX = distance * Math.cos(angle);
                    const newY = distance * Math.sin(angle);
                    
                    knobEl.style.transform = `translate(calc(-50% + ${newX}px), calc(-50% + ${newY}px))`;
                    callback(newX / maxDistance, newY / maxDistance);
                }
            
                joystickEl.addEventListener('touchstart', (e) => {
                    if (touchId === null) {
                        const touch = e.touches[0];
                        touchId = touch.identifier;
                        const rect = joystickEl.getBoundingClientRect();
                        startX = touch.clientX - rect.left;
                        startY = touch.clientY - rect.top;
                    }
                });
            
                joystickEl.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === touchId) {
                            const rect = joystickEl.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const y = touch.clientY - rect.top;
                            updateKnobPosition(x, y);
                            break;
                        }
                    }
                });
            
                function resetKnob() {
                    touchId = null;
                    knobEl.style.transform = 'translate(-50%, -50%)';
                    callback(0, 0);
                }
            
                joystickEl.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            resetKnob();
                            break;
                        }
                    }
                });
            
                joystickEl.addEventListener('touchcancel', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            resetKnob();
                            break;
                        }
                    }
                });
            }
            
            // Add jump button handler
            document.getElementById('mobile-jump-button').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isJumping) {
                    yVelocity = JUMP_POWER;
                    isJumping = true;
                }
            });
            
            // Initialize joysticks
            const movementJoystick = document.getElementById('movement-joystick');
            const cameraJoystick = document.getElementById('camera-joystick');
            
            handleJoystick(
                movementJoystick, 
                movementJoystick.querySelector('.joystick-knob'),
                (x, y) => {
                    moveForward = y < -0.5;
                    moveBackward = y > 0.5;
                    moveLeft = x < -0.5;
                    moveRight = x > 0.5;
                }
            );
            
            handleJoystick(
                cameraJoystick,
                cameraJoystick.querySelector('.joystick-knob'),
                (x, y) => {
                    turnLeft = x > 0.3;
                    turnRight = x < -0.3;
                    lookUp = y < -0.3;
                    lookDown = y > 0.3;
                }
            );
            
            function onKeyDown(event) {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                    case 'ArrowLeft':
                        turnRight = true;
                        break;
                    case 'ArrowRight':
                        turnLeft = true;
                        break;
                    case 'ArrowUp':
                        lookUp = true;
                        break;
                    case 'ArrowDown':
                        lookDown = true;
                        break;
                    case 'Space':
                        if (!isJumping) {
                            yVelocity = JUMP_POWER;
                            isJumping = true;
                        }
                        break;
                    case 'KeyE':
                        useSelectedItem();
                        break;
                    case 'Digit1':
                    case 'Digit2':  
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                        selectedSlot = parseInt(event.code.slice(-1)) - 1;
                        updateInventoryDisplay();
                        break;
                }
            }
            
            function onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                        moveRight = false;
                        break;
                    case 'ArrowLeft':
                        turnRight = false;
                        break;
                    case 'ArrowRight':
                        turnLeft = false;
                        break;
                    case 'ArrowUp':
                        lookUp = false;
                        break;
                    case 'ArrowDown':
                        lookDown = false;
                        break;
                }
            }
            
            function updateRoomDisplay() {
                document.getElementById('room-position').textContent = `Room (${roomPosition.x}, ${roomPosition.y})`;
            
                if (roomPosition.x === 0 && roomPosition.y === 0) {
                    document.getElementById('key-master-button').style.display = 'block';
                } else {
                    document.getElementById('key-master-button').style.display = 'none';
                }
            }
            
            function animate() {
                requestAnimationFrame(animate);
            
                yVelocity += GRAVITY;
                camera.position.y += yVelocity;
                
                if (camera.position.y <= FLOOR_HEIGHT) {
                    camera.position.y = FLOOR_HEIGHT;
                    yVelocity = 0;
                    isJumping = false;
                }
            
                if (!playerFrozen) {
                    const pickupRadius = BASE_PICKUP_RADIUS * (1 + pickupRadiusLevel);
                    for (let i = currentKeys.length - 1; i >= 0; i--) {
                        const key = currentKeys[i];
                        const keyDistance = new THREE.Vector2(
                            camera.position.x - key.position.x,
                            camera.position.z - key.position.z
                        ).length();
                        
                        if (keyDistance < pickupRadius) {
                            scene.remove(key);
                            currentKeys.splice(i, 1);
                            const roomKey = `${roomPosition.x},${roomPosition.y}`;
                            roomData[roomKey].keyPositions.splice(i, 1);
                            playerKeys++;
                            updateKeyDisplay();
                            playKeyCollectSound();
                        } else {
                            key.rotation.y += 0.02; // Spin the key
                        }
                    }

            
                    currentLandmines.forEach((mine, index) => {
                        const dx = camera.position.x - mine.position.x;
                        const dz = camera.position.z - mine.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance < 0.6) {
                            triggerDeath();
                            scene.remove(mine);
                            currentLandmines.splice(index, 1);
                            roomData[`${roomPosition.x},${roomPosition.y}`].landminePositions.splice(index, 1);
                        }
                    });
            
                    direction.set(
                        Number(moveRight) - Number(moveLeft),
                        0,
                        Number(moveBackward) - Number(moveForward)
                    );

                    // Check if the player is far enough from the shop character to close the shop interface
                    if (currentShopCharacter && currentShopCharacter.mesh) {
                        const distance = camera.position.distanceTo(currentShopCharacter.mesh.position);
                        const shopModal = document.getElementById('shop-modal');
                        const thresholdDistance = 5; // Set distance threshold

                        // Close the shop interface if the player moves beyond the threshold
                        if (distance > thresholdDistance && shopModal.style.display === 'block') {
                            closeShop();
                            hideStatusMessage(); // Hide the shop interaction message if it's displayed
                        }
                    }
            
                    const yaw = camera.rotation.y;
                    const yawQuaternion = new THREE.Quaternion();
                    yawQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            
                    direction.applyQuaternion(yawQuaternion);
                    direction.normalize();
                    
                    const frameVelocity = direction.multiplyScalar(speed);
                    velocity.lerp(frameVelocity, 0.2);
                    
                    const nextPosition = camera.position.clone().add(velocity);
                    if (Math.abs(nextPosition.x) < roomWidth / 2 - 1 &&
                        Math.abs(nextPosition.z) < roomDepth / 2 - 1) {
                        camera.position.add(velocity);
                    }
            
                    const doorCollisionThreshold = 2;
                    if (camera.position.z < -roomDepth / 2 + doorCollisionThreshold &&
                        Math.abs(camera.position.x) < 2) {
                        enterNewRoom(0, 1); 
                    } else if (camera.position.z > roomDepth / 2 - doorCollisionThreshold &&
                        Math.abs(camera.position.x) < 2) {
                        enterNewRoom(0, -1); 
                    } else if (camera.position.x < -roomWidth / 2 + doorCollisionThreshold &&
                        Math.abs(camera.position.z) < 2) {
                        enterNewRoom(-1, 0); 
                    } else if (camera.position.x > roomWidth / 2 - doorCollisionThreshold &&
                        Math.abs(camera.position.z) < 2) {
                        enterNewRoom(1, 0); 
                    }
            
                    camera.rotation.y -= turnLeft ? turnSpeed : turnRight ? -turnSpeed : 0;
            
                    // Update camera pitch
                    camera.rotation.x += lookUp ? turnSpeed : lookDown ? -turnSpeed : 0;
            
                    // Clamp camera pitch to between -maxPitch and maxPitch
                    if (camera.rotation.x > maxPitch) camera.rotation.x = maxPitch;
                    if (camera.rotation.x < -maxPitch) camera.rotation.x = -maxPitch;
                }
            
                // Handle key magnet and other active items
                    if (activeKeyMagnet) {
                        currentKeys.forEach(key => {
                            const directionToPlayer = new THREE.Vector3().subVectors(camera.position, key.position);
                            key.position.add(directionToPlayer.normalize().multiplyScalar(0.1));
                        });
                    }

                    // **Add the breathing animation tick here**
                    if (scene.userData.shopCharacterTick) {
                        scene.userData.shopCharacterTick();
                    }

                    // Check interactions with shop character
                    checkShopInteraction();

                    // **Make name tags face the camera**
                    if (currentShopCharacter && currentShopCharacter.nameMesh) {
                        currentShopCharacter.nameMesh.lookAt(camera.position.x, currentShopCharacter.nameMesh.position.y, camera.position.z);
                    }

                    renderer.render(scene, camera);
            }
            
            // Opens the shop popup and sets `isShopOpen` to true
            function openShop() {
                document.getElementById('shop-modal').style.display = 'block';
                isShopOpen = true;
            }

            // Closes the shop popup and sets `isShopOpen` to false
            function closeShop() {
                document.getElementById('shop-modal').style.display = 'none';
                isShopOpen = false;
            }
            
            function openMap() {
                document.getElementById('map-ui').style.display = 'block';
                generateMap();
                centerMapOnCurrentRoom();
                playerFrozen = true;
            }
            
            function closeMap() {
                document.getElementById('map-ui').style.display = 'none';
                document.getElementById('map-container').innerHTML = ''; // Clear the map
                playerFrozen = false;
            }
            
            function showShopTab(tab) {
                const itemsTab = document.getElementById('shop-items');
                const upgradesTab = document.getElementById('shop-upgrades');
                const itemsButton = document.querySelector('.shop-tab[onclick="showShopTab(\'items\')"]');
                const upgradesButton = document.querySelector('.shop-tab[onclick="showShopTab(\'upgrades\')"]');
            
                if (tab === 'items') {
                    itemsTab.style.display = 'block';
                    upgradesTab.style.display = 'none';
                    itemsButton.classList.add('active');
                    upgradesButton.classList.remove('active');
                } else if (tab === 'upgrades') {
                    itemsTab.style.display = 'none';
                    upgradesTab.style.display = 'block';
                    itemsButton.classList.remove('active');
                    upgradesButton.classList.add('active');
                }
            }
            
            function generateMap() {
                const mapContainer = document.getElementById('map-container');
                mapContainer.innerHTML = ''; // Clear previous content
            
                const minX = roomPosition.x - 20;
                const maxX = roomPosition.x + 20;
                const minY = roomPosition.y - 20;
                const maxY = roomPosition.y + 20;
            
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        const roomKey = `${x},${y}`;
                        const roomDiv = document.createElement('div');
                        roomDiv.textContent = `(${x}, ${y})`;
                        roomDiv.classList.add('room-box');
                        roomDiv.style.left = `${(x * 45) + 2000}px`; // Adjust scaling and offset as needed
                        roomDiv.style.top = `${(-y * 45) + 2000}px`;
            
                        if (x === 0 && y === 0) {
                            const iconUrl = 'https://image.pollinations.ai/prompt/' + encodeURIComponent('Make an icon for "A alien weird universe"');
                            roomDiv.style.backgroundImage = `url(${iconUrl})`;
                            roomDiv.style.backgroundColor = ''; // Remove background color if needed
                        } else if (roomPrompts[roomKey]) {
                            roomDiv.style.backgroundColor = 'green'; // Discovered room
                        } else {
                            roomDiv.style.backgroundColor = 'red'; // Undiscovered room
                        }
            
                        // Highlight current room
                        if (x === roomPosition.x && y === roomPosition.y) {
                            roomDiv.style.border = '2px solid yellow';
                        }
            
                        mapContainer.appendChild(roomDiv);
                    }
                }
            }
            
            function centerMapOnCurrentRoom() {
                const x = roomPosition.x;
                const y = roomPosition.y;
            
                mapOffset.x = window.innerWidth / 2 - ((x * 60) + 25 + 2000); // Adjust scaling and offset as needed
                mapOffset.y = window.innerHeight / 2 - ((-y * 60) + 25 + 2000);
            
                const mapContainer = document.getElementById('map-container');
                mapContainer.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }
            
            // Map dragging functionality
            const mapContainer = document.getElementById('map-container');
            mapContainer.addEventListener('mousedown', function(event) {
                isDragging = true;
                dragStart.x = event.clientX - mapOffset.x;
                dragStart.y = event.clientY - mapOffset.y;
                mapContainer.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', function(event) {
                if (isDragging) {
                    mapOffset.x = event.clientX - dragStart.x;
                    mapOffset.y = event.clientY - dragStart.y;
                    mapContainer.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
                }
            });
            
            document.addEventListener('mouseup', function() {
                isDragging = false;
                mapContainer.style.cursor = 'grab';
            });
            
            function executeTravel() {
                const x = parseInt(document.getElementById('travel-x').value);
                const y = parseInt(document.getElementById('travel-y').value);
                
                if (!isNaN(x) && !isNaN(y)) {
                    const dx = x - roomPosition.x;
                    const dy = y - roomPosition.y;
                    enterNewRoom(dx, dy);
                    closeTravelMenu();
                    inventory[selectedSlot] = null;
                    updateInventoryDisplay();
                }
            }
            
            function buyItem(itemId, price) {
                if (playerKeys >= price) {
                    const emptySlot = inventory.findIndex(slot => slot === null);
                    if (emptySlot !== -1) {
                        inventory[emptySlot] = itemId;
                        playerKeys -= price;
                        updateKeyDisplay();
                        updateInventoryDisplay();
                        closeShop();
                    } else {
                        alert('Inventory full!');
                    }
                } else {
                    alert('Not enough keys!');
                }
            }
            
            function buyUpgrade(type) {
                if (type === 'speed') {
                    const cost = 5;
                    if (playerKeys >= cost && speedUpgradeLevel < 5) {
                        playerKeys -= cost;
                        speedUpgradeLevel++;
                        updateKeyDisplay();
                        speed = BASE_SPEED * (1 + speedUpgradeLevel);
                        
                        const boxes = document.querySelectorAll('.upgrade-box:not(.pickup-radius)');
                        for (let i = 0; i < speedUpgradeLevel; i++) {
                            boxes[i].style.background = 'rgba(255,215,0,0.5)';
                        }
                    } else {
                        alert('Not enough keys or max level reached!');
                    }
                } else if (type === 'pickupRadius') {
                    const cost = 5;
                    if (playerKeys >= cost && pickupRadiusLevel < 5) {
                        playerKeys -= cost;
                        pickupRadiusLevel++;
                        updateKeyDisplay();
                        
                        const boxes = document.querySelectorAll('.upgrade-box.pickup-radius');
                        for (let i = 0; i < pickupRadiusLevel; i++) {
                            boxes[i].style.background = 'rgba(255,215,0,0.5)';
                        }
                    } else {
                        alert('Not enough keys or max level reached!');
                    }
                }
            }
            
            function updateInventoryDisplay() {
                const slots = document.querySelectorAll('.inventory-slot');
                slots.forEach((slot, index) => {
                    slot.textContent = inventory[index] || '';
                    slot.className = `inventory-slot${index === selectedSlot ? ' selected' : ''}`;
                });
            }
            
            function useSelectedItem() {
                const item = inventory[selectedSlot];
                if (item === 'keyMagnet') {
                    activeKeyMagnet = true;
                    playerFrozen = true;
                    showStatusMessage('Key Magnet Active');
                    setTimeout(() => {
                        activeKeyMagnet = false;
                        playerFrozen = false;
                        inventory[selectedSlot] = null;
                        updateInventoryDisplay();
                        hideStatusMessage();
                    }, 5000);
                } else if (item === 'travelStone') {
                    showTravelMenu();
                    setToSaveRoom();
                } else if (item === 'speedBoost') {
                    activateSpeedBoost();
                    inventory[selectedSlot] = null;
                    updateInventoryDisplay();
                } else if (item === 'shield') {
                    activateShield();
                    inventory[selectedSlot] = null;
                    updateInventoryDisplay();
                }
            }
            
            function activateSpeedBoost() {
                showStatusMessage('Speed Boost Active');
                const originalSpeed = speed;
                speed *= 2; // Double the speed
                setTimeout(() => {
                    speed = originalSpeed;
                    hideStatusMessage();
                }, 5000); // Lasts for 5 seconds
            }
            
            let shieldActive = false;
            
            function activateShield() {
                shieldActive = true;
                showStatusMessage('Shield Active');
                setTimeout(() => {
                    shieldActive = false;
                    hideStatusMessage();
                }, 10000); // Lasts for 10 seconds
            }
            
            // Modify triggerDeath function to account for shield
            function triggerDeath() {
                if (shieldActive) {
                    shieldActive = false;
                    hideStatusMessage();
                } else {
                    playerFrozen = true;
                    document.getElementById('death-screen').style.display = 'flex';
                }
            }
            
            function enterNewRoom(dx, dy) {
                currentKeys.forEach(key => scene.remove(key));
                currentKeys = [];
                currentLandmines.forEach(mine => scene.remove(mine));
                currentLandmines = [];
            
                roomPosition.x += dx;
                roomPosition.y += dy;
            
                loadRoom();
            
                spawnKey();
                spawnLandmines();
            
                camera.position.set(0, FLOOR_HEIGHT, 0);
                document.getElementById('room-position').textContent = `Room (${roomPosition.x}, ${roomPosition.y})`;
            }
            
            window.addEventListener('resize', onWindowResize, false);
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            const titleScreen = document.getElementById('title-screen');
            const captionSpans = document.querySelectorAll('#caption span');
            
            let delay = 0;
            captionSpans.forEach(span => {
                setTimeout(() => span.style.opacity = 1, delay);
                delay += 500;
            });
            
            setTimeout(() => titleScreen.style.opacity = 0, delay + 1000);
            setTimeout(() => {
                titleScreen.style.opacity = 0;
                titleScreen.style.display = 'none';
                enterRoomAtPosition(0, 0); // Set starting room position to (0, 0)
            }, delay + 2000);
            
            showStatusMessage('Loading initial room...');
            updateInventoryDisplay();
            animate();
            
            function openKeyMaster() {
                document.getElementById('key-master-modal').style.display = 'block';
            }
            
            function closeKeyMaster() {
                document.getElementById('key-master-modal').style.display = 'none';
            }
            
            let keysDonated = 0;
            let playerLevel = 1;
            
            function donateKeys() {
                const input = document.getElementById('donation-amount');
                const amount = parseInt(input.value);
            
                if (isNaN(amount) || amount <= 0) {
                    alert('Please enter a valid amount of keys to donate.');
                    return;
                }
            
                if (playerKeys >= amount) {
                    playerKeys -= amount;
                    keysDonated += amount;
                    updateKeyDisplay();
            
                    document.getElementById('key-master-status').textContent = `You have donated ${keysDonated} keys.`;
            
                    if (keysDonated >= 200) {
                        levelUp();
                        keysDonated -= 200; // Reset after leveling up
                        document.getElementById('key-master-status').textContent = `You have leveled up! Your new level is ${playerLevel}. Keys donated towards next level: ${keysDonated}`;
                    }
                } else {
                    alert('You do not have enough keys to donate.');
                }
            }
            
            function levelUp() {
                playerLevel += 1;
                alert(`Congratulations! You have leveled up to level ${playerLevel}!`);
            }
            
            function showTravelMenu() {
                playerFrozen = true;
                document.getElementById('travel-menu').style.display = 'block';
            }
            
            function closeTravelMenu() {
                playerFrozen = false;
                document.getElementById('travel-menu').style.display = 'none';
            }
            
            function setToSaveRoom() {
                document.getElementById('travel-x').value = lastSavePosition.x;
                document.getElementById('travel-y').value = lastSavePosition.y;
            }
            
            function openSettings() {
                document.getElementById('settings-modal').style.display = 'block';
                playerFrozen = true;
            }
            
            function closeSettings() {
                document.getElementById('settings-modal').style.display = 'none';
                playerFrozen = false;
            
                if (pendingPointerLock) {
                    requestPointerLock();
                    pendingPointerLock = false;  // Reset pending status
                }
            }
            
            // Instructions toggle functionality
            const instructionsToggle = document.getElementById('instructions-toggle');
            instructionsToggle.addEventListener('click', () => {
                const instructions = document.getElementById('instructions');
                if (instructions.style.display === 'none') {
                    instructions.style.display = 'block';
                    instructionsToggle.textContent = '/\\';
                } else {
                    instructions.style.display = 'none';
                    instructionsToggle.textContent = '\\/';
                }
            });
            
            document.getElementById('play-sfx').addEventListener('change', (e) => {
                playSfx = e.target.checked;
            });
            
            document.getElementById('show-instructions').addEventListener('change', (e) => {
                showInstructions = e.target.checked;
                document.getElementById('instructions').style.display = showInstructions ? 'block' : 'none';
                if (showInstructions) {
                    showStatusMessage('Instructions displayed.');
                }
            });
            
            document.getElementById('fov').addEventListener('input', (e) => {
                const fov = parseInt(e.target.value);
                camera.fov = fov;
                camera.updateProjectionMatrix();
            });
            
            const uiScaleSlider = document.getElementById('ui-scale'); 
            let playSfx = true;  // Already exists but let's make sure it's set to true
            let showInstructions = true;
            const scalableElements = [
                '#instructions',
                '#room-position',
                '#key-display',
                '#shop-button',
                '#map-button',
                '#inventory .inventory-slot',
                '#key-master-button',
                '#shop-modal',
                '#key-master-modal',
                '#travel-menu',
                '#status-message',
                '.joystick-container',
                '#mobile-jump-button'
            ];
            
            uiScaleSlider.addEventListener('input', (e) => {
                uiScale = e.target.value / 100;
                updateUIScale();
            });

            function checkShopCharacterNameVisibility() {
                if (currentShopCharacter && currentShopCharacter.mesh && currentShopCharacter.nameMesh) {
                    const distance = camera.position.distanceTo(currentShopCharacter.mesh.position);
                    const nameText = currentShopCharacter.nameMesh; // Retrieve the name text mesh

                    if (distance < 5) { // Show name within 5 units
                        if (!nameText.parent) {  // Ensure name text is added to the scene if not already
                            scene.add(nameText);
                        }
                    } else {
                        if (nameText.parent) {
                            scene.remove(nameText); // Hide the name text if out of range
                        }
                    }
                }
            }



            
            function updateUIScale() {
                const root = document.documentElement;
                root.style.setProperty('--ui-scale', uiScale);
                
                // Add base y positions for elements that need vertical scaling
                const yPositions = {
                    '#key-display': 65,
                    '#map-button': 65,
                    '#settings-button': 110
                };
                
                scalableElements.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        const originalFontSize = window.getComputedStyle(el).getPropertyValue('--original-font-size') || '16px';
                        const originalPadding = window.getComputedStyle(el).getPropertyValue('--original-padding') || '10px';
                        
                        // Scale font size
                        const baseFontSize = parseInt(originalFontSize);
                        el.style.fontSize = `${baseFontSize * uiScale}px`;
                        
                        // Scale padding
                        const basePadding = parseInt(originalPadding);
                        el.style.padding = `${basePadding * uiScale}px`;
                        
                        // Scale Y position if defined
                        if (yPositions[selector]) {
                            el.style.top = `${yPositions[selector] * uiScale}px`;
                        }
                        
                        // Scale width and height for specific elements
                        if (selector === '#inventory .inventory-slot') {
                            el.style.width = `${50 * uiScale}px`;
                            el.style.height = `${50 * uiScale}px`;
                        }
                        if (selector === '.joystick-container') {
                            el.style.width = `${120 * uiScale}px`;
                            el.style.height = `${120 * uiScale}px`;
                        }
                        if (selector === '#mobile-jump-button') {
                            el.style.width = `${80 * uiScale}px`;
                            el.style.height = `${80 * uiScale}px`;
                        }
                    });
                });
            }

            document.addEventListener('keydown', function(event) {
                if (event.key === 'f') { // When F key is pressed
                    if (currentShopCharacter) {
                        const distance = camera.position.distanceTo(currentShopCharacter.mesh.position);
                        if (distance < 1) { // If within 1 unit
                            openShop();  // Open the shop interface
                            showStatusMessage(`You are interacting with ${currentShopCharacter.name}.`);
                        }
                    }
                }
            });


            
            // Store original sizes when the page loads
            window.addEventListener('load', () => {
                scalableElements.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        const style = window.getComputedStyle(el);
                        el.style.setProperty('--original-font-size', style.fontSize);
                        el.style.setProperty('--original-padding', style.padding);
                    });
                });
            });

            function openInventory() {
                document.getElementById('inventory-modal').style.display = 'block';
            }

            function closeInventory() {
                document.getElementById('inventory-modal').style.display = 'none';
            }

            document.addEventListener('keydown', function(event) {
                if (event.key === 'I' || event.key === 'i') {
                    const inventoryModal = document.getElementById('inventory-modal');
                    inventoryModal.style.display = inventoryModal.style.display === 'none' ? 'block' : 'none';
                }
            });

        </script>
    </body>
</html>