<html><head><base href="
    ">
    <title>RODv0.011</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { display: block; }
        #inventory, #stats {
            position: absolute;
            width: 850px; /* Adjusted width for new inventory layout */
            height: 650px; /* Adjusted height for new inventory layout */
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 10;
            overflow-y: auto; /* Allow scrolling if content overflows vertically */
        }
        #inventory { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #stats {
            position: absolute;
            width: 800px;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 10;
            overflow-y: auto;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #stats button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        #hotbar {
            position: absolute;
            bottom: 10px; /* Adjusted position */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }
        .slot {
            width: 64px;
            height: 64px;
            border: 2px solid #555;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background 0.2s;
        }
        .slot:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #minimapContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid #fff;
            overflow: hidden;
            z-index: 5;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }
        #inventoryTabs {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .inventory-tab {
            padding: 5px 10px;
            background-color: #333;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        .inventory-tab.active {
            background-color: #555;
        }
        .inventory-tab-content {
            display: none;
        }
        .inventory-tab-content.active {
            display: block;
        }
        .inventoryGrid {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-auto-rows: 50px;
            gap: 2px;
            margin-top: 10px;
            overflow-y: auto;
            max-height: 500px;
        }
        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 1px solid #fff;
            background: rgba(255, 255, 255, 0.1);
        }
        #npcPopup {
            position: absolute;
            width: 400px;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 10;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #lifeOrb {
            position: absolute;
            bottom: 100px; /* Adjusted position */
            left: 20px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center, #8B0000, #FF0000);
            border: 2px solid #fff;
            border-radius: 50%;
            overflow: hidden;
            z-index: 5;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #lifeFill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Dynamically adjusted via JavaScript */
            background: linear-gradient(to top, #FF4500, #8B0000);
            transition: height 0.3s ease-in-out;
        }
        #lifeValue {
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            transform: translateY(-50%);
            z-index: 1;
            text-shadow: 1px 1px 2px #000;
        }
        #energyOrb {
            position: absolute;
            bottom: 100px; /* Matched with health orb */
            right: 20px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center, #00008B, #0000FF);
            border: 2px solid #fff;
            border-radius: 50%;
            overflow: hidden;
            z-index: 5;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #energyValue {
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            transform: translateY(-50%);
            z-index: 1;
            text-shadow: 1px 1px 2px #000;
        }
        #teleportationBarContainer {
            position: absolute;
            bottom: 50%;
            left: 50%;
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            transform: translate(-50%, 50%);
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            display: none;
        }
        #teleportationBar {
            width: 0%;
            height: 100%;
            background-color: #00ff00;
        }
        #adminConsole {
		position: fixed;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 500px; /* Increased width for better readability */
		max-height: 90%;
		background: rgba(30, 30, 30, 0.95); /* Darker background */
		color: #fff;
		padding: 20px;
		border: 2px solid #aaa;
		z-index: 100;
		overflow-y: auto;
		border-radius: 8px; /* Rounded corners */
		box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); /* Soft shadow */
	}

		#adminConsole h3 {
			margin-top: 15px;
			padding-bottom: 5px;
			border-bottom: 1px solid #555; /* Underline section headers */
			font-size: 16px;
		}

		#adminConsole section {
			margin-bottom: 15px;
			padding: 10px;
			background: rgba(50, 50, 50, 0.8); /* Section background */
			border-radius: 5px;
		}

		#adminConsole input,
		#adminConsole select,
		#adminConsole button {
			width: calc(100% - 20px);
			margin: 5px 0;
			padding: 5px;
			border-radius: 4px;
			border: 1px solid #777;
			background: #222;
			color: #fff;
		}

		#adminConsole button {
			background: #444;
			cursor: pointer;
			transition: background 0.3s;
		}

		#adminConsole button:hover {
			background: #555;
		}

		.collapsible {
			background: #333;
			color: white;
			cursor: pointer;
			padding: 10px;
			width: 100%;
			border: none;
			text-align: left;
			outline: none;
			font-size: 15px;
			margin-bottom: 5px;
			border-radius: 5px;
		}

		.collapsible.active,
		.collapsible:hover {
			background: #444;
		}

		.content {
			padding: 0 15px;
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease-out;
			background-color: rgba(50, 50, 50, 0.9);
			margin-bottom: 10px;
			border-radius: 5px;
		}

        #lootBarContainer {
            position: absolute;
            bottom: 50%;
            left: 50%;
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            transform: translate(-50%, 50%);
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            display: none;
        }
        #lootBar {
            width: 0%;
            height: 100%;
            background-color: #ffff00;
        }
        #lootPopup {
            position: absolute;
            width: 400px;
            height: auto;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 10;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        #npcAdminPopup {
            position: absolute;
            width: 400px;
            height: auto;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 100;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow-y: auto;
        }
        #npcAdminPopup input,
        #npcAdminPopup textarea {
            width: 100%;
            margin-bottom: 10px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
        }
        #npcAdminPopup button {
            margin-right: 10px;
        }
        #chestPopup {
            position: absolute;
            width: 800px;
            max-height: 90%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border: 2px solid #aaa;
            z-index: 10;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow-y: auto;
            display: none;
        }
        #chestInventoryContainer {
            display: flex;
            gap: 20px;
        }
        #chestPopup .inventoryGrid {
            max-height: 400px;
            overflow-y: auto;
        }
        #chestPopup .inventoryGrid {
            display: grid;
            grid-template-columns: repeat(7, 50px); /* Adjust columns as needed */
            grid-auto-rows: 50px;
            gap: 2px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="inventory">
        <h2>Inventory</h2>
        <p>Gold: <span id="goldAmount">0</span></p>
        <div id="inventoryTabs">
            <button class="inventory-tab" data-tab="tab1">Tab 1</button>
            <button class="inventory-tab" data-tab="tab2">Tab 2</button>
            <button class="inventory-tab" data-tab="tab3">Tab 3</button>
            <button class="inventory-tab" data-tab="tab4">Tab 4</button>
            <button class="inventory-tab" data-tab="tab5">Tab 5</button>
            <button class="inventory-tab" data-tab="tab6">Tab 6</button>
        </div>
        <div id="inventoryTabsContent">
            <div class="inventory-tab-content" id="tab1">
                <div class="inventoryGrid" id="inventoryGridTab1"></div>
            </div>
            <div class="inventory-tab-content" id="tab2">
                <div class="inventoryGrid" id="inventoryGridTab2"></div>
            </div>
            <div class="inventory-tab-content" id="tab3">
                <div class="inventoryGrid" id="inventoryGridTab3"></div>
            </div>
            <div class="inventory-tab-content" id="tab4">
                <div class="inventoryGrid" id="inventoryGridTab4"></div>
            </div>
            <div class="inventory-tab-content" id="tab5">
                <div class="inventoryGrid" id="inventoryGridTab5"></div>
            </div>
            <div class="inventory-tab-content" id="tab6">
                <div class="inventoryGrid" id="inventoryGridTab6"></div>
            </div>
        </div>
		<div id="playerOutlineContainer">
			<canvas id="playerOutlineCanvas" width="200" height="500"></canvas>
		</div>
    </div>
    <div id="stats">
        <h2>Character Stats</h2>
        <p>Level: <span id="level">1</span></p>
        <p>Experience: <span id="experience">0</span> / <span id="nextLevelExperience">100</span></p>
        <p>Strength: <span id="strength">10</span></p>
        <p>Dexterity: <span id="dexterity">10</span></p>
        <p>Vitality: <span id="vitality">10</span></p>
        <p>Energy: <span id="energy">10</span></p>
        <p>Available Stat Points: <span id="statPoints">0</span></p>
        <button onclick="increaseStat('strength')">Increase Strength</button>
        <button onclick="increaseStat('dexterity')">Increase Dexterity</button>
        <button onclick="increaseStat('vitality')">Increase Vitality</button>
        <button onclick="increaseStat('energy')">Increase Energy</button>
    </div>
    <div id="hotbar">
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
    </div>
    <div id="minimapContainer"></div>
    <div id="npcPopup" style="display: none;">
        <h2>Friendly NPC</h2>
        <p>Hello, traveler! Stay awhile and listen...</p>
        <button onclick="closeNpcPopup()">Close</button>
    </div>
    <div id="lifeOrb">
        <div id="lifeFill"></div>
        <div id="lifeValue">100/100</div>
    </div>
    <div id="energyOrb">
        <div id="energyValue">1/1</div>
    </div>
    <div id="teleportationBarContainer">
        <div id="teleportationBar"></div>
    </div>
    <div id="adminConsole" style="display: none;">
        <div id="adminLogin">
            <h2>Admin Console</h2>
            <p>Please enter the admin password:</p>
            <input type="password" id="adminPassword">
            <button onclick="checkAdminPassword()">Submit</button>
        </div>
        <div id="adminControls" style="display: none;">
            <h2>Admin Controls</h2>
            <section>
                <h3>Player Stats</h3>
                <p>Health: <input type="number" id="playerHealthInput" value="100" step="1"></p>
                <p>Gold: <input type="number" id="playerGoldInput" value="0" step="1"></p>
                <p>Experience: <input type="number" id="playerExperienceInput" value="0" step="1"></p>
                <button onclick="updatePlayerStats()">Update Player Stats</button>
            </section>
			<section>
				<h3>Weather Options</h3>
				<p>Select Weather:</p>
				<select id="weatherSelect">
					<option value="none">None</option>
					<option value="rain">Rain</option>
					<option value="snow">Snow</option>
					<option value="fog">Fog</option>
				</select>
				<button onclick="applyWeatherEffect()">Apply Weather</button>
			</section>
            <section>
                <h3>Player Options</h3>
                <p>
                    <label>
                        <input type="checkbox" id="invulnerabilityCheckbox"> Invulnerable
                    </label>
                </p>
                <button onclick="updatePlayerOptions()">Update Player Options</button>
            </section>
            <section>
                <h3>Spawn Options</h3>
                <p>Entity Type:
                    <select id="entityTypeSelect">
                        <option value="enemy">Enemy</option>
                        <option value="friendlyNPC">Friendly NPC</option>
                        <option value="structure">Structure</option>
                        <option value="treasureChest">Treasure Chest</option> 
                    </select>
                </p>
                <p>Quantity: <input type="number" id="entityQuantityInput" value="1" step="1" min="1"></p>
                <button onclick="spawnEntities()">Spawn Entities</button>
            </section>
            <section>
                <h3>Game Settings</h3>
                <p>Enemy Speed: <input type="number" id="enemySpeedInput" value="0.7" step="0.1"></p>
                <button onclick="updateGameSettings()">Update Game Settings</button>
            </section>
            <section>
                <h3>Teleport Player</h3>
                <p>X: <input type="number" id="teleportXInput" value="0" step="1"></p>
                <p>Z: <input type="number" id="teleportZInput" value="0" step="1"></p>
                <button onclick="teleportPlayer()">Teleport Player</button>
            </section>
            <section>
                <h3>NPC Admin</h3>
                <p>
                    <label>
                        <input type="checkbox" id="npcAdminCheckbox"> Enable NPC Admin Mode
                    </label>
                </p>
            </section>
            <button onclick="closeAdminConsole()">Close</button>
        </div>
    </div>
    <div id="lootBarContainer">
        <div id="lootBar"></div>
    </div>
    <div id="lootPopup">
        <h2>Loot</h2>
        <div id="lootItems"></div>
        <button onclick="lootAllItems()">Loot All</button>
    </div>
    <div id="npcAdminPopup" style="display: none;">
        <h2>NPC Admin</h2>
        <p>Name: <input type="text" id="npcNameInput"></p>
        <p>Health: <input type="number" id="npcHealthInput" step="1"></p>
        <p>Dialogue:</p>
        <textarea id="npcDialogueInput" rows="4" cols="50"></textarea>
        <br>
        <button onclick="saveNpcChanges()">Save Changes</button>
        <button onclick="closeNpcAdminPopup()">Close</button>
    </div>
    <div id="chestPopup" style="display: none;">
        <h2>Chest Interaction</h2>
        <div id="chestInventoryContainer">
            <div>
                <h3>Chest Inventory</h3>
                <div id="chestInventoryGrid" class="inventoryGrid"></div>
            </div>
            <div>
                <h3>Your Inventory</h3>
                <div id="playerInventoryInChestGrid" class="inventoryGrid"></div>
            </div>
        </div>
        <button onclick="closeChestPopup()">Close</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script>
        const clock = new THREE.Clock();
        let scene, camera, renderer;
        let player, ground, safeZoneGround;
        let inventoryOpen = false;
        let statsOpen = false;
        let destination = null;
        let speed = 1.0;
        let minimapCamera;
        let enemies = [];
        let gold = 0;
        const townRadius = 200;
        let walls = [];
        let friendlies = [];
        let isTeleporting = false;
        let teleportProgress = 0;
        let teleportationDuration = 3; // Duration in seconds
        let previousPosition = null;
        let cameraAngle = 0;
        let adminConsoleOpen = false; // Add this variable for admin console
        let enemyWalls = []; // Walls that affect only enemies
        let npcPopupOpen = false; // Track NPC popup state
        let npcAdminEnabled = false;
        let currentNpc = null;
        let currentOpenedChest = null; // Added to address the popup issue
        let treasureChests = []; // Added to keep track of treasure chests

        // Global variable for enemy speed
        let globalEnemySpeed = 0.7;

        // Player health and energy
        let playerHealth = 100;
        const playerMaxHealth = 100;
        let playerEnergy = 1;
        const playerMaxEnergy = 1;

		// Expanded loot table with different item types and rarity levels
		const lootTable = [
			// Common items
			{ name: 'Rusty Sword', type: 'weapon', attack: 2, rarity: 'common', value: 5 },
			{ name: 'Old Shield', type: 'armor', defense: 1, rarity: 'common', value: 4 },
			{ name: 'Leather Boots', type: 'armor', defense: 1, rarity: 'common', value: 3 },
			{ name: 'Cloth Armor', type: 'armor', defense: 2, rarity: 'common', value: 5 },
			{ name: 'Small Health Potion', type: 'consumable', healthRestore: 10, rarity: 'common', value: 2 },
			{ name: 'Small Mana Potion', type: 'consumable', manaRestore: 10, rarity: 'common', value: 2 },

			// Uncommon items
			{ name: 'Iron Sword', type: 'weapon', attack: 5, rarity: 'uncommon', value: 15 },
			{ name: 'Steel Shield', type: 'armor', defense: 3, rarity: 'uncommon', value: 12 },
			{ name: 'Chainmail Armor', type: 'armor', defense: 4, rarity: 'uncommon', value: 18 },
			{ name: 'Medium Health Potion', type: 'consumable', healthRestore: 25, rarity: 'uncommon', value: 6 },
			{ name: 'Medium Mana Potion', type: 'consumable', manaRestore: 25, rarity: 'uncommon', value: 6 },

			// Rare items
			{ name: 'Silver Sword', type: 'weapon', attack: 10, rarity: 'rare', value: 40 },
			{ name: 'Golden Shield', type: 'armor', defense: 7, rarity: 'rare', value: 35 },
			{ name: 'Plate Armor', type: 'armor', defense: 8, rarity: 'rare', value: 50 },
			{ name: 'Large Health Potion', type: 'consumable', healthRestore: 50, rarity: 'rare', value: 15 },
			{ name: 'Large Mana Potion', type: 'consumable', manaRestore: 50, rarity: 'rare', value: 15 },

			// Epic items
			{ name: 'Dragon Blade', type: 'weapon', attack: 20, rarity: 'epic', value: 100, specialEffect: 'fire damage' },
			{ name: 'Phoenix Shield', type: 'armor', defense: 12, rarity: 'epic', value: 90, specialEffect: 'reflect damage' },
			{ name: 'Mithril Armor', type: 'armor', defense: 15, rarity: 'epic', value: 120, specialEffect: 'speed boost' },
			{ name: 'Elixir of Life', type: 'consumable', healthRestore: 100, rarity: 'epic', value: 50, specialEffect: 'regeneration' },
			{ name: 'Elixir of Power', type: 'consumable', manaRestore: 100, rarity: 'epic', value: 50, specialEffect: 'mana regeneration' }
		];

		
        // Invulnerability variable
        let playerInvulnerable = false;

        // Looting variables
        let isLooting = false;
        let lootProgress = 0;
        const lootDuration = 2; // Duration in seconds
        let lootedItems = [];
        let currentLootingEnemy = null;

        // Initialize Character Stats
        let characterStats = {
            level: 1,
            experience: 0,
            nextLevelExperience: 100,
            strength: 10,
            dexterity: 10,
            vitality: 10,
            energy: 10,
            statPoints: 0
        };

        // Player inventory
        let playerInventory = [];

        function playAttackAnimation() {
            player.isAttacking = true;
            player.attackTime = 0;
        }

        function updateGoldDisplay() {
            document.getElementById('goldAmount').innerText = gold;
        }

        function updateHealthDisplay() {
            document.getElementById('lifeValue').innerText = `${playerHealth}/${playerMaxHealth}`;
            let healthPercent = (playerHealth / playerMaxHealth) * 100;
            document.getElementById('lifeFill').style.height = `${healthPercent}%`;
        }

        function updateEnergyDisplay() {
            document.getElementById('energyValue').innerText = `${playerEnergy}/${playerMaxEnergy}`;
            let energyPercent = (playerEnergy / playerMaxEnergy) * 100;
            document.getElementById('energyOrb').style.clipPath = `inset(${100 - energyPercent}% 0 0 0)`;
        }

		function generateRandomItems(count) {
			const items = [];
			for (let i = 0; i < count; i++) {
				const randomItem = getRandomLoot();
				items.push(randomItem);
			}
			return items;
		}


		// Function to get a random item from the loot table based on rarity
		function getRandomLoot() {
			const randomNumber = Math.random() * 100;

			let filteredItems;
			if (randomNumber < 60) {
				filteredItems = lootTable.filter(item => item.rarity === 'common');
			} else if (randomNumber < 85) {
				filteredItems = lootTable.filter(item => item.rarity === 'uncommon');
			} else if (randomNumber < 95) {
				filteredItems = lootTable.filter(item => item.rarity === 'rare');
			} else {
				filteredItems = lootTable.filter(item => item.rarity === 'epic');
			}

			return filteredItems[Math.floor(Math.random() * filteredItems.length)];
		}


        function addExperience(amount) {
            characterStats.experience += amount;
            if (characterStats.experience >= characterStats.nextLevelExperience) {
                levelUp();
            }
            updateStatsDisplay();
        }

        function openNpcPopup(npc) {
            if (npcPopupOpen) {
                closeNpcPopup();
                return;
            }
            document.getElementById('npcPopup').querySelector('h2').innerText = npc.userData.name || 'Friendly NPC';
            document.getElementById('npcPopup').querySelector('p').innerText = npc.userData.dialogue || 'Hello, traveler! Stay awhile and listen...';
            document.getElementById('npcPopup').style.display = 'block';
            npcPopupOpen = true;
        }

        function closeNpcPopup() {
            document.getElementById('npcPopup').style.display = 'none';
            npcPopupOpen = false;
        }

        function openNpcAdminPopup(npc) {
            currentNpc = npc;
            document.getElementById('npcNameInput').value = npc.userData.name || '';
            document.getElementById('npcHealthInput').value = npc.userData.health || 100;
            document.getElementById('npcDialogueInput').value = npc.userData.dialogue || '';
            document.getElementById('npcAdminPopup').style.display = 'block';
        }

        function closeNpcAdminPopup() {
            document.getElementById('npcAdminPopup').style.display = 'none';
            currentNpc = null;
        }

        function saveNpcChanges() {
            if (currentNpc) {
                currentNpc.userData.name = document.getElementById('npcNameInput').value;
                currentNpc.userData.health = parseInt(document.getElementById('npcHealthInput').value) || 100;
                currentNpc.userData.dialogue = document.getElementById('npcDialogueInput').value;
                alert('NPC changes saved.');
                closeNpcAdminPopup();
            }
        }

        function damagePlayer(amount) {
            if (playerInvulnerable) return; // Player is invulnerable
            playerHealth -= amount;
            if (playerHealth <= 0) {
                playerHealth = 0;
                alert('You have been defeated!');
            }
            updateHealthDisplay();
        }

        function startTeleportation() {
            isTeleporting = true;
            teleportProgress = 0;
            document.getElementById('teleportationBarContainer').style.display = 'block';
        }

        function updateTeleportation(delta) {
            if (isTeleporting) {
                teleportProgress += delta;
                const progressBar = document.getElementById('teleportationBar');
                progressBar.style.width = (teleportProgress / teleportationDuration) * 100 + '%';
                if (teleportProgress >= teleportationDuration) {
                    isTeleporting = false;
                    document.getElementById('teleportationBarContainer').style.display = 'none';
                    progressBar.style.width = '0%';
                    teleportToSafeZone();
                }
            }
        }

        function teleportToSafeZone() {
            previousPosition = player.position.clone(); // Save current position
            player.position.set(0, 0, 0); // Teleport to the center of the shrine
            destination = null; // Stop any movement
        }

        function createHumanoid(color) {
            const group = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(5, 10, 2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 10;
            group.add(body);

            const headGeometry = new THREE.BoxGeometry(3, 3, 3);
            const headMaterial = new THREE.MeshLambertMaterial({ color });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 17;
            group.add(head);

            const armGeometry = new THREE.BoxGeometry(1, 8, 1);
            const armMaterial = new THREE.MeshLambertMaterial({ color });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-3.5, 10, 0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(3.5, 10, 0);
            group.add(rightArm);

            const legGeometry = new THREE.BoxGeometry(2, 10, 2);
            const legMaterial = new THREE.MeshLambertMaterial({ color });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-1, 5, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(1, 5, 0);
            group.add(rightLeg);

            group.head = head;
            group.body = body;
            group.leftArm = leftArm;
            group.rightArm = rightArm;
            group.leftLeg = leftLeg;
            group.rightLeg = rightLeg;

            group.animationTime = 0;
            group.animationSpeed = 10.0;
            group.isMoving = false;
            group.isAttacking = false;
            group.attackTime = 0;

            group.userData = {
                name: 'Friendly NPC',
                health: 100,
                dialogue: 'Hello!',
                weight: 1
            };

            return group;
        }

        function animateHumanoid(humanoid, delta) {
            if (humanoid.isAttacking) {
                humanoid.attackTime += delta * humanoid.animationSpeed;
                const angle = Math.sin(humanoid.attackTime * 20) * (Math.PI / 4);

                humanoid.rightArm.rotation.x = -angle;

                if (humanoid.attackTime > 0.5) {
                    humanoid.rightArm.rotation.x = 0;
                    humanoid.isAttacking = false;
                    humanoid.attackTime = 0;
                }
            } else if (humanoid.isMoving) {
                humanoid.animationTime += delta * humanoid.animationSpeed;
                const angle = Math.sin(humanoid.animationTime) * (Math.PI / 6);

                humanoid.leftArm.rotation.x = angle;
                humanoid.rightArm.rotation.x = -angle;
                humanoid.leftLeg.rotation.x = -angle;
                humanoid.rightLeg.rotation.x = angle;
            } else {
                humanoid.leftArm.rotation.x = 0;
                humanoid.rightArm.rotation.x = 0;
                humanoid.leftLeg.rotation.x = 0;
                humanoid.rightLeg.rotation.x = 0;
            }
        }
		// Function to refresh inventory display when opened or modified
		function updateInventoryDisplay() {
			// Refresh each tab's grid based on playerInventory data
			for (let i = 1; i <= 6; i++) {
				const grid = document.getElementById('inventoryGridTab' + i);
				let playerInventory = [[], [], [], [], [], []]; // Initialize with 6 empty arrays for each tab
				const tabInventory = playerInventory[i - 1] || [];
				populateInventoryGrid(grid, tabInventory);
			}
		}


        function createTreasureChest(x, y, z) {
            const chestGeometry = new THREE.BoxGeometry(10, 10, 10);
            const chestMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const chest = new THREE.Mesh(chestGeometry, chestMaterial);
            chest.position.set(x, y + 5, z);

            chest.userData = {
                type: 'treasureChest',
                items: generateRandomItems(3),
                gold: Math.floor(Math.random() * 100) + 50
            };

            scene.add(chest);
            treasureChests.push(chest); // Keep track of treasure chests
            return chest;
        }

        function init() {
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            minimapCamera = new THREE.OrthographicCamera(-200, 200, 200, -200, 0.1, 10000);
            minimapCamera.position.set(0, 500, 0);
            minimapCamera.up.set(0, 0, -1);
            minimapCamera.lookAt(0, 0, 0);
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 100, 0);
            scene.add(directionalLight);

            const groundShape = new THREE.Shape();
            groundShape.moveTo(-5000, -5000);
            groundShape.lineTo(5000, -5000);
            groundShape.lineTo(5000, 5000);
            groundShape.lineTo(-5000, 5000);
            groundShape.lineTo(-5000, -5000);

            const safeZoneSize = 300;
            const holePath = new THREE.Path();
            holePath.moveTo(-safeZoneSize, -safeZoneSize);
            holePath.lineTo(-safeZoneSize, safeZoneSize);
            holePath.lineTo(safeZoneSize, safeZoneSize);
            holePath.lineTo(safeZoneSize, -safeZoneSize);
            holePath.lineTo(-safeZoneSize, -safeZoneSize);
            groundShape.holes.push(holePath);

			const safeZoneCenter = new THREE.Vector3(0, 0, 0); // Assuming the safezone is at the origin
			const safeZoneRadius = 300; // Adjust this value if needed


            const groundGeometry = new THREE.ShapeGeometry(groundShape);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.name = 'ground';
            scene.add(ground);

            const safeZoneGroundGeometry = new THREE.PlaneGeometry(600, 600);
            const safeZoneGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            safeZoneGround = new THREE.Mesh(safeZoneGroundGeometry, safeZoneGroundMaterial);
            safeZoneGround.rotation.x = -Math.PI / 2;
            safeZoneGround.position.y = 0.1;
            scene.add(safeZoneGround);

            const safeZoneBarrierGeometry = new THREE.BoxGeometry(600, 50, 600);
            const safeZoneBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            const safeZoneBarrier = new THREE.Mesh(safeZoneBarrierGeometry, safeZoneBarrierMaterial);
            safeZoneBarrier.position.set(0, 25, 0);
            scene.add(safeZoneBarrier);
            enemyWalls.push(safeZoneBarrier);

            createSettlementWalls();
            
            const shrineGroup = new THREE.Group();

            const floorGeometry = new THREE.CircleGeometry(20, 32);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.1;
            shrineGroup.add(floor);

            const teleportPadGeometry = new THREE.CircleGeometry(5, 32);
            const teleportPadMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            teleportPad = new THREE.Mesh(teleportPadGeometry, teleportPadMaterial);
            teleportPad.rotation.x = -Math.PI / 2;
            teleportPad.position.y = 0.11;
            teleportPad.name = 'teleportPad';
            shrineGroup.add(teleportPad);

            shrineGroup.position.set(0, 0, 0);
            scene.add(shrineGroup);

            for (let i = 0; i < 10; i++) {
                let position = getRandomPositionOutsideTown(300, 1000);
                let enemy = createEnemy(position.x, 0, position.z);
                enemies.push(enemy);
                scene.add(enemy);
            }

            const structurePositions = [
                { x: 150, z: 150 },
                { x: -150, z: 150 },
                { x: 150, z: -150 },
                { x: -150, z: -150 },
                { x: 0, z: 200 },
            ];

            structurePositions.forEach(pos => {
                const structure = createStructure();
                structure.position.set(pos.x, 0, pos.z);
                scene.add(structure);
                walls.push(...structure.userData.walls);

                const npc = createFriendlyNPC();
                npc.position.set(pos.x, 0, pos.z);
                scene.add(npc);
                friendlies.push(npc);
            });

            player = createHumanoid(0x0000ff);
            player.position.y = 0; 
            scene.add(player);

			

            // Function to add diverse plants to the terrain
            function addPlantsToTerrain() {
                const numElements = 300; // Total number of natural elements

                const elementTypes = [
                    {
                        geometry: new THREE.ConeGeometry(2, 10, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
                        yOffset: 5,
                    },
                    {
                        geometry: new THREE.CylinderGeometry(0.5, 0.5, 5, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                        yOffset: 2.5,
                    },
                    {
                        geometry: new THREE.SphereGeometry(3, 8, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                        yOffset: 3,
                    },
                    {
                        geometry: new THREE.DodecahedronGeometry(3, 0),
                        material: new THREE.MeshLambertMaterial({ color: 0x808080 }),
                        yOffset: 3,
                    },
                ];

                for (let i = 0; i < numElements; i++) {
                    const typeIndex = Math.floor(Math.random() * elementTypes.length);
                    const element = new THREE.Mesh(
                        elementTypes[typeIndex].geometry,
                        elementTypes[typeIndex].material
                    );

                    // Random position within the terrain bounds, avoiding the safe zone
                    let x = Math.random() * 10000 - 5000;
                    let z = Math.random() * 10000 - 5000;
                    while (Math.sqrt(x * x + z * z) < 400) { // Ensure elements are not in the safe zone
                        x = Math.random() * 10000 - 5000;
                        z = Math.random() * 10000 - 5000;
                    }

                    element.position.set(x, elementTypes[typeIndex].yOffset, z);
                    element.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                    scene.add(element);
                }
            }

            addPlantsToTerrain(); // Call the function to add plants and rocks

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
            canvas.addEventListener('mousedown', onDocumentMouseDown, false);
        }

        function createSettlementWalls() {
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const wallHeight = 30;
            const wallThickness = 2;
            const wallLength = 600;

            const northWallLeftGeometry = new THREE.BoxGeometry(wallLength / 2 - 50, wallHeight, wallThickness);
            const northWallLeft = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
            northWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, -300);
            scene.add(northWallLeft);
            walls.push(northWallLeft);

            const northWallRight = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
            northWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, -300);
            scene.add(northWallRight);
            walls.push(northWallRight);

            const gateBarrierGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
            const gateBarrierMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            const northGateBarrier = new THREE.Mesh(gateBarrierGeometry, gateBarrierMaterial);
            northGateBarrier.position.set(0, wallHeight / 2, -300);
            scene.add(northGateBarrier);
            enemyWalls.push(northGateBarrier);

            const southWallLeft = northWallLeft.clone();
            southWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, 300);
            scene.add(southWallLeft);
            walls.push(southWallLeft);

            const southWallRight = northWallRight.clone();
            southWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, 300);
            scene.add(southWallRight);
            walls.push(southWallRight);

            const southGateBarrier = northGateBarrier.clone();
            southGateBarrier.position.set(0, wallHeight / 2, 300);
            scene.add(southGateBarrier);
            enemyWalls.push(southGateBarrier);

            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(300, wallHeight / 2, 0);
            scene.add(eastWall);
            walls.push(eastWall);

            const westWall = eastWall.clone();
            westWall.position.set(-300, wallHeight / 2, 0);
            scene.add(westWall);
            walls.push(westWall);
        }

        function createStructure() {
            const building = new THREE.Group();

            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const wallThickness = 2;
            const wallHeight = 30;
            const wallLength = 50;

            const frontWallShape = new THREE.Shape();
            frontWallShape.moveTo(-wallLength / 2, 0);
            frontWallShape.lineTo(wallLength / 2, 0);
            frontWallShape.lineTo(wallLength / 2, wallHeight);
            frontWallShape.lineTo(-wallLength / 2, wallHeight);
            frontWallShape.lineTo(-wallLength / 2, 0);

            const doorWidth = 10;
            const doorHeight = 20;
            const doorX = -doorWidth / 2;
            const doorY = 0;

            const doorHole = new THREE.Path();
            doorHole.moveTo(doorX, doorY);
            doorHole.lineTo(doorX + doorWidth, doorY);
            doorHole.lineTo(doorX + doorWidth, doorY + doorHeight);
            doorHole.lineTo(doorX, doorY + doorHeight);
            doorHole.lineTo(doorX, doorY);
            frontWallShape.holes.push(doorHole);

            const frontWallGeometry = new THREE.ShapeGeometry(frontWallShape);
            const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            frontWall.position.z = -wallLength / 2;
            building.add(frontWall);

            const backWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.z = wallLength / 2;
            backWall.position.y = wallHeight / 2;
            building.add(backWall);

            const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.x = -wallLength / 2;
            leftWall.position.y = wallHeight / 2;
            building.add(leftWall);

            const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.x = wallLength / 2;
            rightWall.position.y = wallHeight / 2;
            building.add(rightWall);

            const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.y = Math.PI / 4;
            roof.position.y = wallHeight + 7.5;
            building.add(roof);

            building.userData.walls = [frontWall, backWall, leftWall, rightWall];

            return building;
        }

        function createFriendlyNPC() {
            const npc = createHumanoid(0x00ff00);
            npc.userData.type = 'friendly';
            npc.name = 'friendlyNPC';
            return npc;
        }

        function getRandomPositionOutsideTown(minDistance, maxDistance) {
            let angle = Math.random() * 2 * Math.PI;
            let distance = minDistance + Math.random() * (maxDistance - minDistance);
            let x = Math.cos(angle) * distance;
            let z = Math.sin(angle) * distance;
            return { x: x, z: z };
        }

        function createEnemy(x, y, z) {
            const enemy = createHumanoid(0xff0000);
            enemy.position.set(x, 0, z);
            enemy.userData.type = 'hostile';
            enemy.userData.isDead = false; 
            enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
            enemy.isMoving = true; 
            scene.add(enemy);
            return enemy;
        }

        function attackEnemy(enemy) {
            const attackRange = 20; 

            const distance = player.position.distanceTo(enemy.position);

            if (distance <= attackRange) {
                playAttackAnimation();

                setTimeout(() => {
                    defeatEnemy(enemy);
                }, 500); 
            } else {
                alert('Enemy is too far away!');
            }
        }

        function enemyAttackPlayer(enemy) {
            const damageAmount = Math.floor(Math.random() * 3) + 1; // Damage between 1 and 3
            damagePlayer(damageAmount);
        }

        function moveEnemies(delta) {
            enemies.forEach((enemy) => {
                if (enemy.userData.isDead) return; 

                const threatRange = 100; 
                const attackRange = 10;  
                const enemySpeed = globalEnemySpeed;

                const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                const distanceToPlayer = directionToPlayer.length();

                if (distanceToPlayer <= attackRange) {
                    enemy.isMoving = false;

                    enemyAttackPlayer(enemy);
                } else if (distanceToPlayer <= threatRange) {
                    directionToPlayer.normalize();
                    const oldPosition = enemy.position.clone();
                    enemy.position.add(directionToPlayer.multiplyScalar(enemySpeed));

                    let collided = false;
                    for (let wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(enemy);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        if (enemyBox.intersectsBox(wallBox)) {
                            collided = true;
                            break;
                        }
                    }

                    for (let wall of enemyWalls) {
                        const enemyBox = new THREE.Box3().setFromObject(enemy);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        if (enemyBox.intersectsBox(wallBox)) {
                            collided = true;
                            break;
                        }
                    }

                    if (collided) {
                        enemy.position.copy(oldPosition);
                        enemy.isMoving = false;
                    } else {
                        enemy.isMoving = true;
                    }
                } else {
                    const oldPosition = enemy.position.clone();
                    const moveVector = enemy.userData.direction.clone().multiplyScalar(0.5);
                    enemy.position.add(moveVector);

                    let collided = false;
                    for (let wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(enemy);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        if (enemyBox.intersectsBox(wallBox)) {
                            collided = true;
                            break;
                        }
                    }

                    if (collided) {
                        enemy.position.copy(oldPosition);
                        enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                        enemy.isMoving = false;
                    } else {
                        enemy.isMoving = true;
                    }
                }

                animateHumanoid(enemy, delta);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (destination) {
                movePlayerTowardsDestination();
            } else {
                player.isMoving = false;
            }

            animateHumanoid(player, delta);
            moveEnemies(delta);
            animateDeadEnemies(delta);
            updateTeleportation(delta);
            updateLooting(delta);

            const cameraRadius = 100; 
            const cameraHeight = 50;  

            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraAngle) * cameraRadius,
                cameraHeight,
                Math.cos(cameraAngle) * cameraRadius
            );

            camera.position.copy(player.position).add(cameraOffset);
            camera.lookAt(player.position);

            renderer.clear();
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false); 
            renderer.render(scene, camera);

            minimapCamera.position.x = player.position.x;
            minimapCamera.position.z = player.position.z;

            const minimapContainer = document.getElementById('minimapContainer');
            const mapWidth = minimapContainer.clientWidth;
            const mapHeight = minimapContainer.clientHeight;
            const minimapRect = minimapContainer.getBoundingClientRect();
            const canvasRect = renderer.domElement.getBoundingClientRect();
            const minimapX = minimapRect.left - canvasRect.left;
            const minimapY = minimapRect.top - canvasRect.top;

            renderer.setViewport(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
            renderer.setScissor(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
            renderer.setScissorTest(true); 
            renderer.render(scene, minimapCamera);
        }

        function animateDeadEnemies(delta) {
            scene.children.forEach((object) => {
                if (object.userData && object.userData.isDead) {
                    object.userData.deathTime += delta;
                    if (object.userData.deathTime < 1) {
                        object.rotation.x = -Math.PI / 2 * (object.userData.deathTime / 1);
                    } else {
                        object.rotation.x = -Math.PI / 2;

                        if (!object.userData.bloodPoolCreated) {
                            createBloodPool(object.position);
                            object.userData.bloodPoolCreated = true;
                        }
                    }
                }
            });
        }
		
		// Define biome types with unique ground textures and vegetation
		const biomes = {
			forest: {
				groundTexture: 'textures/forest_ground.jpg',
				vegetation: ['tree', 'bush', 'flower'],
				groundColor: 0x228B22,
			},
			desert: {
				groundTexture: 'textures/desert_sand.jpg',
				vegetation: ['cactus', 'dryBush'],
				groundColor: 0xC2B280,
			},
			snowfield: {
				groundTexture: 'textures/snow_ground.jpg',
				vegetation: ['snowyTree', 'smallRock'],
				groundColor: 0xFFFFFF,
			},
			grassland: {
				groundTexture: 'textures/grass_ground.jpg',
				vegetation: ['tallGrass', 'flower'],
				groundColor: 0x32CD32,
			}
		};

		const biomeSize = 1000; // Size of each biome chunk
		let activeBiomes = {}; // Store active biomes

		// Function to get the biome type based on player position
		function getBiomeType(x, z) {
			const biomeTypes = Object.keys(biomes);
			const seed = Math.abs(Math.floor(x / biomeSize) + Math.floor(z / biomeSize));
			return biomeTypes[seed % biomeTypes.length];
		}

		// Function to generate a biome at a specific position
		function generateBiome(x, z) {
			const biomeType = getBiomeType(x, z);
			const biomeData = biomes[biomeType];

			// Create ground for the biome
			const groundGeometry = new THREE.PlaneGeometry(biomeSize, biomeSize);
			const groundTexture = new THREE.TextureLoader().load(biomeData.groundTexture);
			const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture, color: biomeData.groundColor });
			const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
			groundMesh.position.set(x, 0, z);
			groundMesh.rotation.x = -Math.PI / 2;
			scene.add(groundMesh);

			// Add vegetation
			addVegetation(biomeData.vegetation, x, z);

			// Store active biomes
			activeBiomes[`${x},${z}`] = { type: biomeType, ground: groundMesh };
		}

		// Function to add vegetation to a biome
		function addVegetation(vegetationTypes, x, z) {
			vegetationTypes.forEach(type => {
				const count = Math.floor(Math.random() * 20) + 10; // Random number of vegetation elements

				for (let i = 0; i < count; i++) {
					let vegetationMesh;
					switch (type) {
						case 'tree':
							vegetationMesh = createTree();
							break;
						case 'bush':
							vegetationMesh = createBush();
							break;
						case 'flower':
							vegetationMesh = createFlower();
							break;
						case 'cactus':
							vegetationMesh = createCactus();
							break;
						case 'tallGrass':
							vegetationMesh = createTallGrass();
							break;
						case 'snowyTree':
							vegetationMesh = createSnowyTree();
							break;
						case 'smallRock':
							vegetationMesh = createSmallRock();
							break;
						default:
							continue;
					}

					const offsetX = (Math.random() - 0.5) * biomeSize;
					const offsetZ = (Math.random() - 0.5) * biomeSize;
					vegetationMesh.position.set(x + offsetX, 0, z + offsetZ);
					scene.add(vegetationMesh);
				}
			});
		}

		function createTree() {
			const trunkGeometry = new THREE.CylinderGeometry(1, 1, 15, 8);
			const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
			const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

			const foliageGeometry = new THREE.SphereGeometry(5, 16, 16);
			const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
			const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
			foliage.position.y = 10;

			const tree = new THREE.Group();
			tree.add(trunk);
			tree.add(foliage);
			return tree;
		}

		function createBush() {
			const geometry = new THREE.SphereGeometry(3, 8, 8);
			const material = new THREE.MeshLambertMaterial({ color: 0x006400 });
			return new THREE.Mesh(geometry, material);
		}

		function createFlower() {
			const geometry = new THREE.ConeGeometry(0.5, 2, 8);
			const material = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
			const flower = new THREE.Mesh(geometry, material);
			flower.rotation.x = Math.PI / 2;
			return flower;
		}

		function createCactus() {
			const geometry = new THREE.CylinderGeometry(1, 1, 8, 8);
			const material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
			return new THREE.Mesh(geometry, material);
		}

		function createTallGrass() {
			const geometry = new THREE.PlaneGeometry(0.1, 2);
			const material = new THREE.MeshLambertMaterial({ color: 0x32CD32, side: THREE.DoubleSide });
			const grass = new THREE.Mesh(geometry, material);
			grass.rotation.y = Math.random() * Math.PI;
			return grass;
		}

		function createSnowyTree() {
			const trunk = createTree();
			trunk.children[1].material.color.set(0xFFFFFF); // Change foliage to white
			return trunk;
		}

		function createSmallRock() {
			const geometry = new THREE.DodecahedronGeometry(1.5);
			const material = new THREE.MeshLambertMaterial({ color: 0x808080 });
			return new THREE.Mesh(geometry, material);
		}

		
        function createBloodPool(position) {
            const geometry = new THREE.CircleGeometry(5, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
            const bloodPool = new THREE.Mesh(geometry, material);
            bloodPool.rotation.x = -Math.PI / 2;
            bloodPool.position.set(position.x, 0.05, position.z);
            scene.add(bloodPool);
        }

        function movePlayerTowardsDestination() {
            const direction = new THREE.Vector3().subVectors(destination, player.position);
            const distance = direction.length();
            if (distance > 0.1) {
                direction.normalize();
                const moveDistance = Math.min(speed, distance);
                const oldPosition = player.position.clone();
                player.position.add(direction.multiplyScalar(moveDistance));

                let collided = false;
                for (let wall of walls) {
                    const playerBox = new THREE.Box3().setFromObject(player);
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (playerBox.intersectsBox(wallBox)) {
                        collided = true;
                        break;
                    }
                }

                if (collided) {
                    player.position.copy(oldPosition);
                    destination = null;
                    player.isMoving = false;
                } else {
                    player.isMoving = true;
                }
            } else {
                player.position.copy(destination);
                destination = null;
                player.isMoving = false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            minimapCamera.left = -200;
            minimapCamera.right = 200;
            minimapCamera.top = 200;
            minimapCamera.bottom = -200;
            minimapCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentKeyDown(event) {
            if (inventoryOpen || statsOpen || adminConsoleOpen) {
                if (inventoryOpen && (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b')) {
                    inventoryOpen = false;
                    document.getElementById('inventory').style.display = 'none';
                } else if (statsOpen && event.key.toLowerCase() === 'c') {
                    statsOpen = false;
                    document.getElementById('stats').style.display = 'none';
                } else if (adminConsoleOpen && event.key === '`') {
                    closeAdminConsole();
                }
                return;
            }

            if (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b') {
				inventoryOpen = !inventoryOpen;
				document.getElementById('inventory').style.display = inventoryOpen ? 'block' : 'none';
				if (inventoryOpen) {
					updateInventoryDisplay(); // Add this line to refresh the inventory display
				}
				return;
			}


            if (event.key.toLowerCase() === 'c') {
                statsOpen = !statsOpen;
                document.getElementById('stats').style.display = statsOpen ? 'block' : 'none';
                return;
            }

            if (event.key === '`') {
                if (!adminConsoleOpen) {
                    openAdminConsole();
                } else {
                    closeAdminConsole();
                }
                return;
            }

            if (isTeleporting || isLooting) return;

            if (event.key.toLowerCase() === 't') {
                if (!isTeleporting) {
                    startTeleportation();
                }
            }
            if (event.key.toLowerCase() === 'a') {
                cameraAngle -= 0.05;
            }
            if (event.key.toLowerCase() === 'd') {
                cameraAngle += 0.05;
            }
        }

        function onDocumentMouseDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const chestIntersects = raycaster.intersectObjects(treasureChests, true);
            if (chestIntersects.length > 0) {
                const chestObject = chestIntersects[0].object;
                openChestPopup(chestObject);
                return;
            }

            if (inventoryOpen || statsOpen || adminConsoleOpen || isTeleporting || isLooting) return;

            const objects = [ground, safeZoneGround, teleportPad, ...enemies, ...friendlies];
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const parent = intersectedObject.parent;

                if (intersectedObject === ground || intersectedObject === safeZoneGround) {
                    const point = intersects[0].point;
                    destination = new THREE.Vector3(point.x, player.position.y, point.z);
                } else if (intersectedObject === teleportPad) {
                    if (previousPosition) {
                        player.position.copy(previousPosition);
                        destination = null;
                        previousPosition = null;
                        alert('Teleported back to your previous location.');
                    } else {
                        alert('No previous location to teleport to.');
                    }
                } else if (parent.userData && parent.userData.type === 'hostile') {
                    if (parent.userData.isDead) {
                        lootEnemy(parent);
                    } else {
                        attackEnemy(parent);
                    }
                } else if (friendlies.includes(parent)) {
                    if (npcAdminEnabled) {
                        openNpcAdminPopup(parent);
                        return;
                    }
                    openNpcPopup(parent);
                }
            }
        }

        function lootEnemy(enemy) {
			isLooting = true;
			lootProgress = 0;
			currentLootingEnemy = enemy;
			document.getElementById('lootBarContainer').style.display = 'block';
		}

        function updateLooting(delta) {
            if (isLooting) {
                lootProgress += delta;
                const progressBar = document.getElementById('lootBar');
                progressBar.style.width = (lootProgress / lootDuration) * 100 + '%';
                if (lootProgress >= lootDuration) {
                    isLooting = false;
                    document.getElementById('lootBarContainer').style.display = 'none';
                    openLootPopup();
                }
            }
        }
		
		
		
        // Updating the function to open the loot popup with the expanded items
		function openLootPopup() {
			lootedItems = generateRandomItems(Math.floor(Math.random() * 4) + 1); // Randomize the number of items (1 to 4)

			const lootItemsDiv = document.getElementById('lootItems');
			lootItemsDiv.innerHTML = '';
			lootedItems.forEach(item => {
				const itemDiv = document.createElement('div');
				itemDiv.innerText = `${item.name} (${item.rarity})`;
				lootItemsDiv.appendChild(itemDiv);
			});

			document.getElementById('lootPopup').style.display = 'block';
		}
		


        function lootAllItems() {
            lootedItems.forEach(item => {
                addItemToInventory(item);
            });
            lootedItems = [];
            document.getElementById('lootPopup').style.display = 'none';
            alert('Items looted and added to your inventory.');
        }

        function generateRandomItems(count) {
            const items = [
                { name: 'Small Health Potion' },
                { name: 'Rusty Sword' },
                { name: 'Old Shield' },
                { name: 'Leather Boots' },
                { name: 'Cloth Armor' },
                { name: 'Mana Potion' },
                { name: 'Iron Helmet' },
            ];
            const randomItems = [];
            for (let i = 0; i < count; i++) {
                const randomIndex = Math.floor(Math.random() * items.length);
                randomItems.push(items[randomIndex]);
            }
            return randomItems;
        }

        function addItemsToInventory(items) {
            console.log('Items added to inventory:', items);
            playerInventory.push(...items);
        }



        function openAdminConsole() {
            adminConsoleOpen = true;
            document.getElementById('adminConsole').style.display = 'block';
            document.getElementById('adminLogin').style.display = 'block';
            document.getElementById('adminControls').style.display = 'none';
			// JavaScript to enable collapsible functionality
			document.querySelectorAll('.collapsible').forEach(button => {
				button.addEventListener('click', () => {
					button.classList.toggle('active');
					const content = button.nextElementSibling;
					if (content.style.maxHeight) {
						content.style.maxHeight = null;
					} else {
						content.style.maxHeight = content.scrollHeight + 'px';
					}
				});
			});

        }

		function applyWeatherEffect() {
			const selectedWeather = document.getElementById('weatherSelect').value;
			setWeatherEffect(selectedWeather);
			alert(`Weather changed to ${selectedWeather}.`);
		}


        function closeAdminConsole() {
            adminConsoleOpen = false;
            document.getElementById('adminConsole').style.display = 'none';
        }

        function checkAdminPassword() {
            const passwordInput = document.getElementById('adminPassword').value;
            if (passwordInput === 'ltwelcome1') {
                isAdminLoggedIn = true;
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminControls').style.display = 'block';
                document.getElementById('playerHealthInput').value = playerHealth;
                document.getElementById('playerGoldInput').value = gold;
                document.getElementById('playerExperienceInput').value = characterStats.experience;
                document.getElementById('enemySpeedInput').value = globalEnemySpeed;
                document.getElementById('invulnerabilityCheckbox').checked = playerInvulnerable;

                document.getElementById('npcAdminCheckbox').addEventListener('change', function() {
                    npcAdminEnabled = this.checked;
                    alert('NPC Admin Mode ' + (npcAdminEnabled ? 'Enabled' : 'Disabled'));
                });
            } else {
                alert('Incorrect password!');
            }
        }

		function updatePlayerPosition() {
			const playerX = Math.floor(player.position.x / biomeSize) * biomeSize;
			const playerZ = Math.floor(player.position.z / biomeSize) * biomeSize;

			if (!activeBiomes[`${playerX},${playerZ}`]) {
				generateBiome(playerX, playerZ);
			}

			// Check for inactive biomes and remove them if the player is too far away
			Object.keys(activeBiomes).forEach(key => {
				const [biomeX, biomeZ] = key.split(',').map(Number);
				const distance = Math.hypot(playerX - biomeX, playerZ - biomeZ);
				if (distance > 2 * biomeSize) {
					scene.remove(activeBiomes[key].ground);
					delete activeBiomes[key];
				}
			});
		}


        function updatePlayerOptions() {
            playerInvulnerable = document.getElementById('invulnerabilityCheckbox').checked;
            alert('Player options updated.');
        }

        function updatePlayerStats() {
            const healthInput = parseInt(document.getElementById('playerHealthInput').value);
            const goldInput = parseInt(document.getElementById('playerGoldInput').value);
            const experienceInput = parseInt(document.getElementById('playerExperienceInput').value);

            if (!isNaN(healthInput)) {
                playerHealth = Math.min(healthInput, playerMaxHealth);
                updateHealthDisplay();
            }
            if (!isNaN(goldInput)) {
                gold = goldInput;
                updateGoldDisplay();
            }
            if (!isNaN(experienceInput)) {
                characterStats.experience = experienceInput;
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    levelUp();
                }
                updateStatsDisplay();
            }
            alert('Player stats updated.');
        }

        function spawnEntities() {
            const entityType = document.getElementById('entityTypeSelect').value;
            const quantity = parseInt(document.getElementById('entityQuantityInput').value);

            if (isNaN(quantity) || quantity <= 0) {
                alert('Invalid quantity!');
                return;
            }

            for (let i = 0; i < quantity; i++) {
                const offsetX = Math.random() * 50 - 25;
                const offsetZ = Math.random() * 50 - 25;
                const spawnPosition = {
                    x: player.position.x + offsetX,
                    y: player.position.y,
                    z: player.position.z + offsetZ
                };

                if (entityType === 'enemy') {
                    const enemy = createEnemy(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                    enemies.push(enemy);
                    scene.add(enemy);
                } else if (entityType === 'friendlyNPC') {
                    const npc = createFriendlyNPC();
                    npc.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                    friendlies.push(npc);
                    scene.add(npc);
                } else if (entityType === 'structure') {
                    const structure = createStructure();
                    structure.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                    scene.add(structure);
                    walls.push(...structure.userData.walls);
                } else if (entityType === 'treasureChest') {
                    createTreasureChest(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                    alert('Treasure Chest spawned.');
                }
            }
        }

        function updateGameSettings() {
            const enemySpeedInput = parseFloat(document.getElementById('enemySpeedInput').value);

            if (!isNaN(enemySpeedInput) && enemySpeedInput > 0) {
                globalEnemySpeed = enemySpeedInput;
                alert('Game settings updated.');
            } else {
                alert('Invalid enemy speed!');
            }
        }

        function teleportPlayer() {
            const x = parseFloat(document.getElementById('teleportXInput').value);
            const z = parseFloat(document.getElementById('teleportZInput').value);

            if (!isNaN(x) && !isNaN(z)) {
                player.position.set(x, player.position.y, z);
                destination = null;
                alert(`Player teleported to (${x}, ${z}).`);
            } else {
                alert('Invalid coordinates!');
            }
        }

        function levelUp() {
            characterStats.level++;
            characterStats.experience -= characterStats.nextLevelExperience;
            characterStats.nextLevelExperience = Math.floor(characterStats.nextLevelExperience * 1.5);
            characterStats.statPoints += 5;
            alert('Level Up! You have reached level ' + characterStats.level);
        }

        function defeatEnemy(enemy) {
            addExperience(20);
            gold += 10;
            updateGoldDisplay();
            alert('Enemy defeated! You gained 20 experience and 10 gold.');

            enemy.isMoving = false;
            enemy.userData.isDead = true;
            enemy.userData.deathTime = 0;
        }

        function increaseStat(stat) {
            if (characterStats.statPoints > 0) {
                characterStats[stat]++;
                characterStats.statPoints--;
                updateStatsDisplay();
            } else {
                alert('No available stat points!');
            }
        }

        function updateStatsDisplay() {
            document.getElementById('level').innerText = characterStats.level;
            document.getElementById('experience').innerText = characterStats.experience;
            document.getElementById('nextLevelExperience').innerText = characterStats.nextLevelExperience;
            document.getElementById('strength').innerText = characterStats.strength;
            document.getElementById('dexterity').innerText = characterStats.dexterity;
            document.getElementById('vitality').innerText = characterStats.vitality;
            document.getElementById('energy').innerText = characterStats.energy;
            document.getElementById('statPoints').innerText = characterStats.statPoints;
        }

        // Function to initialize inventory slots and grids for each tab
		function generateInventorySlots() {
			for (let i = 1; i <= 6; i++) {
				const grid = document.getElementById('inventoryGridTab' + i);
				grid.innerHTML = ''; // Clear existing slots
				for (let j = 0; j < 56; j++) { // Assuming each tab has 56 slots
					const slot = document.createElement('div');
					slot.classList.add('inventory-slot');
					grid.appendChild(slot);
				}
			}
		}
		
		let currentWeather = null; // Track current weather effect

		function setWeatherEffect(effectName) {
			// Remove existing weather effect
			if (currentWeather) {
				if (currentWeather.name === 'rainEffect' || currentWeather.name === 'snowEffect') {
					scene.remove(currentWeather);
				} else if (scene.fog) {
					scene.fog = null;
				}
			}

			// Add new weather effect
			if (effectName === 'rain') {
				currentWeather = createRainEffect();
				scene.add(currentWeather);
			} else if (effectName === 'snow') {
				currentWeather = createSnowEffect();
				scene.add(currentWeather);
			} else if (effectName === 'fog') {
				createFogEffect();
				currentWeather = { name: 'fogEffect' }; // Just a placeholder object to track fog
			}
		}

		
		// Function to create fog effect
		function createFogEffect() {
			const fogColor = 0xaaaaaa;
			const fogDensity = 0.02;
			scene.fog = new THREE.FogExp2(fogColor, fogDensity);
		}

		
		// Function to create snow effect
		function createSnowEffect() {
			const snowCount = 1000;
			const snowGeometry = new THREE.BufferGeometry();
			const snowPositions = new Float32Array(snowCount * 3);

			for (let i = 0; i < snowCount; i++) {
				snowPositions[i * 3] = (Math.random() - 0.5) * 1000; // X position
				snowPositions[i * 3 + 1] = Math.random() * 500; // Y position
				snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000; // Z position
			}

			snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
			const snowMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, transparent: true });
			const snow = new THREE.Points(snowGeometry, snowMaterial);
			snow.name = 'snowEffect';
			return snow;
		}


		// Function to create rain effect
		function createRainEffect() {
			const rainCount = 1000;
			const rainGeometry = new THREE.BufferGeometry();
			const rainPositions = new Float32Array(rainCount * 3);

			for (let i = 0; i < rainCount; i++) {
				rainPositions[i * 3] = (Math.random() - 0.5) * 1000; // X position
				rainPositions[i * 3 + 1] = Math.random() * 500; // Y position
				rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000; // Z position
			}

			rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
			const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.5, transparent: true });
			const rain = new THREE.Points(rainGeometry, rainMaterial);
			rain.name = 'rainEffect';
			return rain;
		}


        // Function to add an item to the player's inventory
		function addItemToInventory(item) {
			// Find the first empty slot in any tab
			for (let i = 0; i < playerInventory.length; i++) {
				const tabInventory = playerInventory[i];
				const emptyIndex = tabInventory.findIndex(slot => slot == null);
				if (emptyIndex !== -1) {
					tabInventory[emptyIndex] = item;
					updateInventoryDisplay(); // Refresh inventory display
					return;
				}
			}
			alert('No space available in inventory!');
		}



        function setupInventoryTabs() {
            const tabs = document.querySelectorAll('.inventory-tab');
            const tabContents = document.querySelectorAll('.inventory-tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));

                    tab.classList.add('active');
                    const activeTabContent = document.getElementById(tab.dataset.tab);
                    activeTabContent.classList.add('active');
                });
            });

            tabs[0].classList.add('active');
            tabContents[0].classList.add('active');
        }

        setupInventoryTabs();

        function openChestPopup(chest) {
            currentOpenedChest = chest;
            const chestPopup = document.getElementById('chestPopup');
            chestPopup.style.display = 'block';

            const chestInventoryGrid = document.getElementById('chestInventoryGrid');
            const playerInventoryGrid = document.getElementById('playerInventoryInChestGrid');

            const chestColumns = 7;
            const chestRows = 4;
            const playerColumns = 7;
            const playerRows = 8;

            generateInventoryGrid(chestInventoryGrid, chestColumns, chestRows);
            generateInventoryGrid(playerInventoryGrid, playerColumns, playerRows);

            // Ensure items arrays have correct length
            if (!chest.userData.items) chest.userData.items = [];
            chest.userData.items.length = chestColumns * chestRows;
            playerInventory.length = playerColumns * playerRows;

            populateInventoryGrid(chestInventoryGrid, chest.userData.items);
            populateInventoryGrid(playerInventoryGrid, playerInventory);

            setupInventorySlotEventListeners(chestInventoryGrid, chest.userData.items, playerInventory, playerInventoryGrid);
            setupInventorySlotEventListeners(playerInventoryGrid, playerInventory, chest.userData.items, chestInventoryGrid);
        }

		// Enhanced rain effect with animation
		function createRainEffect() {
			const rainCount = 2000; // Increase count for more density
			const rainGeometry = new THREE.BufferGeometry();
			const rainPositions = new Float32Array(rainCount * 3);

			for (let i = 0; i < rainCount; i++) {
				rainPositions[i * 3] = (Math.random() - 0.5) * 1000; // X position
				rainPositions[i * 3 + 1] = Math.random() * 500; // Y position (height)
				rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000; // Z position
			}

			rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
			const rainMaterial = new THREE.PointsMaterial({
				color: 0xaaaaaa,
				size: 0.5,
				transparent: true,
				opacity: 0.6 // Slight transparency for visual effect
			});

			const rain = new THREE.Points(rainGeometry, rainMaterial);
			rain.name = 'rainEffect';

			// Add animation behavior
			rain.tick = () => {
				const positions = rain.geometry.attributes.position.array;
				for (let i = 0; i < rainCount; i++) {
					positions[i * 3 + 1] -= 3; // Simulate falling
					if (positions[i * 3 + 1] < 0) {
						positions[i * 3 + 1] = 500; // Reset raindrop to top
					}
				}
				rain.geometry.attributes.position.needsUpdate = true;
			};

			return rain;
		}
		
		// Enhanced fog effect
	function createFogEffect() {
		const fogColor = 0xaaaaaa;
		const initialDensity = 0.02;
		let increasing = true; // Fog density direction

		scene.fog = new THREE.FogExp2(fogColor, initialDensity);

		// Add animation behavior
		scene.fog.tick = () => {
			if (increasing) {
				scene.fog.density += 0.00005; // Increase density
				if (scene.fog.density > 0.05) increasing = false; // Start decreasing
			} else {
				scene.fog.density -= 0.00005; // Decrease density
				if (scene.fog.density < 0.02) increasing = true; // Start increasing
			}
		};
	}

		
		// Enhanced snow effect with animation
		function createSnowEffect() {
			const snowCount = 1500;
			const snowGeometry = new THREE.BufferGeometry();
			const snowPositions = new Float32Array(snowCount * 3);
			const snowSpeeds = new Float32Array(snowCount);

			for (let i = 0; i < snowCount; i++) {
				snowPositions[i * 3] = (Math.random() - 0.5) * 1000; // X position
				snowPositions[i * 3 + 1] = Math.random() * 500; // Y position
				snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000; // Z position
				snowSpeeds[i] = Math.random() * 0.5 + 0.2; // Speed of each snowflake
			}

			snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
			const snowMaterial = new THREE.PointsMaterial({
				color: 0xffffff,
				size: 1.5,
				transparent: true,
				opacity: 0.8
			});

			const snow = new THREE.Points(snowGeometry, snowMaterial);
			snow.name = 'snowEffect';

			// Add animation behavior
			snow.tick = () => {
				const positions = snow.geometry.attributes.position.array;
				for (let i = 0; i < snowCount; i++) {
					positions[i * 3 + 1] -= snowSpeeds[i]; // Move snow down
					positions[i * 3] += Math.sin(Date.now() * 0.001) * 0.05; // Add gentle drift

					if (positions[i * 3 + 1] < 0) {
						positions[i * 3 + 1] = 500; // Reset snowflake to top
					}
				}
				snow.geometry.attributes.position.needsUpdate = true;
			};

			return snow;
		}

		
        function generateInventoryGrid(gridElement, numColumns, numRows) {
            gridElement.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
            gridElement.innerHTML = '';
            for (let i = 0; i < numColumns * numRows; i++) {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                gridElement.appendChild(slot);
            }
        }

        function populateInventoryGrid(gridElement, items) {
            const slots = gridElement.querySelectorAll('.inventory-slot');
            slots.forEach((slot, index) => {
                slot.innerHTML = '';
                if (items[index]) {
                    slot.innerText = items[index].name;
                }
            });
        }

        function setupInventorySlotEventListeners(sourceGrid, sourceItems, targetItems, targetGrid) {
            const slots = sourceGrid.querySelectorAll('.inventory-slot');
            slots.forEach((slot, index) => {
                slot.addEventListener('click', () => {
                    if (sourceItems[index]) {
                        // Find first empty slot in targetItems
                        let emptyIndex = targetItems.findIndex(item => item == null);
                        if (emptyIndex === -1) {
                            alert('No space in target inventory.');
                            return;
                        }
                        // Transfer item
                        targetItems[emptyIndex] = sourceItems[index];
                        sourceItems[index] = null;

                        // Update grids
                        populateInventoryGrid(sourceGrid, sourceItems);
                        populateInventoryGrid(targetGrid, targetItems);
                    }
                });
            });
        }

        function closeChestPopup() {
            document.getElementById('chestPopup').style.display = 'none';
            currentOpenedChest = null;

            // Update the main inventory display if it's open
            if (inventoryOpen) {
                populateInventoryGrid(document.getElementById('inventoryGridTab1'), playerInventory);
            }
        }

        function takeAllChestItems() {
            const chest = currentOpenedChest;
            chest.userData.items.forEach(item => {
                addItemToInventory(item);
            });
            chest.userData.items = [];
            gold += chest.userData.gold;
            updateGoldDisplay();
            chest.userData.gold = 0;

            scene.remove(chest);

            closeChestPopup();
        }

        generateInventorySlots();
        updateGoldDisplay();
        updateHealthDisplay();
        updateEnergyDisplay();
        updateStatsDisplay();
        init();
        animate();
    </script>
</body>
</html>