<html>
    <head>
        <title>Remnants of Destruction v0.2.7</title>
        <link rel="stylesheet" type="text/css" href="rodstyles.css">
        <!-- Include Three.js -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
        <!-- Include GLTFLoader -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        <div id="fullscreenMap" style="display: none;">
            <canvas id="mapCanvas"></canvas>
            <button onclick="closeFullscreenMap()" style="position: absolute; top: 10px; right: 10px; z-index: 201;">Close Map</button>
        </div>
        
        <!-- Skill Tree Popup -->
        <div id="skillTree" style="display: none;">
            <h2>Skill Tree</h2>
            <div id="skillsContainer">
                <!-- Skills will be dynamically added here -->
            </div>
            <button onclick="closeSkillTree()">Close Skill Tree</button>
        </div>

        <!-- Button to Open Bestiary -->
        <button id="openBestiary" class="open-bestiary-button">View Bestiary</button>

        <!-- Bestiary Modal -->
        <div id="bestiaryModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="bestiaryTitle">
            <div class="modal-content">
                <button id="closeBestiary" class="close-button" aria-label="Close Bestiary">&times;</button>
                <h2 id="bestiaryTitle">Bestiary</h2>
                <div id="bestiaryContent" class="bestiary-content">
                    <!-- Dynamic Bestiary Content Will Be Injected Here by bestiary.js -->
                </div>
            </div>
        </div>

        <!-- Race Details Modal -->
        <div id="creatureDetailsModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="creatureDetailsTitle">
            <div class="modal-content">
                <button class="close-details close-button" aria-label="Close Race Details">&times;</button>
                <div id="creatureDetailsContent" class="creature-details-content">
                    <!-- Dynamic Race Details Will Be Injected Here by bestiary.js -->
                </div>
            </div>
        </div>

        <div id="inventory">
            <h2>Inventory</h2>
            <p>Gold: <span id="goldAmount">0</span></p>
            <div id="inventoryTabs">
                <button class="inventory-tab" data-tab="tab1">Tab 1</button>
                <button class="inventory-tab" data-tab="tab2">Tab 2</button>
                <button class="inventory-tab" data-tab="tab3">Tab 3</button>
                <button class="inventory-tab" data-tab="tab4">Tab 4</button>
                <button class="inventory-tab" data-tab="tab5">Tab 5</button>
                <button class="inventory-tab" data-tab="tab6">Tab 6</button>
            </div>
            <div id="inventoryTabsContent">
                <div class="inventory-tab-content" id="tab1">
                    <div class="inventoryGrid" id="inventoryGridTab1"></div>
                </div>
                <div class="inventory-tab-content" id="tab2">
                    <div class="inventoryGrid" id="inventoryGridTab2"></div>
                </div>
                <div class="inventory-tab-content" id="tab3">
                    <div class="inventoryGrid" id="inventoryGridTab3"></div>
                </div>
                <div class="inventory-tab-content" id="tab4">
                    <div class="inventoryGrid" id="inventoryGridTab4"></div>
                </div>
                <div class="inventory-tab-content" id="tab5">
                    <div class="inventoryGrid" id="inventoryGridTab5"></div>
                </div>
                <div class="inventory-tab-content" id="tab6">
                    <div class="inventoryGrid" id="inventoryGridTab6"></div>
                </div>
            </div>
        </div>

        <div id="stats">
            <h2>Character Stats</h2>
            <p>Level: <span id="level">1</span></p>
            <p>Experience: <span id="experience">0</span> / <span id="nextLevelExperience">100</span></p>
            <p>Strength: <span id="strength">10</span></p>
            <p>Dexterity: <span id="dexterity">10</span></p>
            <p>Vitality: <span id="vitality">10</span></p>
            <p>Energy: <span id="energy">10</span></p>
            <p>Mana: <span id="mana">50</span></p>
            <p>Karma: <span id="karma">0</span></p> 
            <p>Reputation: <span id="reputation">0</span></p> 
            <p>Available Stat Points: <span id="statPoints">0</span></p>
            <button onclick="increaseStat('strength')">Increase Strength</button>
            <button onclick="increaseStat('dexterity')">Increase Dexterity</button>
            <button onclick="increaseStat('vitality')">Increase Vitality</button>
            <button onclick="increaseStat('energy')">Increase Energy</button>
            <button onclick="increaseStat('mana')">Increase Mana</button> <!-- New Button -->
            <button onclick="increaseStat('karma')">Increase Karma</button> <!-- New Button -->
            <button onclick="increaseStat('reputation')">Increase Reputation</button> <!-- New Button -->
        </div>

        <div id="hotbar">
            <div class="slot" data-slot="1"></div>
            <div class="slot" data-slot="2"></div>
            <div class="slot" data-slot="3"></div>
            <div class="slot" data-slot="4"></div>
            <div class="slot" data-slot="5"></div>
            <div class="slot" data-slot="6"></div>
            <div class="slot" data-slot="7"></div>
            <div class="slot" data-slot="8"></div>
            <div class="slot" data-slot="9"></div>
            <div class="slot" data-slot="0"></div> <!-- '0' represents the 10th slot -->
        </div>

        <div id="minimapContainer"></div>
        <div id="npcPopup" style="display: none;">
            <h2>Friendly NPC</h2>
            <p>Hello, traveler! Stay awhile and listen...</p>
            <button onclick="closeNpcPopup()">Close</button>
        </div>

        <div id="lifeOrb">
            <div id="lifeFill"></div>
            <div id="lifeValue">100/100</div>
        </div>

        <div id="energyOrb">
            <div id="energyValue">1/1</div>
        </div>

        <div id="teleportationBarContainer">
            <div id="teleportationBar"></div>
        </div>
        <!-- Add Loading Indicator HTML -->
        <div id="adminLoading" class="loading-overlay" style="display: none;">
            <div class="loading-spinner"></div>
        </div>

        <!-- Admin Console Modal -->
        <div id="adminConsole" class="modal" aria-hidden="true" role="dialog" aria-labelledby="adminConsoleTitle">
            <div class="modal-content">
                <button class="close-button" onclick="closeAdminConsole()" aria-label="Close Admin Console">&times;</button>
                <h2 id="adminConsoleTitle">Admin Console</h2>
                
                <!-- Tab Navigation -->
                <div class="admin-tabs">
                    <button class="tab-button active" data-tab="adminLogin">Login</button>
                    <button class="tab-button" data-tab="playerManagement">Player Management</button>
                    <button class="tab-button" data-tab="gameSettings">Game Settings</button>
                    <button class="tab-button" data-tab="spawnOptions">Spawn Options</button>
                    <button class="tab-button" data-tab="teleportPlayer">Teleport Player</button>
                    <button class="tab-button" data-tab="npcAdmin">NPC Admin</button>
                </div>
                
                <!-- Tab Content -->
                <div class="admin-tab-content active" id="adminLogin">
                    <h3>Admin Login</h3>
                    <p>Please enter the admin password:</p>
                    <input type="password" id="adminPassword" placeholder="Enter Password">
                    <button onclick="checkAdminPassword()">Submit</button>
                </div>
                
                <div class="admin-tab-content" id="playerManagement">
                    <h3>Player Management</h3>
                    <section>
                        <h4>Player Stats</h4>
                        <p>Health: <input type="number" id="playerHealthInput" value="100" step="1" min="0"></p>
                        <p>Gold: <input type="number" id="playerGoldInput" value="0" step="1" min="0"></p>
                        <p>Experience: <input type="number" id="playerExperienceInput" value="0" step="1" min="0"></p>
                        <button onclick="updatePlayerStats()">Update Player Stats</button>
                    </section>
                    <section>
                        <h4>Player Options</h4>
                        <p>
                            <label class="checkbox-label">
                                <input type="checkbox" id="invulnerabilityCheckbox"> Invulnerable
                            </label>
                        </p>
                        <button onclick="updatePlayerOptions()">Update Player Options</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="gameSettings">
                    <h3>Game Settings</h3>
                    <section>
                        <h4>Enemy Speed</h4>
                        <p>Enemy Speed: <input type="number" id="enemySpeedInput" value="0.7" step="0.1" min="0"></p>
                        <button onclick="updateGameSettings()">Update Game Settings</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="spawnOptions">
                    <h3>Spawn Options</h3>
                    <section>
                        <h4>Spawn Entities</h4>
                        <p>Entity Type:
                            <select id="entityTypeSelect">
                                <option value="enemy">Enemy</option>
                                <option value="friendlyNPC">Friendly NPC</option>
                                <option value="structure">Structure</option>
                                <option value="treasureChest">Treasure Chest</option>
                                <option value="settlement">Settlement</option>
                                <option value="quadruped">Quadruped</option>
                            </select>
                        </p>
                        <p>Quantity: <input type="number" id="entityQuantityInput" value="1" step="1" min="1"></p>
                        <button onclick="spawnEntities()">Spawn Entities</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="teleportPlayer">
                    <h3>Teleport Player</h3>
                    <section>
                        <h4>Set Player Coordinates</h4>
                        <p>X: <input type="number" id="teleportXInput" value="0" step="1"></p>
                        <p>Z: <input type="number" id="teleportZInput" value="0" step="1"></p>
                        <button onclick="teleportPlayer()">Teleport Player</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="npcAdmin">
                    <h3>NPC Admin</h3>
                    <section>
                        <h4>Manage NPC Admin Mode</h4>
                        <p>
                            <label class="checkbox-label">
                                <input type="checkbox" id="npcAdminCheckbox"> Enable NPC Admin Mode
                            </label>
                        </p>
                    </section>
                </div>
                
            </div>
        </div>




        <div id="lootBarContainer">
            <div id="lootBar"></div>
        </div>
        <!-- Trait Selection Modal -->
        <div id="traitSelectionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="traitSelectionTitle">
            <div class="modal-content">
                <button class="close-trait-selection close-button" aria-label="Close Trait Selection">&times;</button>
                <h2 id="traitSelectionTitle">Select Your Traits</h2>
                <div id="traitOptions">
                    <!-- Trait options will be dynamically added here -->
                </div>
                <button onclick="confirmTraitSelection()">Confirm Traits</button>
            </div>
        </div>

        <div id="lootPopup">
            <h2>Loot</h2>
            <div id="lootItems"></div>
            <button onclick="lootAllItems()">Loot All</button>
        </div>

        <div id="npcAdminPopup" style="display: none;">
            <h2>NPC Admin</h2>
            <p>Name: <input type="text" id="npcNameInput"></p>
            <p>Health: <input type="number" id="npcHealthInput" step="1"></p>
            <p>Dialogue:</p>
		
		    <!-- Add color inputs for body parts -->
		    <p>Head Color: <input type="color" id="npcHeadColorInput"></p>
		    <p>Body Color: <input type="color" id="npcBodyColorInput"></p>
		    <p>Arm Color: <input type="color" id="npcArmColorInput"></p>
		    <p>Leg Color: <input type="color" id="npcLegColorInput"></p>

            <textarea id="npcDialogueInput" rows="4" cols="50"></textarea>
            <br>
            <button onclick="saveNpcChanges()">Save Changes</button>
            <button onclick="closeNpcAdminPopup()">Close</button>
        </div>

        <div id="chestPopup" style="display: none;">
            <h2>Chest Interaction</h2>
            <div id="chestInventoryContainer">
                <div>
                    <h3>Chest Inventory</h3>
                    <div id="chestInventoryGrid" class="inventoryGrid"></div>
                </div>
                <div>
                    <h3>Your Inventory</h3>
                    <div id="playerInventoryInChestGrid" class="inventoryGrid"></div>
                </div>
            </div>
            <button onclick="closeChestPopup()">Close</button>
        </div>

        <!-- Quest Log Popup -->
        <div id="questLog" style="display: none;">
            <h2>Quest Log</h2>
            <ul id="questList">
                <!-- Quests will be dynamically added here -->
            </ul>
            <button onclick="closeQuestLog()">Close Quest Log</button>
        </div>

        <!-- Help Window -->
        <div id="helpWindow">
            <button id="closeHelp">X</button>
            <div class="content">
                <div class="left-column">
                    <h2>Latest Updates</h2>
                    <p><strong>Version 0.2.7</strong></p>
                    <ul class="updates">
                        <li>Fixed Bestiary</li>
                        <li>Improved Admin Screen</li>
                        <li>Fixed on-hover elements to show correct data</li>
                        <li>Increased "safezone" size</li>
                        <li>Smoothened camera rotation</li>
                        <li>Fixed Closing Help Window with the X button</li>
                    </ul>
                    <h3><strong>Admin Info:</strong></h3>
                    <p><strong>Admin Password:</strong> ltwelcome1</p>
                </div>
                <div class="right-column">
                    <h3>Key Bindings:</h3>
                    <ul class="keybindings">
                        <li><strong>I</strong> or <strong>B</strong>: Open/Close Inventory</li>
                        <li><strong>C</strong>: Open/Close Character Stats</li>
                        <li><strong>Q</strong>: Open/Close Quest Log</li>
                        <li><strong>T</strong>: Start Teleportation</li>
                        <li><strong>A</strong>: Rotate Camera Left</li>
                        <li><strong>D</strong>: Rotate Camera Right</li>
                        <li><strong>`</strong>: Open/Close Admin Console</li>
                        <li><strong>H</strong>: Open/Close Help Window</li>
                        <li><strong>Y</strong>: Open/Close Bestiary</li>
                    </ul>
        
                    <h3>Planned Fixes:</h3>
                    <ul class="features">
                        <li>Enemies allowed in safe zone</li>
                        <li>More structures</li>
                        <li>More NPCs</li>
                        <li>Fix Black Ground</li>
                        <li>Item ToolTips</li>
                        
                    </ul>
                </div>
            </div>
        </div>
        
        
        
        </div>

	    <div id="structureAdminPopup" style="display: none;">
		    <h2>Structure Admin</h2>
		    <p>Scale: <input type="number" id="structureScaleInput" value="1" step="0.1"></p>
		    <p>Color: <input type="color" id="structureColorInput"></p>
		    <button onclick="saveStructureChanges()">Save Changes</button>
		    <button onclick="closeStructureAdminPopup()">Close</button>
	    </div>

    
        <script>
            let inventoryLoaded = false;
            const clock = new THREE.Clock(); // Create a new Three.js clock
            let mapScene, mapCamera, mapRenderer; // Create a new Three.js scene, camera, and renderer for the fullscreen map.
            let scene, camera, renderer; // Create a new Three.js scene, camera, and renderer
            let player, ground, safeZoneGround; // Player, ground, and safe zone
            let inventoryOpen = false; // Inventory state
            let statsOpen = false; // Character stats state
            let destination = null; // Destination for teleportation
            let speed = 1.0; // Player movement speed
            let minimapCamera; // Minimap camera
            let enemies = []; // List of enemies
            let gold = 0; // Gold amount
            let bestiary = {}; // Bestiary data
            const townRadius = 200; // Radius of the town
            let quadrupeds = []; // List of quadrupeds
            let walls = []; // List of walls
            let friendlies = []; // List of friendlies
            let helpWindowOpen = false; // Add this variable for help window
            let isTeleporting = false; // Add this variable for teleportation
            let adminConsoleOpen = false; // Add this variable for admin console
            let teleportProgress = 0; // Add this variable for teleportation
            let teleportationDuration = 3; // Duration in seconds
            let previousPosition = null; // Add this variable for teleportation
            let structures = []; // Add this variable for structures
            let cameraAngle = 0;    // Add this variable for camera angle
            let enemyWalls = []; // Walls that affect only enemies
            let npcPopupOpen = false; // Track NPC popup state
            let npcAdminEnabled = false; // Track NPC admin state
            let currentNpc = null; // Track current NPC
            let currentOpenedChest = null; // Added to address the popup issue
            let treasureChests = []; // Added to keep track of treasure chests
            let isAdminLoggedIn = false; // Add this variable for admin login
            let quests = [];
            let questLogOpen = false; // Add this variable for quest log
            let isMouseDown = false; // Add this variable for mouse down
            let mouseDestination = null; // Add this variable for mouse down
            let cameraTargetAngle = 0; // Add this variable for camera target angle
            let currentCameraAngle = 0; // Add this variable for current camera angle
            const cameraRotationSpeed = 0.05; // Adjust for smoother or faster rotation
            let rotateLeft = false; // Add this variable for rotation
            let currentStructure = null; // Implement Structure Admin Functions
            let rotateRight = false; // Add this variable for rotation
            let globalEnemySpeed = 0.7; // Global variable for enemy speed
            let activeDamageIntervals = new Map(); // Keep track of active damage intervals
            const collidableTerrainObjects = [];       
            let playerInventory = []; // Player inventory

            const npcData = [
                { 
                    name: 'John Reilly', 
                    dialogue: 'Greetings, adventurer. May your journey be safe.', 
                    occupation: 'Town Guard', 
                    health: 100, 
                    location: { x: 200, y: 0, z: -150 },
                    faction: 'Town' 
                },
                { 
                    name: 'Martha Reilly', 
                    dialogue: 'Looking to trade? I have wares you might like.', 
                    occupation: 'Merchant', 
                    health: 100, 
                    location: { x: 300, y: 0, z: -100 },
                    faction: 'Town' 
                },
                { 
                    name: 'Noah', 
                    dialogue: 'Need your weapons sharpened?', 
                    occupation: 'Blacksmith', 
                    health: 120, 
                    location: { x: 100, y: 0, z: -50 },
                    faction: 'Town' 
                },
                { 
                    name: 'Jace', 
                    dialogue: 'These crops won\'t tend themselves.', 
                    occupation: 'Farmer', 
                    health: 80, 
                    location: { x: 400, y: 0, z: 0 },
                    faction: 'Village' 
                },
                { 
                    name: 'Kaanan', 
                    dialogue: 'Stay vigilant out there.', 
                    occupation: 'Ranger', 
                    health: 150, 
                    location: { x: -50, y: 0, z: 50 },
                    faction: 'Outskirts' 
                },
                // Add more NPCs as desired
            ];


            // Player health and energy
            let playerHealth = 100;
            const playerMaxHealth = 100;
            let playerEnergy = 1;
            const playerMaxEnergy = 1;

            // Invulnerability variable
            let playerInvulnerable = false;

            // Looting variables
            let isLooting = false;
            let lootProgress = 0;
            const lootDuration = 2; // Duration in seconds
            let lootedItems = [];
            let currentLootingEnemy = null;

            // Initialize Character Stats with Expanded Attributes
            let characterStats = {
                level: 1,
                experience: 0,
                nextLevelExperience: 100,
                strength: 10,
                dexterity: 10,
                vitality: 10,
                energy: 10,
                mana: 50,          // New Attribute
                karma: 0,          // New Attribute
                reputation: 0,     // New Attribute
                statPoints: 0
            };

		
            // Define skill tree data with new attributes
            let skillTreeData = {
                strength: {
                    name: 'Strength Boost',
                    description: 'Increase your strength by 5.',
                    cost: 1,
                    learned: false,
                    effects: { strength: 5 }
                },
                dexterity: {
                    name: 'Dexterity Boost',
                    description: 'Increase your dexterity by 5.',
                    cost: 1,
                    learned: false,
                    effects: { dexterity: 5 }
                },
                vitality: {
                    name: 'Vitality Boost',
                    description: 'Increase your vitality by 5.',
                    cost: 1,
                    learned: false,
                    effects: { vitality: 5 }
                },
                energy: {
                    name: 'Energy Boost',
                    description: 'Increase your energy by 5.',
                    cost: 1,
                    learned: false,
                    effects: { energy: 5 }
                },
                mana: {
                    name: 'Mana Pool',
                    description: 'Increase your mana by 20.',
                    cost: 2,
                    learned: false,
                    effects: { mana: 20 }
                },
                karmaInfluence: {
                    name: 'Karma Influence',
                    description: 'Increase your karma by 5.',
                    cost: 2,
                    learned: false,
                    effects: { karma: 5 }
                },
                reputationBoost: {
                    name: 'Reputation Boost',
                    description: 'Increase your reputation by 10.',
                    cost: 2,
                    learned: false,
                    effects: { reputation: 10 }
                }
                // Add more skills as needed
            };
            function initializeInventory() {
                const tabs = document.querySelectorAll('.inventory-tab');
                const tabContents = document.querySelectorAll('.inventory-tab-content');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.getAttribute('data-tab');
                        tabContents.forEach(content => {
                            content.style.display = content.id === tabId ? 'block' : 'none';
                        });
                    });
                });

                // Show the first tab by default
                if (tabContents.length > 0) {
                    tabContents[0].style.display = 'block';
                }
            }

            function init() {
                // Disable right-click context menu
                document.addEventListener('contextmenu', function(event) {
                    event.preventDefault();
                }, false);
                initializeInventory();
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({ canvas });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.autoClear = false;
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
                minimapCamera = new THREE.OrthographicCamera(-200, 200, 200, -200, 0.1, 10000);
                minimapCamera.position.set(0, 500, 0);
                minimapCamera.up.set(0, 0, -1);
                minimapCamera.lookAt(0, 0, 0);
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 100, 0);
                scene.add(directionalLight);
                addQuadrupeds();

                    

                // Help Window Open on Start
                helpWindowOpen = true;
                document.getElementById('helpWindow').style.display = 'block';

                
                

                const groundShape = new THREE.Shape();
                groundShape.moveTo(-5000, -5000);
                groundShape.lineTo(5000, -5000);
                groundShape.lineTo(5000, 5000);
                groundShape.lineTo(-5000, 5000);
                groundShape.lineTo(-5000, -5000);

                const safeZoneSize = 600;
                const holePath = new THREE.Path();
                holePath.moveTo(-safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, -safeZoneSize);
                groundShape.holes.push(holePath);

                const groundGeometry = new THREE.ShapeGeometry(groundShape);
                console.log(groundGeometry.attributes.uv); // Inspect UVs in the console

                // Load the texture and apply it to the ground material
                const textureLoader = new THREE.TextureLoader();
                const groundTexture = textureLoader.load(
                    'ground.png',
                    () => {
                        console.log('Ground texture loaded successfully.');
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading ground texture:', error);
                    }
                );
                
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(25, 25); // Adjust the repeat to scale the texture as desired


                const groundMaterial = new THREE.MeshLambertMaterial({
                    map: groundTexture,
                });

                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.name = 'ground';
                scene.add(ground);

                const safeZoneGroundGeometry = new THREE.PlaneGeometry(1200, 1200);
                const safeZoneGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                safeZoneGround = new THREE.Mesh(safeZoneGroundGeometry, safeZoneGroundMaterial);
                safeZoneGround.rotation.x = -Math.PI / 2;
                safeZoneGround.position.y = 0.1;
                scene.add(safeZoneGround);

                const safeZoneBarrierGeometry = new THREE.BoxGeometry(1200, 50, 1200);
                const safeZoneBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const safeZoneBarrier = new THREE.Mesh(safeZoneBarrierGeometry, safeZoneBarrierMaterial);
                safeZoneBarrier.position.set(0, 25, 0);
                scene.add(safeZoneBarrier);
                enemyWalls.push(safeZoneBarrier);

                const initialSettlementWalls = createSettlementWalls();
                scene.add(initialSettlementWalls);
                        
                const shrineGroup = new THREE.Group();

                const floorGeometry = new THREE.CircleGeometry(20, 32);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1;
                shrineGroup.add(floor);

                const teleportPadGeometry = new THREE.CircleGeometry(5, 32);
                const teleportPadMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                teleportPad = new THREE.Mesh(teleportPadGeometry, teleportPadMaterial);
                teleportPad.rotation.x = -Math.PI / 2;
                teleportPad.position.y = 0.15;
                teleportPad.name = 'teleportPad';
                shrineGroup.add(teleportPad);

                shrineGroup.position.set(0, 0, 0);
                scene.add(shrineGroup);

                // Spawn Red Enemies (Regular)
                for (let i = 0; i < 10; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let enemy = createEnemy(position.x, 0, position.z, 'red');
                    enemies.push(enemy);
                    scene.add(enemy);
                }

                // Spawn Blue Enemies
                for (let i = 0; i < 3; i++) { // Adjust the number as desired
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let blueEnemy = createEnemy(position.x, 0, position.z, 'blue');
                    enemies.push(blueEnemy);
                    scene.add(blueEnemy);
                }

                const structurePositions = [
                    // Row 1 (z = 200)
                    { x: -200, z: 200 },
                    { x: 0, z: 200 },
                    { x: 200, z: 200 },
                    // Row 2 (z = -200)
                    { x: -200, z: -200 },
                    { x: 0, z: -200 },
                    { x: 200, z: -200 },
                ];
                

                structurePositions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, 0, pos.z);
                    scene.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    // Select a random NPC from npcData
                    const npcInfo = npcData[Math.floor(Math.random() * npcData.length)];

                    // Create the NPC with the selected data
                    const npc = createFriendlyNPC(0x00ff00, npcInfo.name, npcInfo.dialogue);

                    // Position the NPC at the structure's position
                    npc.position.copy(structure.position);

                    // Add the NPC to the scene and friendlies array
                    scene.add(npc);
                    friendlies.push(npc);
                });

                player = createHumanoid(0x0000ff);
                player.position.y = 0; 
                scene.add(player);

                function checkEnemiesInSafeZone() {
                    const safeZoneRadius = 600; // Radius of the safe zone

                    enemies.forEach((enemy) => {
                        if (enemy.userData.isDead) return;

                        const distanceFromCenter = Math.sqrt(
                            enemy.position.x * enemy.position.x + enemy.position.z * enemy.position.z
                        );

                        if (distanceFromCenter < safeZoneRadius) {
                            const angle = Math.random() * Math.PI * 2;
                            const teleportDistance = 1000;
                            enemy.position.x = Math.cos(angle) * teleportDistance;
                            enemy.position.z = Math.sin(angle) * teleportDistance;
                            enemy.position.y = 0; 
                        }
                    });
                }

                

                // Function to add diverse plants to the terrain
                function addPlantsToTerrain() {
                    const numElements = 3000; // Total number of natural elements

                    const elementTypes = [
                        {
                            // Tree
                            geometry: new THREE.ConeGeometry(20, 200, 20),
                            material: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
                            yOffset: 5,
                        },
                        {
                            geometry: new THREE.CylinderGeometry(0.5, 0.5, 5, 8),
                            material: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                            yOffset: 2.5,
                        },
                        {
                            geometry: new THREE.SphereGeometry(3, 8, 8),
                            material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                            yOffset: 3,
                        },
                        {
                            //Large Bush
                            geometry: new THREE.SphereGeometry(4, 12, 13),
                            material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                            yOffset: 3,
                        },
                        {
                            //Rock
                            geometry: new THREE.DodecahedronGeometry(3, 2),
                            material: new THREE.MeshLambertMaterial({ color: 0x808080 }),
                            yOffset: 3,
                        },
                    ];

                    for (let i = 0; i < numElements; i++) {
                        const typeIndex = Math.floor(Math.random() * elementTypes.length);
                        const element = new THREE.Mesh(
                            elementTypes[typeIndex].geometry,
                            elementTypes[typeIndex].material
                        );

                        // Random position within the terrain bounds, avoiding the safe zone
                        let x = Math.random() * 10000 - 5000;
                        let z = Math.random() * 10000 - 5000;
                        while (Math.sqrt(x * x + z * z) < 800) { // Ensure elements are not in the safe zone
                            x = Math.random() * 10000 - 5000;
                            z = Math.random() * 10000 - 5000;
                        }

                        element.position.set(x, elementTypes[typeIndex].yOffset, z);
                        element.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                        scene.add(element);
                    }
                }

                addPlantsToTerrain(); // Call the function to add plants and rocks

                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('keydown', onDocumentKeyDown, false);
                canvas.addEventListener('mousedown', onDocumentMouseDown, false);
                canvas.addEventListener('mouseup', onDocumentMouseUp, false);

            }
                
            function initMap() {
                const mapCanvas = document.getElementById('mapCanvas');
                mapRenderer = new THREE.WebGLRenderer({ canvas: mapCanvas, alpha: true });
                mapRenderer.setSize(window.innerWidth, window.innerHeight);
                mapScene = new THREE.Scene();

                // Orthographic camera for 2D map
                const aspect = window.innerWidth / window.innerHeight;
                const d = 5000; // Adjust based on your game world's size
                mapCamera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 10000);
                mapCamera.position.set(0, 1000, 0); // High above the game world
                mapCamera.up.set(0, 0, -1); // Adjust to match the game world's orientation
                mapCamera.lookAt(new THREE.Vector3(0, 0, 0));

                // Add similar lighting to the main scene
                const ambientLight = new THREE.AmbientLight(0x404040);
                mapScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 100, 0);
                mapScene.add(directionalLight);
            }
            

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();

                if (isMouseDown && mouseDestination) {
                    destination = mouseDestination.clone();
                }

                if (destination) {
                    movePlayerTowardsDestination();
                } else {
                    player.isMoving = false;
                }

                // Maintain minimum of 50 enemies
                maintainEnemyCount();

                animateHumanoid(player, delta);
                moveEnemies(delta);
                animateDeadEnemies(delta);
                moveQuadrupeds(delta); // Ensure quadrupeds are moving
                updateTeleportation(delta);
                updateLooting(delta);

                // Animate quadrupeds
                quadrupeds.forEach(quadruped => {
                    animateQuadruped(quadruped, delta);
                });

                // Handle camera rotation
                if (rotateLeft) {
                    cameraTargetAngle -= cameraRotationSpeed;
                }
                if (rotateRight) {
                    cameraTargetAngle += cameraRotationSpeed;
                }

                // Smoothly interpolate current angle towards target angle
                currentCameraAngle += (cameraTargetAngle - currentCameraAngle) * 0.1;


                // Update camera position based on current angle
                const cameraRadius = 100;
                const cameraHeight = 50;

                const cameraOffset = new THREE.Vector3(
                    Math.sin(currentCameraAngle) * cameraRadius,
                    cameraHeight,
                    Math.cos(currentCameraAngle) * cameraRadius
                );

                camera.position.copy(player.position).add(cameraOffset);
                camera.lookAt(player.position);


                // Render Main Scene
                renderer.clear();
                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissorTest(false);
                renderer.render(scene, camera);

                // Render Minimap
                minimapCamera.position.x = player.position.x;
                minimapCamera.position.z = player.position.z;

                const minimapContainer = document.getElementById('minimapContainer');
                const mapWidth = minimapContainer.clientWidth;
                const mapHeight = minimapContainer.clientHeight;
                const minimapRect = minimapContainer.getBoundingClientRect();
                const canvasRect = renderer.domElement.getBoundingClientRect();
                const minimapX = minimapRect.left - canvasRect.left;
                const minimapY = minimapRect.top - canvasRect.top;

                renderer.setViewport(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
                renderer.setScissor(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
                renderer.setScissorTest(true);
                renderer.render(scene, minimapCamera);

                // Render Fullscreen Map if visible
                const fullscreenMap = document.getElementById('fullscreenMap');
                if (fullscreenMap.style.display === 'block') {
                    renderMap();
                }
            }

            function onDocumentKeyDown(event) {
                if (inventoryOpen || statsOpen || adminConsoleOpen) {
                    if (inventoryOpen && (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b')) {
                        inventoryOpen = false;
                        document.getElementById('inventory').style.display = 'none';
                    } else if (statsOpen && event.key.toLowerCase() === 'c') {
                        statsOpen = false;
                        document.getElementById('stats').style.display = 'none';
                    } else if (adminConsoleOpen && event.key === '`') {
                        closeAdminConsole();
                    }
                    return;
                            
                }
                        
                if (event.key === 'Escape') { // Handle Esc key
                    closeAllMenus();
                    return;
                }

                if (event.key.toLowerCase() === 'y') {
                    openBestiary();
                    return;
                }


                if (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b') {
                    inventoryOpen = !inventoryOpen;
                    document.getElementById('inventory').style.display = inventoryOpen ? 'block' : 'none';
                    return;
                }

                if (event.key.toLowerCase() === 'c') {
                    statsOpen = !statsOpen;
                    document.getElementById('stats').style.display = statsOpen ? 'block' : 'none';
                    return;
                }

                if (event.key === '`') {
                    if (adminConsoleOpen) {
                        closeAdminConsole();
                    } else {
                        openAdminConsole();
                    }
                    return;
                }


                // Handle toggling of admin window
                if (event.key === '`') {
                    if (!isAdminLoggedIn) {
                        openAdminConsole();
                    } else {
                        closeAdminConsole();
                    }
                    return;
                }

                // Handle toggling of help window
                if (event.key.toLowerCase() === 'h') {
                    helpWindowOpen = !helpWindowOpen;
                    document.getElementById('helpWindow').style.display = helpWindowOpen ? 'block' : 'none';
                    return;
                }

                // Set rotation flags
                if (event.key.toLowerCase() === 'a') {
                    rotateLeft = true;
                    return;
                }
                if (event.key.toLowerCase() === 'd') {
                    rotateRight = true;
                    return;
                }

                if (isTeleporting || isLooting) return;

                if (event.key.toLowerCase() === 't') {
                    if (!isTeleporting) {
                        startTeleportation();
                    }
                }
                        
                if (event.key.toLowerCase() === 'q') {
                    questLogOpen = !questLogOpen;
                    document.getElementById('questLog').style.display = questLogOpen ? 'block' : 'none';
                    return;
                }


                if (event.key.toLowerCase() === 'k') {
                    if (document.getElementById('skillTree').style.display === 'block') {
                        closeSkillTree();
                    } else {
                        openSkillTree();
                    }
                    return;
                }
            }

            document.getElementById('closeHelp').addEventListener('click', function() {
                document.getElementById('helpWindow').style.display = 'none';
                helpWindowOpen = false; // Ensure the variable tracks the state properly
            });


            function onDocumentKeyUp(event) {
                if (event.key.toLowerCase() === 'a') {
                    rotateLeft = false;
                    return;
                }
                if (event.key.toLowerCase() === 'd') {
                    rotateRight = false;
                    return;
                }
            }

            // Add keyup event listener
            document.addEventListener('keyup', onDocumentKeyUp, false);

            function onDocumentMouseDown(event) {
                // Set destination if clicking on ground
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                const chestIntersects = raycaster.intersectObjects(treasureChests, true);
                if (chestIntersects.length > 0) {
                    const chestObject = chestIntersects[0].object;
                    openChestPopup(chestObject);
                    return;
                }

                // If any popups are open or other conditions are met, don't process other keys
                if (inventoryOpen || statsOpen || adminConsoleOpen || isTeleporting || isLooting || helpWindowOpen) return;

                const objects = [ground, safeZoneGround, teleportPad, ...enemies, ...friendlies];
                const intersects = raycaster.intersectObjects([ground, safeZoneGround, teleportPad, ...enemies, ...friendlies], true);

                if (intersects.length > 0) {
                    const intersectedObject = intersects[0].object;
                    const parent = intersectedObject.parent;

                    if (intersectedObject === ground || intersectedObject === safeZoneGround) {
                        const point = intersects[0].point;
                        mouseDestination = new THREE.Vector3(point.x, player.position.y, point.z);
                        destination = new THREE.Vector3(point.x, player.position.y, point.z);
                    } else if (intersectedObject === teleportPad) {
                        if (previousPosition) {
                            player.position.copy(previousPosition);
                            destination = null;
                            previousPosition = null;
                            alert('Teleported back to your previous location.');
                        } else {
                            alert('No previous location to teleport to.');
                        }
                    } else if (parent.userData && parent.userData.type === 'hostile') {
                        if (parent.userData.isDead) {
                            lootEnemy(parent);
                        } else {
                            attackEnemy(parent);
                        }
                    } else if (friendlies.includes(parent)) {
                        if (npcAdminEnabled) {
                            openNpcAdminPopup(parent);
                            return;
                        }
                        openNpcPopup(parent);
                    } else if (parent.userData && parent.userData.type === 'nonHostile') {
                        alert('You see a peaceful creature.');
                    } else if (npcAdminEnabled) {
                        if (structures.includes(parent)) {
                            openStructureAdminPopup(parent);
                            return;
                        }
                        if (settlementWalls.includes(intersectedObject)) {
                            openSettlementWallAdminPopup(intersectedObject);
                            return;
                        }
                    } else if (friendlies.includes(parent)) {
                        if (npcAdminEnabled) {
                            openNpcAdminPopup(parent);
                            return;
                        }
                        openNpcPopup(parent);
                    }
                }
            }

            function onDocumentMouseUp(event) {
                isMouseDown = false;
                mouseDestination = null;
            }

            // Structure Functions:
            function openStructureAdminPopup(structure) {
                currentStructure = structure;
                document.getElementById('structureScaleInput').value = structure.scale.x;
                document.getElementById('structureColorInput').value = '#' + structure.userData.color.getHexString();
                document.getElementById('structureAdminPopup').style.display = 'block';
            }

            function closeStructureAdminPopup() {
                document.getElementById('structureAdminPopup').style.display = 'none';
                currentStructure = null;
            }

            function saveStructureChanges() {
                if (currentStructure) {
                    const scale = parseFloat(document.getElementById('structureScaleInput').value);
                    const colorValue = document.getElementById('structureColorInput').value;
                    const color = new THREE.Color(colorValue);

                    currentStructure.scale.set(scale, scale, scale);

                    // Update color of all child meshes
                    currentStructure.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(color);
                        }
                    });

                    currentStructure.userData.color = color; // Store the new color

                    alert('Structure changes saved.');
                    closeStructureAdminPopup();
                }
            }

            // Implement Map Rendering:
            function renderMap() {
                mapRenderer.render(mapScene, mapCamera);

                // Optionally, add markers for player, enemies, etc.
                addMapMarkers();
            }

            function addMapMarkers() {
                // Clear existing markers
                mapScene.children = mapScene.children.filter(child => !child.userData.isMapMarker);

                // Player Marker
                const playerMarkerGeometry = new THREE.SphereGeometry(10, 16, 16);
                const playerMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const playerMarker = new THREE.Mesh(playerMarkerGeometry, playerMarkerMaterial);
                playerMarker.position.set(player.position.x, 0, player.position.z);
                playerMarker.userData.isMapMarker = true;
                mapScene.add(playerMarker);

                // Enemy Markers
                enemies.forEach(enemy => {
                    if (!enemy.userData.isDead) { // Only mark active enemies
                        const enemyMarkerGeometry = new THREE.SphereGeometry(5, 8, 8);
                        const enemyMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const enemyMarker = new THREE.Mesh(enemyMarkerGeometry, enemyMarkerMaterial);
                        enemyMarker.position.set(enemy.position.x, 0, enemy.position.z);
                        enemyMarker.userData.isMapMarker = true;
                        mapScene.add(enemyMarker);
                    }
                });

                // Add other markers as needed (e.g., friendly NPCs, settlements)
            }
            

            function createQuadruped(color = 0x996633) {
                const group = new THREE.Group();

                // Body
                const bodyMaterial = new THREE.MeshLambertMaterial({ color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 5), bodyMaterial);
                body.position.y = 5;
                group.add(body);

                // Head
                const headMaterial = new THREE.MeshLambertMaterial({ color });
                const head = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), headMaterial);
                head.position.set(7, 7, 0);
                group.add(head);

                // Legs
                const legMaterial = new THREE.MeshLambertMaterial({ color });
                const legGeometry = new THREE.BoxGeometry(1, 5, 1);

                const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontLeftLeg.position.set(4, 2.5, 2);
                group.add(frontLeftLeg);

                const frontRightLeg = frontLeftLeg.clone();
                frontRightLeg.position.z = -2;
                group.add(frontRightLeg);

                const backLeftLeg = frontLeftLeg.clone();
                backLeftLeg.position.x = -4;
                group.add(backLeftLeg);

                const backRightLeg = frontRightLeg.clone();
                backRightLeg.position.x = -4;
                group.add(backRightLeg);

                // Tail
                const tailMaterial = new THREE.MeshLambertMaterial({ color });
                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 5), tailMaterial);
                tail.position.set(-7, 6, 0);
                tail.rotation.y = Math.PI / 4;
                group.add(tail);

                // Animation properties
                group.isMoving = false;
                group.animationTime = 0;
                group.animationSpeed = 5.0;

                // Store legs for animation
                group.legs = [frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg];

                // Direction for movement
                group.userData.direction = new THREE.Vector3();

                // Assign user data
                group.userData.type = 'nonHostile';
                group.userData.name = 'Quadruped';

                return group;
            }

            function createHumanoid(color) {
                const group = new THREE.Group();

                const bodyGeometry = new THREE.BoxGeometry(5, 10, 2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(5, 10, 2), bodyMaterial);
                body.position.y = 10;
                group.add(body);

                const headGeometry = new THREE.BoxGeometry(3, 3, 3);
                const headMaterial = new THREE.MeshLambertMaterial({ color });
                const head = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), headMaterial);
                head.position.y = 17;
                group.add(head);

                const armGeometry = new THREE.BoxGeometry(1, 8, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color });
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-3.5, 10, 0);
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(3.5, 10, 0);
                group.add(rightArm);

                const legGeometry = new THREE.BoxGeometry(2, 10, 2);
                const legMaterial = new THREE.MeshLambertMaterial({ color });
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-1, 5, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(1, 5, 0);
                group.add(rightLeg);

                group.head = head;
                group.body = body;
                group.leftArm = leftArm;
                group.rightArm = rightArm;
                group.leftLeg = leftLeg;
                group.rightLeg = rightLeg;

                group.animationTime = 0;
                group.animationSpeed = 10.0;
                group.isMoving = false;
                group.isAttacking = false;
                group.attackTime = 0;

                group.userData = {
                    name: 'Friendly NPC',
                    health: 100,
                    dialogue: 'Hello!',
                    weight: 1
                };

                return group;
            }

            function animateQuadruped(quadruped, delta) {
                if (quadruped.isMoving) {
                    quadruped.animationTime += delta * quadruped.animationSpeed;
                    const angle = Math.sin(quadruped.animationTime) * (Math.PI / 6);

                    // Front Left & Back Right Legs
                    quadruped.legs[0].rotation.x = angle;
                    quadruped.legs[3].rotation.x = angle;

                    // Front Right & Back Left Legs
                    quadruped.legs[1].rotation.x = -angle;
                    quadruped.legs[2].rotation.x = -angle;
                } else {
                    // Reset leg rotations
                    quadruped.legs.forEach(leg => leg.rotation.x = 0);
                }
            }

            function animateHumanoid(humanoid, delta) {
                if (humanoid.isAttacking) {
                    humanoid.attackTime += delta * humanoid.animationSpeed;
                    const angle = Math.sin(humanoid.attackTime * 20) * (Math.PI / 4);

                    humanoid.rightArm.rotation.x = -angle;

                    if (humanoid.attackTime > 0.5) {
                        humanoid.rightArm.rotation.x = 0;
                        humanoid.isAttacking = false;
                        humanoid.attackTime = 0;
                    }
                } else if (humanoid.isMoving) {
                    humanoid.animationTime += delta * humanoid.animationSpeed;
                    const angle = Math.sin(humanoid.animationTime) * (Math.PI / 6);

                    humanoid.leftArm.rotation.x = angle;
                    humanoid.rightArm.rotation.x = -angle;
                    humanoid.leftLeg.rotation.x = -angle;
                    humanoid.rightLeg.rotation.x = angle;
                } else {
                    humanoid.leftArm.rotation.x = 0;
                    humanoid.rightArm.rotation.x = 0;
                    humanoid.leftLeg.rotation.x = 0;
                    humanoid.rightLeg.rotation.x = 0;
                }
            }

            function createTreasureChest(x, y, z) {
                const chestGeometry = new THREE.BoxGeometry(10, 10, 10);
                const chestMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const chest = new THREE.Mesh(chestGeometry, chestMaterial);
                chest.position.set(x, y + 5, z);

                chest.userData = {
                    type: 'treasureChest',
                    items: generateRandomItems(3),
                    gold: Math.floor(Math.random() * 100) + 50
                };

                scene.add(chest);
                treasureChests.push(chest); // Keep track of treasure chests
                return chest;
            }

            function createSettlement(x, y, z) {
                const settlementGroup = new THREE.Group();

                // Create settlement walls
                const wallsGroup = createSettlementWalls();
                wallsGroup.position.set(x, y, z);
                settlementGroup.add(wallsGroup);

                // Create structures and NPCs
                const positions = [
                    { x: x + 50, z: z + 50 },
                    { x: x - 50, z: z + 50 },
                    { x: x + 50, z: z - 50 },
                    { x: x - 50, z: z - 50 },
                    { x: x, z: z + 70 },
                ];

                positions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, y, pos.z);
                    settlementGroup.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    const npc = createFriendlyNPC();
                    npc.position.set(pos.x, y, pos.z);
                    settlementGroup.add(npc);
                    friendlies.push(npc);
                });

                scene.add(settlementGroup);
            }

            // Function to increase a specific stat
            function increaseStat(stat) {
                if (characterStats.statPoints > 0) {
                    characterStats[stat] += 1;
                    characterStats.statPoints -= 1;
                    updateDisplay();
                } else {
                    alert('No available stat points!');
                }
            }

            // Example function to handle leveling up
            function levelUp() {
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    characterStats.level += 1;
                    characterStats.experience -= characterStats.nextLevelExperience;
                    characterStats.nextLevelExperience = Math.floor(characterStats.nextLevelExperience * 1.5);
                    characterStats.statPoints += 5; // Grant 5 stat points per level
                    alert(`Leveled up to ${characterStats.level}! You have ${characterStats.statPoints} stat points to distribute.`);
                    updateDisplay();
                    
                    // Open trait selection modal upon leveling up
                    openTraitSelection();
                }
            }


            function createSettlementWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallHeight = 30;
                const wallThickness = 2;
                const wallLength = 600;

                const northWallLeftGeometry = new THREE.BoxGeometry(wallLength / 2 - 50, wallHeight, wallThickness);
                const northWallLeft = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, -300);
                scene.add(northWallLeft);
                walls.push(northWallLeft);

                const northWallRight = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, -300);
                scene.add(northWallRight);
                walls.push(northWallRight);

                const gateBarrierGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
                const gateBarrierMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const northGateBarrier = new THREE.Mesh(gateBarrierGeometry, gateBarrierMaterial);
                northGateBarrier.position.set(0, wallHeight / 2, -300);
                scene.add(northGateBarrier);
                enemyWalls.push(northGateBarrier);

                const southWallLeft = northWallLeft.clone();
                southWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, 300);
                scene.add(southWallLeft);
                walls.push(southWallLeft);

                const southWallRight = northWallRight.clone();
                southWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, 300);
                scene.add(southWallRight);
                walls.push(southWallRight);

                const southGateBarrier = northGateBarrier.clone();
                southGateBarrier.position.set(0, wallHeight / 2, 300);
                scene.add(southGateBarrier);
                enemyWalls.push(southGateBarrier);

                const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
                eastWall.position.set(300, wallHeight / 2, 0);
                scene.add(eastWall);
                walls.push(eastWall);

                const westWall = eastWall.clone();
                westWall.position.set(-300, wallHeight / 2, 0);
                scene.add(westWall);
                walls.push(westWall);

                // Add white walls at gate barriers
                const northGateWhiteWall = createWhiteWall();
                northGateWhiteWall.position.set(0, 15, -300); // Position at the gate
                scene.add(northGateWhiteWall);

                const southGateWhiteWall = createWhiteWall();
                southGateWhiteWall.position.set(0, 15, 300); // Position at the gate
                scene.add(southGateWhiteWall);

                // Add to walls array if enemies should collide
                walls.push(northGateWhiteWall);
                walls.push(southGateWhiteWall);
            }

            function createStructure() {
                const building = new THREE.Group();

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;
                const wallColor = 0x8B4513;

                const frontWallShape = new THREE.Shape();
                frontWallShape.moveTo(-wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, 0);

                const doorWidth = 10;
                const doorHeight = 20;
                const doorX = -doorWidth / 2;
                const doorY = 0;

                const doorHole = new THREE.Path();
                doorHole.moveTo(doorX, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY);
                frontWallShape.holes.push(doorHole);

                const frontWallGeometry = new THREE.ShapeGeometry(frontWallShape);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                const backWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.z = wallLength / 2;
                backWall.position.y = wallHeight / 2;
                building.add(backWall);

                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                rightWall.position.x = wallLength / 2;
                rightWall.position.y = wallHeight / 2;
                building.add(rightWall);

                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                return building;
            }

            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }

            function getRandomPositionOutsideTown(minDistance, maxDistance) {
                let angle = Math.random() * 2 * Math.PI;
                let distance = minDistance + Math.random() * (maxDistance - minDistance);
                let x = Math.cos(angle) * distance;
                let z = Math.sin(angle) * distance;
                return { x: x, z: z };
            }

            function createEnemy(x, y, z, type = 'red') {
                let color;
                let damageRate; // Damage per second

                if (type === 'blue') {
                    color = 0x0000ff; // Blue color
                    damageRate = 4; // 2x damage assuming base is 2
                } else {
                    color = 0xff0000; // Red color
                    damageRate = 2; // Base damage per second
                }

                const enemy = createHumanoid(color);
                enemy.position.set(x, 0, z);
                enemy.userData.type = 'hostile';
                enemy.userData.isDead = false; 
                enemy.userData.hasBeenLooted = false; // Initialize flag
                enemy.userData.deathTime = 0; // Existing initialization
                enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                enemy.isMoving = true; 
                enemy.userData.damageRate = damageRate; // Assign damage rate
                scene.add(enemy);
                return enemy;
            }

            function moveQuadrupeds(delta) {
                quadrupeds.forEach((quadruped) => {
                    if (quadruped.isDead) return; // Optional: Handle dead quadrupeds

                    // Simple wandering logic
                    if (!quadruped.isMoving) {
                        // Decide to move or stay
                        if (Math.random() < 0.01) { // 1% chance to start moving each frame
                            quadruped.isMoving = true;
                            // Random direction
                            const angle = Math.random() * 2 * Math.PI;
                            quadruped.userData.direction.set(Math.cos(angle), 0, Math.sin(angle));
                            // Rotate to face direction
                            quadruped.rotation.y = angle;
                        }
                    } else {
                        // Move in the set direction
                        const moveDistance = globalEnemySpeed * delta * 10; // Adjust speed as needed
                        quadruped.position.add(quadruped.userData.direction.clone().multiplyScalar(moveDistance));

                        // Check for collisions with walls
                        let collided = false;
                        for (let wall of walls) {
                            const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (quadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        for (let wall of enemyWalls) {
                            const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (quadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            quadruped.position.sub(quadruped.userData.direction.clone().multiplyScalar(moveDistance));
                            quadruped.isMoving = false;
                        } else {
                            quadruped.isMoving = true;
                        }

                        // Stop moving after a certain distance or time
                        if (Math.random() < 0.005) { // 0.5% chance to stop moving each frame
                            quadruped.isMoving = false;
                        }
                    }

                    // Animate quadruped
                    animateQuadruped(quadruped, delta);
                });
            }
                    
            function toggleFullscreenMap() {
                const fullscreenMap = document.getElementById('fullscreenMap');
                if (fullscreenMap.style.display === 'none') {
                    fullscreenMap.style.display = 'block';
                    renderMap(); // Initial render
                } else {
                    fullscreenMap.style.display = 'none';
                }
            }

            function closeFullscreenMap() {
                const fullscreenMap = document.getElementById('fullscreenMap');
                fullscreenMap.style.display = 'none';
            }
                    
            function addQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    const quadruped = createQuadruped();
                    quadruped.position.set(position.x, 0, position.z);
                    quadrupeds.push(quadruped);
                    scene.add(quadruped);
                }
            }

            function movePlayerTowardsDestination() {
                const direction = new THREE.Vector3().subVectors(destination, player.position);
                const distance = direction.length();
                if (distance > 0.1) {
                    direction.normalize();
                    const moveDistance = Math.min(speed, distance);
                    const oldPosition = player.position.clone();
                    player.position.add(direction.multiplyScalar(moveDistance));

                    let collided = false;
                    for (let wall of walls) {
                        const playerBox = new THREE.Box3().setFromObject(player);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        if (playerBox.intersectsBox(wallBox)) {
                            collided = true;
                            break;
                        }
                    }

                    if (collided) {
                        player.position.copy(oldPosition);
                        destination = null;
                        player.isMoving = false;
                    } else {
                        player.isMoving = true;
                        // Rotate player to face the direction of movement
                        player.rotation.y = Math.atan2(direction.x, direction.z);
                    }
                } else {
                    player.position.copy(destination);
                    destination = null;
                    player.isMoving = false;
                }
            }

            function createWhiteWall() {
                const wallGeometry = new THREE.BoxGeometry(10, 30, 2); // Adjust size as needed
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White color
                const whiteWall = new THREE.Mesh(wallGeometry, wallMaterial);
                whiteWall.userData.isWhiteWall = true; // Flag to identify white walls
                return whiteWall;
            }

            // Ensure the help window properly adjusts when the window is resized
            window.addEventListener('resize', onWindowResize);

            // Adjusting for window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                minimapCamera.left = -200;
                minimapCamera.right = 200;
                minimapCamera.top = 200;
                minimapCamera.bottom = -200;
                minimapCamera.updateProjectionMatrix();
            }



            initMap();
            init();
            animate();

            function openNpcPopup(npc) {
                if (npcPopupOpen) {
                    closeNpcPopup();
                    return;
                }
                document.getElementById('npcPopup').querySelector('h2').innerText = npc.userData.name || 'Friendly NPC';
                document.getElementById('npcPopup').querySelector('p').innerText = npc.userData.dialogue || 'Hello, traveler! Stay awhile and listen...';
                document.getElementById('npcPopup').style.display = 'block';
                npcPopupOpen = true;
            }

            function closeNpcPopup() {
                document.getElementById('npcPopup').style.display = 'none';
                npcPopupOpen = false;
            }

            function openNpcAdminPopup(npc) {
                currentNpc = npc;
                document.getElementById('npcNameInput').value = npc.userData.name || '';
                document.getElementById('npcHealthInput').value = npc.userData.health || 100;
                document.getElementById('npcDialogueInput').value = npc.userData.dialogue || '';

                // Set initial colors
                document.getElementById('npcHeadColorInput').value = '#' + npc.head.material.color.getHexString();
                document.getElementById('npcBodyColorInput').value = '#' + npc.body.material.color.getHexString();
                document.getElementById('npcArmColorInput').value = '#' + npc.leftArm.material.color.getHexString();
                document.getElementById('npcLegColorInput').value = '#' + npc.leftLeg.material.color.getHexString();

                document.getElementById('npcAdminPopup').style.display = 'block';
            }

            function closeNpcAdminPopup() {
                document.getElementById('npcAdminPopup').style.display = 'none';
                currentNpc = null;
            }

            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }

            function saveNpcChanges() {
                if (currentNpc) {
                    currentNpc.userData.name = document.getElementById('npcNameInput').value;
                    currentNpc.userData.health = parseInt(document.getElementById('npcHealthInput').value) || 100;
                    currentNpc.userData.dialogue = document.getElementById('npcDialogueInput').value;

                    // Update colors
                    const headColor = new THREE.Color(document.getElementById('npcHeadColorInput').value);
                    const bodyColor = new THREE.Color(document.getElementById('npcBodyColorInput').value);
                    const armColor = new THREE.Color(document.getElementById('npcArmColorInput').value);
                    const legColor = new THREE.Color(document.getElementById('npcLegColorInput').value);

                    currentNpc.head.material.color.set(headColor);
                    currentNpc.body.material.color.set(bodyColor);
                    currentNpc.leftArm.material.color.set(armColor);
                    currentNpc.rightArm.material.color.set(armColor);
                    currentNpc.leftLeg.material.color.set(legColor);
                    currentNpc.rightLeg.material.color.set(legColor);

                    alert('NPC changes saved.');
                    closeNpcAdminPopup();
                }
            }

            // Function to open Admin Console
            function openAdminConsole() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'flex';
                adminConsoleOpen = true;

                // Reset to Login tab when opening
                setActiveAdminTab('adminLogin');
            }

            // Function to close Admin Console
            function closeAdminConsole() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'none';
                adminConsoleOpen = false;

                // Reset admin login status to require password again
                isAdminLoggedIn = false;
                setActiveAdminTab('adminLogin');
            }

            // Function to set active admin tab
            function setActiveAdminTab(tabId) {
                // Remove 'active' class from all tabs
                const tabs = document.querySelectorAll('.admin-tabs .tab-button');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                });

                // Hide all tab contents
                const tabContents = document.querySelectorAll('.admin-tab-content');
                tabContents.forEach(content => {
                    content.classList.remove('active');
                });

                // Activate the selected tab
                const activeTab = document.querySelector(`.admin-tabs .tab-button[data-tab="${tabId}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }

                // Show the selected tab content
                const activeContent = document.getElementById(tabId);
                if (activeContent) {
                    activeContent.classList.add('active');
                }

                // Special handling for tabs that require admin login
                const adminOnlyTabs = ['playerManagement', 'gameSettings', 'spawnOptions', 'teleportPlayer', 'npcAdmin'];
                if (adminOnlyTabs.includes(tabId) && !isAdminLoggedIn) {
                    alert('Please log in as admin to access this section.');
                    setActiveAdminTab('adminLogin');
                }
            }

            // Function to handle tab clicks
            function setupAdminTabs() {
                const tabs = document.querySelectorAll('.admin-tabs .tab-button');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.getAttribute('data-tab');
                        setActiveAdminTab(tabId);
                    });
                });
            }

            // Function to check Admin Password
            function checkAdminPassword() {
                const passwordInput = document.getElementById('adminPassword').value;
                if (passwordInput === 'ltwelcome1') { // Replace with secure authentication in production
                    isAdminLoggedIn = true;
                    alert('Admin login successful!');
                    setActiveAdminTab('playerManagement'); // Redirect to Player Management or desired tab

                    // Attach event listeners for admin controls
                    attachAdminEventListeners();
                } else {
                    alert('Incorrect password!');
                }
            }

            // Function to attach event listeners for admin controls
            function attachAdminEventListeners() {
                // Ensure event listeners are attached only once
                const npcAdminCheckbox = document.getElementById('npcAdminCheckbox');
                if (npcAdminCheckbox && !npcAdminCheckbox.hasAttribute('data-listener')) {
                    npcAdminCheckbox.addEventListener('change', function() {
                        npcAdminEnabled = this.checked;
                        alert('NPC Admin Mode ' + (npcAdminEnabled ? 'Enabled' : 'Disabled'));
                    });
                    npcAdminCheckbox.setAttribute('data-listener', 'true');
                }
            }

            // Function to update Player Stats
            function updatePlayerStats() {
                const healthInput = parseInt(document.getElementById('playerHealthInput').value);
                const goldInput = parseInt(document.getElementById('playerGoldInput').value);
                const experienceInput = parseInt(document.getElementById('playerExperienceInput').value);

                if (!isNaN(healthInput)) {
                    playerHealth = Math.min(healthInput, playerMaxHealth);
                    updateHealthDisplay();
                }
                if (!isNaN(goldInput)) {
                    gold = goldInput;
                    updateGoldDisplay();
                }
                if (!isNaN(experienceInput)) {
                    characterStats.experience = experienceInput;
                    if (characterStats.experience >= characterStats.nextLevelExperience) {
                        levelUp();
                    }
                    updateStatsDisplay();
                }
                alert('Player stats updated.');
            }

            // Function to update Player Options
            function updatePlayerOptions() {
                playerInvulnerable = document.getElementById('invulnerabilityCheckbox').checked;
                alert('Player options updated.');
            }

            // Function to update Game Settings
            function updateGameSettings() {
                const enemySpeedInput = parseFloat(document.getElementById('enemySpeedInput').value);

                if (!isNaN(enemySpeedInput) && enemySpeedInput > 0) {
                    globalEnemySpeed = enemySpeedInput;
                    alert('Game settings updated.');
                } else {
                    alert('Invalid enemy speed!');
                }
            }

            // Teleport Player with Confirmation
            function teleportPlayer() {
                const x = parseInt(document.getElementById('teleportXInput').value);
                const z = parseInt(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    if (confirm(`Are you sure you want to teleport the player to (${x}, ${z})?`)) {
                        player.position.set(x, player.position.y, z);
                        alert(`Player teleported to (${x}, ${z}).`);
                    }
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // Spawn Entities with Loading Indicator
            function spawnEntities() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity < 1) {
                    alert('Please enter a valid quantity.');
                    return;
                }

                if (confirm(`Are you sure you want to spawn ${quantity} ${entityType}(s)?`)) {
                    // Show loading indicator
                    document.getElementById('adminLoading').style.display = 'flex';

                    setTimeout(() => { // Simulate async operation
                        for (let i = 0; i < quantity; i++) {
                            // Implement your entity spawning logic here
                            console.log(`Spawning ${entityType} (${i + 1}/${quantity})`);
                            // Example: spawnEntity(entityType);
                        }

                        alert(`Spawned ${quantity} ${entityType}(s).`);

                        // Hide loading indicator
                        document.getElementById('adminLoading').style.display = 'none';
                    }, 1000); // Adjust timeout as needed based on actual spawning time
                }
            }


            // Function to handle closing all menus (existing functionality)
            function closeAllMenus() {
                // Close Inventory
                if (inventoryOpen) {
                    inventoryOpen = false;
                    document.getElementById('inventory').style.display = 'none';
                }

                // Close Stats
                if (statsOpen) {
                    statsOpen = false;
                    document.getElementById('stats').style.display = 'none';
                }

                // Close Admin Console
                if (adminConsoleOpen) {
                    closeAdminConsole();
                }

                // Close Quest Log
                if (questLogOpen) { // We'll define questLogOpen
                    questLogOpen = false;
                    document.getElementById('questLog').style.display = 'none';
                }

                // Close Help Window
                if (helpWindowOpen) {
                    helpWindowOpen = false;
                    document.getElementById('helpWindow').style.display = 'none';
                }

                // Close Loot Popup
                if (isLooting) {
                    isLooting = false;
                    document.getElementById('lootBarContainer').style.display = 'none';
                    document.getElementById('lootBar').style.width = '0%';
                }
                document.getElementById('lootPopup').style.display = 'none';

                // Close NPC Popup
                if (npcPopupOpen) {
                    closeNpcPopup();
                }

                // Close Chest Popup
                if (currentOpenedChest) {
                    closeChestPopup();
                }

                // Close Skill Tree
                if (document.getElementById('skillTree').style.display === 'block') {
                    closeSkillTree();
                }

                // Close Fullscreen Map
                if (document.getElementById('fullscreenMap').style.display === 'block') {
                    closeFullscreenMap();
                }

                // Add more menus as needed
            }

            // Function to add experience (existing functionality)
            function addExperience(amount) {
                characterStats.experience += amount;
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    levelUp();
                }
                updateStatsDisplay();
            }

            // Function to handle hotbar slot selection (existing functionality)
            function handleHotbarSelection(slotNumber) {
                const selectedSlot = document.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (selectedSlot) {
                    // Add a visual indicator for selection (e.g., a border)
                    document.querySelectorAll('.slot').forEach(slot => slot.style.borderColor = '#555'); // Reset all borders
                    selectedSlot.style.borderColor = '#FFD700'; // Highlight selected slot with gold color

                    // Implement the action you want when a slot is selected
                    // For example, equip the item in the slot or activate its ability
                    console.log(`Hotbar slot ${slotNumber} selected.`);
                    // Add your custom action here
                }
            }

            // Initialize Admin Tabs on DOM Content Loaded
            document.addEventListener('DOMContentLoaded', () => {
                setupAdminTabs();
            });

            // JavaScript source code
            // Add a Purple Structure a Little Ways Away from Town
                const purpleStructure = createPurpleStructure();
                purpleStructure.position.set(800, 0, -800); // Adjust position as desired
                scene.add(purpleStructure);

                
            // Function to Create Purple Structure
            function createPurpleStructure() {
                const building = new THREE.Group();

                // Define wall material and dimensions
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Purple color
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;

                // Front Wall
                const frontWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                // Back Wall
                const backWall = frontWall.clone();
                backWall.position.z = wallLength / 2;
                building.add(backWall);

                // Left Wall
                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                // Right Wall
                const rightWall = leftWall.clone();
                rightWall.position.x = wallLength / 2;
                building.add(rightWall);

                // Roof
                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Purple color
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                // Add walls to userData for collision detection
                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                // Add a black floor
                const floorGeometry = new THREE.PlaneGeometry(50, 50);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1; // Slightly above ground to avoid z-fighting
                building.add(floor);

                return building;
            }

            document.addEventListener('DOMContentLoaded', () => {
                initializeBestiary();
                setupEventListeners();
                initializeBestiaryUI();
            });

            function initializeBestiaryUI() {
                // Add this to ensure rendering when opened
                document.getElementById('openBestiary').addEventListener('click', () => {
                    openBestiary();
                    renderBestiary();
                });
            }

            /**
             * Initializes the bestiary by loading all species data.
             */
            function initializeBestiary() {
                window.bestiary = {}; // Initialize the bestiary object

                const standardizedWidth = 128;
                const standardizedHeight = 128;

                const speciesData = {
                    humans: {
                        highResImage: {
                            src: 'images/bestiary/humans.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Humans',
                        description: 'Humans, once masters of a thriving world, now traverse the remnants, their spirits unbroken. Their resilience and adaptability have become legendary.',
                        extendedDescription: 'In the aftermath of cataclysmic events that shattered their civilization, humans have learned to adapt to the harshest of environments. They harness remnants of old technology and combine it with newfound survival techniques. Their cities lie in ruins, but from the ashes, they build shelters, forge alliances, and continue to dream of a better future. The human spirit is unyielding, and their creativity knows no bounds as they navigate the challenges of a changed world.',
                        history: 'Once the dominant species on Earth, humans thrived with advanced technology and sprawling civilizations. However, a series of cataclysmic events, possibly self-inflicted, brought about the downfall of their societies. Now, they live in smaller communities, scavenging the remnants of their past while striving to rebuild. Tales are told of the old world, serving both as a warning and a beacon of hope for future generations.',
                        abilities: 'Humans possess remarkable adaptability, able to adjust to new environments and situations swiftly. Their resilience is legendary, enabling them to endure hardships that would break other species. Technological ingenuity allows them to repurpose old technologies and innovate solutions with limited resources. They are also known for their diplomatic abilities, often acting as mediators between other races.',
                        culture: 'Human culture is a rich tapestry woven from countless traditions, languages, and beliefs. In the post-apocalyptic world, they have developed a culture centered around community, survival, and storytelling. Music, art, and literature have become means of preserving their history and inspiring hope. Despite their fragmented state, humans place great value on cooperation and learning from the mistakes of the past.',
                        modelName: 'humans',
                        stats: {
                            STR: 80,
                            DEX: 50,
                            AGI: 60,
                            VIT: 70,
                            COM: 40,
                            INT: 65,
                            PER: 55,
                            CHA: 70,
                            PSY: 30
                        }
                    },
                    tal_ehn: {
                        highResImage: {
                            src: 'images/high-res/tal_ehn.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Tal'ehn",
                        description: "The Tal'ehn are a small species known for their advanced technology and space travel, constantly seeking knowledge beyond the stars.",
                        extendedDescription: "Tal'ehn are pioneers in interstellar navigation, adapting their technologies to explore beyond their home worlds. Their thirst for knowledge is unquenchable, and they have been known to engage in exploratory missions to distant galaxies, always seeking to understand the universe around them.",
                        history: "An ancient race that has seen the rise and fall of many civilizations, the Tal'ehn have preserved their heritage through wisdom and innovation. Their history is marred by conflicts with less enlightened species, but they continue to strive for peace and understanding.",
                        abilities: "Technological prowess, curiosity, and exploration skills make them formidable in both diplomacy and combat. They are able to quickly adapt to new environments and challenges.",
                        culture: "A culture based on knowledge and scientific advancement, the Tal'ehn value education, research, and collaboration. They are often seen as guardians of knowledge, holding their archives sacred.",
                        modelName: 'tal_ehn',
                        stats: {
                            STR: 40,
                            DEX: 60,
                            AGI: 50,
                            VIT: 70,
                            COM: 20,
                            INT: 150,
                            PER: 80,
                            CHA: 70,
                            PSY: 200
                        }
                    },
                    shal_rah_prime: {
                        highResImage: {
                            src: 'images/high-res/shal_rah_prime.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Shal'Rah Prime",
                        description: "The Shal'Rah Prime are a hostile insectoid race known for their aggressive conquests of other worlds. Beware their cunning!",
                        extendedDescription: "Cunning and ruthless, they dominate through fear and overwhelming tactics, seeking to expand their territories at all costs. Their hives are a manifestation of their hierarchical society, where strength reigns supreme.",
                        history: "Evolved on a harsh world that shaped their existence, the Shal'Rah Prime have fought fiercely against all rivals, consolidating power and spreading their influence to numerous colonies.",
                        abilities: "Strength, swiftness, and overwhelming numbers make them a dangerous foe on the battlefield.",
                        culture: "Built on a foundation of hierarchy and conquest, their culture revolves around loyalty to the hive and the queen, with every individual existing to serve the greater whole.",
                        modelName: 'shal_rah_prime',
                        stats: {
                            STR: 100,
                            DEX: 40,
                            AGI: 30,
                            VIT: 90,
                            COM: 60,
                            INT: 80,
                            PER: 70,
                            CHA: 50,
                            PSY: 100
                        }
                    },
                    shal_rah_talorian: {
                        highResImage: {
                            src: 'images/high-res/shal_rah_talorian.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Shal'Rah Talorian",
                        description: "The Talorians excel in diplomacy, struggling against the encroaching invasions and fighting to maintain their culture.",
                        extendedDescription: "A sophisticated people who value peace and mutual respect, Talorians engage in complex negotiations to secure their future against overwhelming odds. They are known for their artistry and traditions that reflect their rich history.",
                        history: "Once a prosperous civilization now on the brink of war, the Talorians have weathered many storms but remain steadfast in their beliefs, cherishing the lessons of the past.",
                        abilities: "Diplomatic skill and advanced negotiation tactics make them unique, often able to avert conflicts and find peaceful resolutions.",
                        culture: "Rich traditions with great respect for nature and the arts define their society. They prioritize harmony and balance, drawing strength from their communities.",
                        modelName: 'shal_rah_talorian',
                        stats: {
                            STR: 50,
                            DEX: 70,
                            AGI: 80,
                            VIT: 60,
                            COM: 100,
                            INT: 50,
                            PER: 60,
                            CHA: 80,
                            PSY: 30
                        }
                    },
                    shal_rah_t_ana_rhe: {
                        highResImage: {
                            src: 'images/high-res/shal_rah_t_ana_rhe.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Shal'Rah T'ana'Rhe",
                        description: "The T'ana'Rhe are bird-like psions known for their healing abilities and facing oppression by their own leaders.",
                        extendedDescription: "They are known for their powerful psionic abilities, which they harness for both healing and protection, often acting as mediators among species. Despite their talents, they strive for freedom from their oppressive rulers.",
                        history: "An ancient race constantly fighting for their freedom, their history is littered with struggles against authoritarianism and the quest for peace.",
                        abilities: "Healing, telepathy, and foresight are their main abilities as they navigate the complex socio-political landscape of their world.",
                        culture: "A deeply spiritual culture connected to the universe, they value empathy and harmony, often seeking a greater understanding with all beings.",
                        modelName: 'shal_rah_t_ana_rhe',
                        stats: {
                            STR: 20,
                            DEX: 30,
                            AGI: 50,
                            VIT: 70,
                            COM: 40,
                            INT: 90,
                            PER: 100,
                            CHA: 70,
                            PSY: 150
                        }
                    },
                    shal_rah_dengar: {
                        highResImage: {
                            src: 'images/high-res/shal_rah_dengar.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Shal'Rah Dengar",
                        description: "The Dengar chose to ally with the Shal'Rah, proficient in brute strength and combat tactics throughout the galaxy.",
                        extendedDescription: "Fierce warriors, they value strength and training above all else, often becoming the backbone of military campaigns in support of the Shal'Rah.",
                        history: "Former rivals to the Shal'Rah, now steadfast allies, they have united for greater power against common threats.",
                        abilities: "Combat skills, resilience, and tactical prowess offer them a prominent role in both strategy and action.",
                        culture: "Honor and strength define their ways, with a deep-rooted respect for warriors and their legacies.",
                        modelName: 'shal_rah_dengar',
                        stats: {
                            STR: 90,
                            DEX: 60,
                            AGI: 40,
                            VIT: 100,
                            COM: 30,
                            INT: 30,
                            PER: 50,
                            CHA: 20,
                            PSY: 40
                        }
                    },
                    custom: {
                        highResImage: {
                            src: 'images/high-res/custom.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Custom',
                        description: 'Create a unique race with tailored abilities to suit your individual play style. The possibilities are endless!',
                        extendedDescription: 'The creation is limited only by imagination and resourcefulness, allowing players a vast array of options.',
                        history: "Each custom race holds a unique story, reflecting the creator's vision of strengths and culture.",
                        abilities: "Varying abilities based on the creator's choice, they encompass a wide range of gameplay experiences.",
                        culture: "A culture shaped by individual creativity ensures that each creation is as unique as its maker.",
                        modelName: 'custom',
                        stats: {
                            STR: 60,
                            DEX: 60,
                            AGI: 60,
                            VIT: 60,
                            COM: 60,
                            INT: 60,
                            PER: 60,
                            CHA: 60,
                            PSY: 60
                        }
                    }
                };

                window.bestiary = speciesData;
            }


            /**
             * Sets up event listeners for bestiary interactions.
             */
            function setupEventListeners() {
                const openBestiaryButton = document.getElementById('openBestiary');
                const closeBestiaryButton = document.getElementById('closeBestiary');
                const bestiaryModal = document.getElementById('bestiaryModal');

                if (openBestiaryButton) {
                    openBestiaryButton.addEventListener('click', openBestiary);
                }

                if (closeBestiaryButton) {
                    closeBestiaryButton.addEventListener('click', closeBestiary);
                }

                window.addEventListener('click', (event) => {
                    if (event.target === bestiaryModal) {
                        closeBestiary();
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'y' || e.key === 'Y') {
                        openBestiary();
                    }
                    if (e.key === 'Escape' && bestiaryModal.classList.contains('show')) {
                        closeBestiary();
                    }
                });
            }

            /**
             * Renders the bestiary content by listing all races.
             */
            function renderBestiary() {
                console.log('renderBestiary() called');
                const bestiaryDiv = document.getElementById('bestiaryContent');
                bestiaryDiv.innerHTML = ''; // Clear existing content

                for (const key in window.bestiary) {
                    if (window.bestiary.hasOwnProperty(key)) {
                        const creature = window.bestiary[key];
                        const creatureCard = document.createElement('div');
                        creatureCard.classList.add('creature-card');

                        creatureCard.innerHTML = `
                            <img src="${creature.highResImage}" alt="${creature.name}" class="creature-image">
                            <div class="creature-info">
                                <h3>${creature.name}</h3>
                                <p>${creature.description}</p>
                                <button class="view-details-button" data-creature="${key}">View Details</button>
                            </div>
                        `;

                        bestiaryDiv.appendChild(creatureCard);
                    }
                }

                // Add event listeners to view details buttons
                const viewDetailsButtons = document.querySelectorAll('.view-details-button');
                viewDetailsButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const creatureKey = button.getAttribute('data-creature');
                        displayRaceDetails(creatureKey);
                    });
                });
            }

            /**
             * Displays detailed information about a selected race in a modal.
             * @param {string} creatureKey - The key of the creature in the bestiary data.
             */
            function displayRaceDetails(creatureKey) {
                const creature = window.bestiary[creatureKey];
                if (!creature) return;

                const detailsModal = document.getElementById('creatureDetailsModal');
                const detailsContent = document.getElementById('creatureDetailsContent');

                detailsContent.innerHTML = `
                    <img src="${creature.highResImage}" alt="${creature.name}" class="creature-detail-image">
                    <h2>${creature.name}</h2>
                    <p>${creature.extendedDescription}</p>
                    <h3>History</h3>
                    <p>${creature.history}</p>
                    <h3>Abilities</h3>
                    <p>${creature.abilities}</p>
                    <h3>Culture</h3>
                    <p>${creature.culture}</p>
                    <h3>Stats</h3>
                    <div class="stats-container">
                        ${generateStatsHTML(creature.stats)}
                    </div>
                    <div id="model-container-${creatureKey}" class="model-container"></div>
                `;

                detailsModal.classList.add('show');
                detailsModal.setAttribute('aria-hidden', 'false');

                // Close Race Details Modal
                const closeDetailsButton = detailsModal.querySelector('.close-details');
                closeDetailsButton.addEventListener('click', () => {
                    closeCreatureDetails(creatureKey);
                });

                // Close when clicking outside the modal content
                detailsModal.addEventListener('click', (event) => {
                    if (event.target === detailsModal) {
                        closeCreatureDetails(creatureKey);
                    }
                });

                // Load 3D model
                loadCreatureModel(creature.modelName, `model-container-${creatureKey}`);
            }

            /**
             * Generates HTML for the stats section.
             * @param {object} stats - The stats object containing various stat values.
             * @returns {string} - The generated HTML string for stats.
             */
            function generateStatsHTML(stats) {
                let statsHTML = '';
                for (const stat in stats) {
                    if (stats.hasOwnProperty(stat)) {
                        const value = stats[stat];
                        const percentage = Math.min((value / 150) * 100, 100); // Assuming 150 is the max stat value
                        statsHTML += `
                            <div class="stat-item">
                                <span>${stat}:</span>
                                <div class="stat-bar">
                                    <div class="progress" style="width: ${percentage}%;"></div>
                                </div>
                            </div>
                        `;
                    }
                }
                return statsHTML;
            }

            /**
             * Loads a 3D model using Three.js and GLTFLoader.
             * @param {string} modelName - The name of the model file (without extension).
             * @param {string} containerId - The ID of the container where the model will be rendered.
             */
            function loadCreatureModel(modelName, containerId) {
                const modelPath = `models/${modelName}.glb`;
                const container = document.getElementById(containerId);

                if (!container) return;

                // Initialize Three.js Scene
                const scene = new THREE.Scene();

                // Camera setup
                const camera = new THREE.PerspectiveCamera(
                    75,
                    container.clientWidth / container.clientHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;

                // Renderer setup
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 1);
                scene.add(ambientLight);

                // GLTFLoader to load the model
                const loader = new THREE.GLTFLoader();
                loader.load(
                    modelPath,
                    function (gltf) {
                        scene.add(gltf.scene);
                        animate();
                    },
                    undefined,
                    function (error) {
                        console.error('An error occurred while loading the model:', error);
                    }
                );

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }

                // Handle window resize
                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                });
            }

            /**
             * Populates and opens the bestiary modal.
             */
            function openBestiary() {
                console.log('openBestiary() called');
                const bestiaryModal = document.getElementById('bestiaryModal');
                populateBestiaryModal();
                bestiaryModal.classList.add('show');
                bestiaryModal.setAttribute('aria-hidden', 'false');
            }

            /**
             * Closes the bestiary modal.
             */
            function closeBestiary() {
                const bestiaryModal = document.getElementById('bestiaryModal');
                bestiaryModal.classList.remove('show');
                bestiaryModal.setAttribute('aria-hidden', 'true');

                // Also close creature details if open
                const detailsModal = document.getElementById('creatureDetailsModal');
                if (detailsModal.classList.contains('show')) {
                    closeCreatureDetails();
                }
            }


            /**
             * Populates the bestiary modal with all races.
             */
            function populateBestiaryModal() {
                renderBestiary();
            }

            /**
             * Closes the creature details modal.
             * @param {string} creatureKey - The key of the creature to close details for.
             */
            function closeCreatureDetails(creatureKey) {
                const detailsModal = document.getElementById('creatureDetailsModal');
                detailsModal.classList.remove('show');
                detailsModal.setAttribute('aria-hidden', 'true');

                // Optionally, remove the 3D model to free up resources
                const modelContainer = document.getElementById(`model-container-${creatureKey}`);
                if (modelContainer) {
                    modelContainer.innerHTML = '';
                }
            }

            // Function to create settlement walls
            function createSettlementWalls() {
                const wallsGroup = new THREE.Group();

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallHeight = 30;
                const wallThickness = 2;
                const wallLength = 600;

                const northWallLeftGeometry = new THREE.BoxGeometry(wallLength / 2 - 50, wallHeight, wallThickness);
                const northWallLeft = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, -300);
                wallsGroup.add(northWallLeft);
                walls.push(northWallLeft);

                const northWallRight = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, -300);
                wallsGroup.add(northWallRight);
                walls.push(northWallRight);

                const gateBarrierGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
                const gateBarrierMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const northGateBarrier = new THREE.Mesh(gateBarrierGeometry, gateBarrierMaterial);
                northGateBarrier.position.set(0, wallHeight / 2, -300);
                wallsGroup.add(northGateBarrier);
                enemyWalls.push(northGateBarrier);

                const southWallLeft = northWallLeft.clone();
                southWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, 300);
                wallsGroup.add(southWallLeft);
                walls.push(southWallLeft);

                const southWallRight = northWallRight.clone();
                southWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, 300);
                wallsGroup.add(southWallRight);
                walls.push(southWallRight);

                const southGateBarrier = northGateBarrier.clone();
                southGateBarrier.position.set(0, wallHeight / 2, 300);
                wallsGroup.add(southGateBarrier);
                enemyWalls.push(southGateBarrier);

                const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
                eastWall.position.set(300, wallHeight / 2, 0);
                wallsGroup.add(eastWall);
                walls.push(eastWall);

                const westWall = eastWall.clone();
                westWall.position.set(-300, wallHeight / 2, 0);
                wallsGroup.add(westWall);
                walls.push(westWall);

                // Add white walls at gate barriers
                const northGateWhiteWall = createWhiteWall();
                northGateWhiteWall.position.set(0, 15, -300);
                wallsGroup.add(northGateWhiteWall);

                const southGateWhiteWall = createWhiteWall();
                southGateWhiteWall.position.set(0, 15, 300);
                wallsGroup.add(southGateWhiteWall);

                walls.push(northGateWhiteWall);
                walls.push(southGateWhiteWall);

                return wallsGroup;
            }

            // Function to create settlement
            function createSettlement(x, y, z) {
                const settlementGroup = new THREE.Group();

                // Create settlement walls
                const wallsGroup = createSettlementWalls();
                wallsGroup.position.set(x, y, z);
                settlementGroup.add(wallsGroup);

                // Create structures and NPCs
                const positions = [
                    { x: x + 50, z: z + 50 },
                    { x: x - 50, z: z + 50 },
                    { x: x + 50, z: z - 50 },
                    { x: x - 50, z: z - 50 },
                    { x: x, z: z + 70 },
                ];

                positions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, y, pos.z);
                    settlementGroup.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    const npc = createFriendlyNPC();
                    npc.position.set(pos.x, y, pos.z);
                    settlementGroup.add(npc);
                    friendlies.push(npc);
                });

                scene.add(settlementGroup);
            }

            function initializeInventory() {
                // Initialize inventory arrays and UI elements
                playerInventory = [];
                generateInventorySlots();
                setupInventoryTabs();
                updateInventoryDisplay();
            }

            function addItemToInventory(item) {
                playerInventory.push(item);
                updateInventoryDisplay();
            }

            function updateInventoryDisplay() {
                // Loop through all inventory tabs and update their grids
                for (let i = 1; i <= 6; i++) {
                    const grid = document.getElementById(`inventoryGridTab${i}`);
                    grid.innerHTML = ''; // Clear existing items
                    playerInventory.forEach((invItem, index) => {
                        if (index < 56) { // Assuming each tab has 56 slots
                            const slot = document.createElement('div');
                            slot.classList.add('inventory-slot');
                            slot.innerText = invItem.name;
                            grid.appendChild(slot);
                        }
                    });
                }
            }

            function loadInventory() {
                if (inventoryLoaded) {
                    toggleInventoryDisplay();
                    return;
                }

                fetch('inventory.html')
                    .then(response => response.text())
                    .then(html => {
                        const inventoryPlaceholder = document.getElementById('inventoryPlaceholder');
                        inventoryPlaceholder.innerHTML = html;
                        inventoryLoaded = true;
                        initializeInventory();
                        toggleInventoryDisplay();
                    })
                    .catch(error => console.error('Error loading inventory:', error));
            }

            function populateInventoryGrid(gridElement, items) {
                gridElement.innerHTML = '';
                for (let i = 0; i < 56; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    if (items[i]) {
                        slot.innerText = items[i].name;

                        // Add data attributes for tooltip
                        slot.setAttribute('data-name', items[i].name);
                        slot.setAttribute('data-description', items[i].description || 'No description available.');

                        // Event listeners for tooltip
                        slot.addEventListener('mouseenter', showTooltip);
                        slot.addEventListener('mousemove', moveTooltip);
                        slot.addEventListener('mouseleave', hideTooltip);
                    }
                    gridElement.appendChild(slot);
                }
            }

            // Event listeners for inventory tabs
            function setupInventoryTabs() {
                const tabs = document.querySelectorAll('.inventory-tab');
                const tabContents = document.querySelectorAll('.inventory-tab-content');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(tc => tc.classList.remove('active'));

                        tab.classList.add('active');
                        const activeTabContent = document.getElementById(tab.dataset.tab);
                        activeTabContent.classList.add('active');
                    });
                });

                tabs[0].classList.add('active');
                tabContents[0].classList.add('active');
            }

            function generatePlayerInventoryGrid() {
                const grid = document.getElementById('playerInventoryGrid');
                grid.innerHTML = '';
                const numColumns = 7;
                const numRows = Math.ceil(playerInventory.length / numColumns); // Adjust rows based on items
                grid.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    grid.appendChild(slot);
                }
            }

            function generateInventoryGrid(gridElement, numColumns, numRows) {
                gridElement.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                gridElement.innerHTML = '';
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    gridElement.appendChild(slot);
                }
            }

            function generateInventorySlots() {
                for (let i = 1; i <= 6; i++) {
                    const grid = document.getElementById('inventoryGridTab' + i);
                    grid.innerHTML = '';
                    for (let j = 0; j < 56; j++) {
                        const slot = document.createElement('div');
                        slot.classList.add('inventory-slot');
                        grid.appendChild(slot);
                    }
                }
            }

            function setupInventorySlotEventListeners(sourceGrid, sourceItems, targetItems, targetGrid) {
                const slots = sourceGrid.querySelectorAll('.inventory-slot');
                slots.forEach((slot, index) => {
                    slot.addEventListener('click', () => {
                        if (sourceItems[index]) {
                            // Find first empty slot in targetItems
                            let emptyIndex = targetItems.findIndex(item => item == null);
                            if (emptyIndex === -1) {
                                alert('No space in target inventory.');
                                return;
                            }
                            // Transfer item
                            targetItems[emptyIndex] = sourceItems[index];
                            sourceItems[index] = null;

                            // Update grids
                            populateInventoryGrid(sourceGrid, sourceItems);
                            populateInventoryGrid(targetGrid, targetItems);
                        }
                    });
                });
            }

            function addItemToInventory(item) {
                // Assuming item includes name and description
                playerInventory.push(item);
                updateInventoryDisplay();
            }

            function toggleInventoryDisplay() {
                const inventory = document.getElementById('inventory');
                if (inventory) {
                    inventory.style.display = inventory.style.display === 'none' ? 'block' : 'none';
                }
            }

            // Load inventory when 'I' key is pressed
            document.addEventListener('keydown', (event) => {
                if (event.key === 'I' || event.key === 'i') {
                    loadInventory();
                }
            });

            setupInventoryTabs();
            generateInventorySlots();
             
            function initEnemies() {
                // Spawn Red Enemies (Regular)
                for (let i = 0; i < 10; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let enemy = createEnemy(position.x, 0, position.z, 'red');
                    enemies.push(enemy);
                    scene.add(enemy);
                }

                // Spawn Blue Enemies
                for (let i = 0; i < 3; i++) { // Adjust the number as desired
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let blueEnemy = createEnemy(position.x, 0, position.z, 'blue');
                    enemies.push(blueEnemy);
                    scene.add(blueEnemy);
                }
            }

            function checkEnemiesInSafeZone() {
                const safeZoneRadius = 300; // Radius of the safe zone

                enemies.forEach((enemy) => {
                    if (enemy.userData.isDead) return;

                    const distanceFromCenter = Math.sqrt(
                        enemy.position.x * enemy.position.x + enemy.position.z * enemy.position.z
                    );

                    if (distanceFromCenter < safeZoneRadius) {
                        const angle = Math.random() * Math.PI * 2;
                        const teleportDistance = 500;
                        enemy.position.x = Math.cos(angle) * teleportDistance;
                        enemy.position.z = Math.sin(angle) * teleportDistance;
                        enemy.position.y = 0; 
                    }
                });
            }

            function getRandomPositionOutsideTown(minDistance, maxDistance) {
                let angle = Math.random() * 2 * Math.PI;
                let distance = minDistance + Math.random() * (maxDistance - minDistance);
                let x = Math.cos(angle) * distance;
                let z = Math.sin(angle) * distance;
                return { x: x, z: z };
            }

            function spawnEntities() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity <= 0) {
                    alert('Invalid quantity!');
                    return;
                }

                for (let i = 0; i < quantity; i++) {
                    const offsetX = Math.random() * 50 - 25;
                    const offsetZ = Math.random() * 50 - 25;
                    const spawnPosition = {
                        x: player.position.x + offsetX,
                        y: player.position.y,
                        z: player.position.z + offsetZ
                    };

                    if (entityType === 'enemy') {
                        const enemy = createEnemy(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        enemies.push(enemy);
                        scene.add(enemy);
                    } else if (entityType === 'friendlyNPC') {
                        const npc = createFriendlyNPC();
                        npc.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        friendlies.push(npc);
                        scene.add(npc);
                    } else if (entityType === 'structure') {
                        const structure = createStructure();
                        structure.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        scene.add(structure);
                        walls.push(...structure.userData.walls);
                    } else if (entityType === 'treasureChest') {
                        createTreasureChest(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Treasure Chest spawned.');
                    } else if (entityType === 'settlement') {
                        createSettlement(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Settlement spawned.');
                    } else if (entityType === 'quadruped') {
                        const quadruped = createQuadruped();
                        quadruped.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        quadrupeds.push(quadruped);
                        scene.add(quadruped);
                        alert('Quadruped spawned.');
                    }
                }
            }

            function createEnemy(x, y, z, type) {
                const enemyTypes = {
                    'blue': { color: 0x0000ff, damageRate: 4 },
                    'green': { color: 0x00ff00, damageRate: 3 },
                    'yellow': { color: 0xffff00, damageRate: 2.5 },
                    'purple': { color: 0x800080, damageRate: 3.5 },
                    'orange': { color: 0xffa500, damageRate: 2.8 },
                    'cyan': { color: 0x00ffff, damageRate: 3 },
                    'magenta': { color: 0xff00ff, damageRate: 3.2 },
                    'lime': { color: 0x32cd32, damageRate: 2.6 }
                };

                if (!enemyTypes[type]) {
                    const types = Object.keys(enemyTypes);
                    type = types[Math.floor(Math.random() * types.length)];
                }

                const { color, damageRate } = enemyTypes[type];

                const enemy = createHumanoid(color);
                enemy.position.set(x, 0, z);
                enemy.userData.type = 'hostile';
                enemy.userData.isDead = false; 
                enemy.userData.hasBeenLooted = false;
                enemy.userData.deathTime = 0;
                enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                enemy.isMoving = true; 
                enemy.userData.damageRate = damageRate;
                scene.add(enemy);
                return enemy;
            }

            function moveEnemies(delta) {
                enemies.forEach((enemy) => {
                    if (enemy.userData.isDead) return; 

                    const threatRange = 100; 
                    const attackRange = 10;  
                    const enemySpeed = globalEnemySpeed;

                    // Calculate direction and distance to the player
                    const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                    const distanceToPlayer = directionToPlayer.length();

                    // Define Safe Zone Parameters
                    const safeZoneCenter = new THREE.Vector3(0, 0, 0); // Adjust if your town center is different
                    const safeZoneRadius = townRadius; // 200 units

                    // Check if the enemy is within attack range
                    if (distanceToPlayer <= attackRange) {
                        enemy.isMoving = false;
                        enemyAttackPlayer(enemy, delta);
                    } 
                    // Enemy is within threat range and should move towards the player
                    else if (distanceToPlayer <= threatRange) {
                        directionToPlayer.normalize();
                        const oldPosition = enemy.position.clone();
                        const newPosition = enemy.position.clone().add(directionToPlayer.clone().multiplyScalar(enemySpeed));

                        // **Safe Zone Check Before Moving**
                        const distanceToSafeZone = newPosition.distanceTo(safeZoneCenter);
                        if (distanceToSafeZone < safeZoneRadius) {
                            // Calculate the direction away from the safe zone center
                            const directionAway = new THREE.Vector3().subVectors(newPosition, safeZoneCenter).normalize();
                            // Position the enemy just outside the safe zone boundary
                            const adjustedPosition = safeZoneCenter.clone().add(directionAway.multiplyScalar(safeZoneRadius - 1)); // Slight buffer
                            enemy.position.copy(adjustedPosition);
                            enemy.isMoving = false; // Stop moving further
                            return; // Skip collision checks for this iteration
                        }

                        // Move the enemy to the new position
                        enemy.position.copy(newPosition);

                        // Collision Detection with Walls
                        let collided = false;
                        for (let wall of walls) {
                            const enemyBox = new THREE.Box3().setFromObject(enemy);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (enemyBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        for (let wall of enemyWalls) {
                            const enemyBox = new THREE.Box3().setFromObject(enemy);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (enemyBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            enemy.position.copy(oldPosition);
                            enemy.isMoving = false;
                        } else {
                            enemy.isMoving = true;
                            // Rotate enemy to face the player
                            const angle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                            enemy.rotation.y = angle;
                        }
                    } 
                    // Enemy is outside threat range and should wander randomly
                    else {
                        const oldPosition = enemy.position.clone();
                        const moveVector = enemy.userData.direction.clone().multiplyScalar(0.5);
                        const newPosition = enemy.position.clone().add(moveVector);

                        // **Safe Zone Check Before Moving**
                        const distanceToSafeZone = newPosition.distanceTo(safeZoneCenter);
                        if (distanceToSafeZone < safeZoneRadius) {
                            // Calculate the direction away from the safe zone center
                            const directionAway = new THREE.Vector3().subVectors(newPosition, safeZoneCenter).normalize();
                            // Position the enemy just outside the safe zone boundary
                            const adjustedPosition = safeZoneCenter.clone().add(directionAway.multiplyScalar(safeZoneRadius - 1)); // Slight buffer
                            enemy.position.copy(adjustedPosition);
                            enemy.isMoving = false; // Stop moving further
                            return; // Skip collision checks for this iteration
                        }

                        // Move the enemy to the new position
                        enemy.position.copy(newPosition);

                        // Collision Detection with Walls
                        let collided = false;
                        for (let wall of walls) {
                            const enemyBox = new THREE.Box3().setFromObject(enemy);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (enemyBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            enemy.position.copy(oldPosition);
                            // Change direction randomly upon collision
                            enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                            enemy.isMoving = false;
                        } else {
                            enemy.isMoving = true;
                            // Rotate enemy to face the movement direction
                            const angle = Math.atan2(moveVector.x, moveVector.z);
                            enemy.rotation.y = angle;
                        }
                    }

                    // Animate the enemy's movements (arms, legs, etc.)
                    animateHumanoid(enemy, delta);
                });
            }


            function attackEnemy(enemy) {
                const attackRange = 20; 

                const distance = player.position.distanceTo(enemy.position);

                if (distance <= attackRange) {
                    playAttackAnimation();

                    setTimeout(() => {
                        defeatEnemy(enemy);
                    }, 500); 
                } else {
                    alert('Enemy is too far away!');
                }
            }

            function playAttackAnimation() {
                player.isAttacking = true;
                player.attackTime = 0;
            }

            function enemyAttackPlayer(enemy) {
                const damageAmount = Math.floor(Math.random() * 3) + 1; // Damage between 1 and 3
                damagePlayer(damageAmount);
            }

            function enemyAttackPlayer(enemy, delta) {
                if (enemy.userData.isDead || playerInvulnerable) return;

                // Calculate damage based on damageRate and delta time
                const damage = enemy.userData.damageRate * delta;
                const actualDamage = Math.max(0, damage - (characterStats.vitality / 10)); // Adjust based on vitality
                
                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            function animateDeadEnemies(delta) {
                scene.children.forEach((object) => {
                    if (object.userData && object.userData.isDead) {
                        object.userData.deathTime += delta;
                        if (object.userData.deathTime < 1) {
                            object.rotation.x = -Math.PI / 2 * (object.userData.deathTime / 1);
                        } else {
                            object.rotation.x = -Math.PI / 2;

                            if (!object.userData.bloodPoolCreated) {
                                createBloodPool(object.position);
                                object.userData.bloodPoolCreated = true;
                            }
                        }
                    }
                });
            }

            function maintainEnemyCount() {
                const activeEnemies = enemies.filter(enemy => !enemy.userData.isDead).length;
                const enemiesToSpawn = 100 - activeEnemies;

                for (let i = 0; i < enemiesToSpawn; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let type = Math.random() < 0.1 ? 'blue' : 'red'; // 10% chance to spawn a blue enemy
                    let enemy = createEnemy(position.x, 0, position.z, type);
                    enemies.push(enemy);
                    scene.add(enemy);
                }
            }

            function defeatEnemy(enemy) {
                addExperience(20);
                gold += 10;
                updateGoldDisplay();
                alert('Enemy defeated! You gained 20 experience and 10 gold.');

                enemy.isMoving = false;
                enemy.userData.isDead = true;
                enemy.userData.deathTime = 0;
            }

            function damagePlayer(amount) {
                if (playerInvulnerable) return; // Player is invulnerable
                const vitalityFactor = characterStats.vitality / 10; // Adjust as needed
                const actualDamage = Math.max(1, amount - vitalityFactor);
                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            function addExperience(amount) {
                characterStats.experience += amount;
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    levelUp();
                }
                updateStatsDisplay();
            }

            function createBloodPool(position) {
                const geometry = new THREE.CircleGeometry(5, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const bloodPool = new THREE.Mesh(geometry, material);
                bloodPool.rotation.x = -Math.PI / 2;
                bloodPool.position.set(position.x, 0.05, position.z);
                scene.add(bloodPool);
            }

            function maintainEnemyCount() {
                const activeEnemies = enemies.filter(enemy => !enemy.userData.isDead).length;
                const enemiesToSpawn = 50 - activeEnemies;

                for (let i = 0; i < enemiesToSpawn; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    let type = Math.random() < 0.1 ? 'blue' : 'red'; // 10% chance to spawn a blue enemy
                    let enemy = createEnemy(position.x, 0, position.z, type);
                    enemies.push(enemy);
                    scene.add(enemy);
                }
            }

            function lootEnemy(enemy) {
                if (enemy.userData.hasBeenLooted) {
                    alert('This enemy has already been looted.');
                    return;
                }

                isLooting = true;
                lootProgress = 0;
                currentLootingEnemy = enemy;
                document.getElementById('lootBarContainer').style.display = 'block';
            }

            function updateLooting(delta) {
                if (isLooting) {
                    lootProgress += delta;
                    const progressBar = document.getElementById('lootBar');
                    progressBar.style.width = (lootProgress / lootDuration) * 100 + '%';
                    if (lootProgress >= lootDuration) {
                        isLooting = false;
                        document.getElementById('lootBarContainer').style.display = 'none';
                        openLootPopup();
                    }
                }
            }

            function openLootPopup() {
                lootedItems = generateRandomItems(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            function lootAllItems() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change enemy color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    // Prevent further looting by disabling the enemy
                    // Optionally, you can remove the enemy from the scene or make it non-interactive
                    // For now, we just mark it as looted

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            // Tooltip Element
            const tooltip = document.getElementById('tooltip');

            // Initialize UI Components
            function initializeUI() {
                initializeInventoryUI();
                initializeStatsUI();
                initializeSkillTreeUI();
                initializeBestiaryUI();
                initializeQuestLogUI();
                initializeHelpWindowUI();
                initializeAdminConsoleUI();
                initializeHotbarUI();
                initializeLootPopupUI();
                initializeNpcPopupUI();
                initializeChestPopupUI();
                initializeEnergyOrbUI();
                initializeLifeOrbUI();
                initializeTeleportationBarUI();
            }

            // --------------------------------------- Inventory UI ---------------------------------------

            // Function to Show Tooltip
            function showTooltip(event) {
                const name = this.getAttribute('data-name');
                const description = this.getAttribute('data-description');
                tooltip.innerHTML = `<strong>${name}</strong><br>${description}`;
                tooltip.style.display = 'block';
            }

            // Function to Move Tooltip with Mouse
            function moveTooltip(event) {
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;
                const pageWidth = window.innerWidth;
                const pageHeight = window.innerHeight;

                let x = event.clientX + 10;
                let y = event.clientY + 10;

                // Prevent tooltip from going off-screen
                if (x + tooltipWidth > pageWidth) {
                    x = event.clientX - tooltipWidth - 10;
                }
                if (y + tooltipHeight > pageHeight) {
                    y = event.clientY - tooltipHeight - 10;
                }

                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            }

            // Function to Hide Tooltip
            function hideTooltip() {
                tooltip.style.display = 'none';
                tooltip.innerHTML = '';
            }

            // --------------------------------------- Stats UI ---------------------------------------

            function initializeStatsUI() {
                updateStatsDisplay();
            }

            function updateStatsDisplay() {
                document.getElementById('level').innerText = characterStats.level;
                document.getElementById('experience').innerText = characterStats.experience;
                document.getElementById('nextLevelExperience').innerText = characterStats.nextLevelExperience;
                document.getElementById('strength').innerText = characterStats.strength;
                document.getElementById('dexterity').innerText = characterStats.dexterity;
                document.getElementById('vitality').innerText = characterStats.vitality;
                document.getElementById('energy').innerText = characterStats.energy;
                document.getElementById('statPoints').innerText = characterStats.statPoints;
            }

            function increaseStat(stat) {
                if (characterStats.statPoints > 0) {
                    characterStats[stat]++;
                    characterStats.statPoints--;
                    updateStatsDisplay();
                } else {
                    alert('No available stat points!');
                }
            }

            // --------------------------------------- Skill Tree UI ---------------------------------------

            function initializeSkillTreeUI() {
                // Skill Tree is initialized when opened
            }

            function openSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'block';
                populateSkillTree();
            }

            function closeSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'none';
            }

            function populateSkillTree() {
                const skillsContainer = document.getElementById('skillsContainer');
                skillsContainer.innerHTML = ''; // Clear existing skills

                for (const key in skillTreeData) {
                    if (skillTreeData.hasOwnProperty(key)) {
                        const skill = skillTreeData[key];
                        const skillDiv = document.createElement('div');
                        skillDiv.classList.add('skill');
                        if (skill.learned) {
                            skillDiv.classList.add('learned');
                        }
                        skillDiv.innerHTML = `<strong>${skill.name}</strong><br>${skill.description}<br>Cost: ${skill.cost} XP`;
                        
                        // Add click event to learn the skill
                        skillDiv.addEventListener('click', () => {
                            if (!skill.learned && characterStats.experience >= skill.cost * 100) { // Assuming 100 XP per cost unit
                                characterStats.experience -= skill.cost * 100;
                                characterStats[Object.keys(skillTreeData)[Object.keys(skillTreeData).indexOf(key)]] += 5; // Increase the relevant stat
                                skill.learned = true;
                                updateStatsDisplay();
                                populateSkillTree(); // Refresh the skill tree
                                alert(`You have learned ${skill.name}!`);
                            } else if (skill.learned) {
                                alert('Skill already learned.');
                            } else {
                                alert('Not enough experience to learn this skill.');
                            }
                        });

                        // Add CSS classes based on skill availability
                        if (!skill.learned && characterStats.experience < skill.cost * 100) {
                            skillDiv.classList.add('unavailable');
                        }

                        skillsContainer.appendChild(skillDiv);
                    }
                }
            }

            // --------------------------------------- Bestiary UI ---------------------------------------

            function initializeBestiaryUI() {
                // Bestiary initialization if needed
            }

            function openBestiary() {
                const bestiaryModal = document.getElementById('bestiaryModal');
                bestiaryModal.style.display = 'block';
                renderBestiary();  // Ensure content is populated when opened
            }

            function closeBestiary() {
                const bestiaryDiv = document.getElementById('bestiary');
                bestiaryDiv.style.display = 'none';
            }

            function populateBestiary() {
                const bestiaryContent = document.getElementById('bestiaryContent');
                bestiaryContent.innerHTML = ''; // Clear existing content

                enemies.forEach(enemy => {
                    if (!enemy.userData.isDead) {
                        const enemyInfo = document.createElement('div');
                        enemyInfo.innerHTML = `<strong>Enemy:</strong> ${enemy.userData.type}<br>`;
                        bestiaryContent.appendChild(enemyInfo);
                    }
                });

                // Add more details as needed
            }

            // --------------------------------------- Quest Log UI ---------------------------------------


            function initializeQuestLogUI() {
                // Quest Log is initialized when opened
            }

            function openQuestLog() {
                questLogOpen = true;
                document.getElementById('questLog').style.display = 'block';
                populateQuestLog();
            }

            function closeQuestLog() {
                questLogOpen = false;
                document.getElementById('questLog').style.display = 'none';
            }

            function populateQuestLog() {
                const questList = document.getElementById('questList');
                questList.innerHTML = ''; // Clear existing quests

                quests.forEach(quest => {
                    const questItem = document.createElement('li');
                    questItem.innerText = `${quest.name}: ${quest.description}`;
                    questList.appendChild(questItem);
                });

                // Add more quest details as needed
            }

            // --------------------------------------- Help Window UI ---------------------------------------


            function initializeHelpWindowUI() {
                // Help Window is initialized when opened
            }

            function toggleHelpWindow() {
                helpWindowOpen = !helpWindowOpen;
                document.getElementById('helpWindow').style.display = helpWindowOpen ? 'block' : 'none';
            }

            // --------------------------------------- Admin Console UI ---------------------------------------


            function initializeAdminConsoleUI() {
                // Admin Console is initialized when opened
            }

            function openAdminConsoleUI() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'block';
                if (isAdminLoggedIn) {
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminControls').style.display = 'block';
                } else {
                    document.getElementById('adminLogin').style.display = 'block';
                    document.getElementById('adminControls').style.display = 'none';
                }
            }

            function closeAdminConsoleUI() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'none';
                isAdminLoggedIn = false;
                document.getElementById('adminControls').style.display = 'none';
                document.getElementById('adminLogin').style.display = 'block';
            }

            function checkAdminPasswordUI() {
                const passwordInput = document.getElementById('adminPassword').value;
                if (passwordInput === 'ltwelcome1') {
                    isAdminLoggedIn = true;
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminControls').style.display = 'block';
                    document.getElementById('adminPassword').value = ''; // Clear password field

                    // Attach the change event listener only once
                    if (!document.getElementById('npcAdminCheckbox').hasAttribute('data-listener')) {
                        document.getElementById('npcAdminCheckbox').addEventListener('change', function() {
                            npcAdminEnabled = this.checked;
                            alert('NPC Admin Mode ' + (npcAdminEnabled ? 'Enabled' : 'Disabled'));
                        });
                        document.getElementById('npcAdminCheckbox').setAttribute('data-listener', 'true');
                    }
                } else {
                    alert('Incorrect password!');
                }
            }

            function updatePlayerOptionsUI() {
                playerInvulnerable = document.getElementById('invulnerabilityCheckbox').checked;
                alert('Player options updated.');
            }

            function updatePlayerStatsUI() {
                const healthInput = parseInt(document.getElementById('playerHealthInput').value);
                const goldInput = parseInt(document.getElementById('playerGoldInput').value);
                const experienceInput = parseInt(document.getElementById('playerExperienceInput').value);

                if (!isNaN(healthInput)) {
                    playerHealth = Math.min(healthInput, playerMaxHealth);
                    updateHealthDisplay();
                }
                if (!isNaN(goldInput)) {
                    gold = goldInput;
                    updateGoldDisplay();
                }
                if (!isNaN(experienceInput)) {
                    characterStats.experience = experienceInput;
                    if (characterStats.experience >= characterStats.nextLevelExperience) {
                        levelUp();
                    }
                    updateStatsDisplay();
                }
                alert('Player stats updated.');
            }

            function spawnEntitiesUI() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity <= 0) {
                    alert('Invalid quantity!');
                    return;
                }

                for (let i = 0; i < quantity; i++) {
                    const offsetX = Math.random() * 50 - 25;
                    const offsetZ = Math.random() * 50 - 25;
                    const spawnPosition = {
                        x: player.position.x + offsetX,
                        y: player.position.y,
                        z: player.position.z + offsetZ
                    };

                    if (entityType === 'enemy') {
                        const enemy = createEnemy(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        enemies.push(enemy);
                        scene.add(enemy);
                        enemy.userData.homePosition = enemy.position.clone();
                        enemy.userData.wanderRadius = 500; // Adjust as needed
                    } else if (entityType === 'friendlyNPC') {
                        const npc = createFriendlyNPC();
                        npc.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        friendlies.push(npc);
                        scene.add(npc);
                    } else if (entityType === 'structure') {
                        const structure = createStructure();
                        structure.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        scene.add(structure);
                        walls.push(...structure.userData.walls);
                    } else if (entityType === 'treasureChest') {
                        createTreasureChest(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Treasure Chest spawned.');
                    } else if (entityType === 'settlement') {
                        createSettlement(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Settlement spawned.');
                    } else if (entityType === 'quadruped') {
                        const quadruped = createQuadruped();
                        quadruped.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        quadrupeds.push(quadruped);
                        scene.add(quadruped);
                        alert('Quadruped spawned.');
                    }
                }
            }

            function updateGameSettingsUI() {
                const enemySpeedInput = parseFloat(document.getElementById('enemySpeedInput').value);

                if (!isNaN(enemySpeedInput) && enemySpeedInput > 0) {
                    globalEnemySpeed = enemySpeedInput;
                    alert('Game settings updated.');
                } else {
                    alert('Invalid enemy speed!');
                }
            }

            function teleportPlayerUI() {
                const x = parseFloat(document.getElementById('teleportXInput').value);
                const z = parseFloat(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    player.position.set(x, player.position.y, z);
                    destination = null;
                    isTeleporting = false; // Reset teleporting state
                    document.getElementById('teleportationBarContainer').style.display = 'none'; // Hide progress bar
                    document.getElementById('teleportationBar').style.width = '0%'; // Reset progress bar
                    alert(`Player teleported to (${x}, ${z}).`);
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // --------------------------------------- Hotbar UI ---------------------------------------

            function initializeHotbarUI() {
                const slots = document.querySelectorAll('.slot');
                slots.forEach(slot => {
                    slot.addEventListener('click', () => {
                        const slotNumber = slot.getAttribute('data-slot');
                        handleHotbarSelection(slotNumber);
                    });
                });
            }

            function handleHotbarSelection(slotNumber) {
                const selectedSlot = document.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (selectedSlot) {
                    // Add a visual indicator for selection (e.g., a border)
                    document.querySelectorAll('.slot').forEach(slot => slot.style.borderColor = '#555'); // Reset all borders
                    selectedSlot.style.borderColor = '#FFD700'; // Highlight selected slot with gold color

                    // Implement the action you want when a slot is selected
                    // For example, equip the item in the slot or activate its ability
                    console.log(`Hotbar slot ${slotNumber} selected.`);
                    // Add your custom action here
                }
            }

            // --------------------------------------- Loot Popup UI ---------------------------------------

            function initializeLootPopupUI() {
                // Loot Popup is initialized when opened
            }

            function openLootPopupUI() {
                lootedItems = generateRandomItems(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            function lootAllItemsUI() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change enemy color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    // Prevent further looting by disabling the enemy
                    // For now, we just mark it as looted

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            // --------------------------------------- NPC Popup UI ---------------------------------------


            function initializeNpcPopupUI() {
                // NPC Popup is initialized when opened
            }

            function openNpcPopupUI(npc) {
                if (npcPopupOpen) {
                    closeNpcPopupUI();
                    return;
                }
                document.getElementById('npcPopup').querySelector('h2').innerText = npc.userData.name || 'Friendly NPC';
                document.getElementById('npcPopup').querySelector('p').innerText = npc.userData.dialogue || 'Hello, traveler! Stay awhile and listen...';
                document.getElementById('npcPopup').style.display = 'block';
                npcPopupOpen = true;
            }

            function closeNpcPopupUI() {
                document.getElementById('npcPopup').style.display = 'none';
                npcPopupOpen = false;
            }

            // --------------------------------------- Chest Popup UI ---------------------------------------


            function initializeChestPopupUI() {
                // Chest Popup is initialized when opened
            }

            function openChestPopupUI(chest) {
                currentOpenedChest = chest;
                const chestPopup = document.getElementById('chestPopup');
                chestPopup.style.display = 'block';

                const chestInventoryGrid = document.getElementById('chestInventoryGrid');
                const playerInventoryGrid = document.getElementById('playerInventoryInChestGrid');

                const chestColumns = 7;
                const chestRows = 4;
                const playerColumns = 7;
                const playerRows = 8;

                generateInventoryGrid(chestInventoryGrid, chestColumns, chestRows);
                generateInventoryGrid(playerInventoryGrid, playerColumns, playerRows);

                // Ensure items arrays have correct length for chests but not for playerInventory
                if (!chest.userData.items) chest.userData.items = [];
                chest.userData.items.length = chestColumns * chestRows;


                populateInventoryGridChest(chestInventoryGrid, chest.userData.items);
                populateInventoryGridChest(playerInventoryGrid, playerInventory);

                setupInventorySlotEventListeners(chestInventoryGrid, chest.userData.items, playerInventory, playerInventoryGrid);
                setupInventorySlotEventListeners(playerInventoryGrid, playerInventory, chest.userData.items, chestInventoryGrid);
            }

            function generateInventoryGrid(gridElement, numColumns, numRows) {
                gridElement.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                gridElement.innerHTML = '';
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    gridElement.appendChild(slot);
                }
            }

            function populateInventoryGridChest(gridElement, items) {
                gridElement.innerHTML = ''; // Clear existing items
                items.forEach((item, index) => {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    slot.innerText = item ? item.name : '';

                    if (item) {
                        slot.setAttribute('data-name', item.name);
                        slot.setAttribute('data-description', item.description || 'No description available.');

                        // Event listeners for tooltip
                        slot.addEventListener('mouseenter', showTooltip);
                        slot.addEventListener('mousemove', moveTooltip);
                        slot.addEventListener('mouseleave', hideTooltip);
                    }

                    gridElement.appendChild(slot);
                });
            }

            function setupInventorySlotEventListeners(sourceGrid, sourceItems, targetItems, targetGrid) {
                const slots = sourceGrid.querySelectorAll('.inventory-slot');
                slots.forEach((slot, index) => {
                    slot.addEventListener('click', () => {
                        if (sourceItems[index]) {
                            // Find first empty slot in targetItems
                            let emptyIndex = targetItems.findIndex(item => item == null);
                            if (emptyIndex === -1) {
                                alert('No space in target inventory.');
                                return;
                            }
                            // Transfer item
                            targetItems[emptyIndex] = sourceItems[index];
                            sourceItems[index] = null;

                            // Update grids
                            populateInventoryGrid(sourceGrid, sourceItems);
                            populateInventoryGrid(targetGrid, targetItems);
                        }
                    });
                });
            }

            function closeChestPopupUI() {
                document.getElementById('chestPopup').style.display = 'none';
                currentOpenedChest = null;

                // Update the main inventory display if it's open
                if (inventoryOpen) {
                    populateInventoryGrid(document.getElementById('inventoryGridTab1'), playerInventory);
                }
            }

            function takeAllChestItemsUI() {
                const chest = currentOpenedChest;
                chest.userData.items.forEach(item => {
                    addItemToInventory(item);
                });
                chest.userData.items = [];
                gold += chest.userData.gold;
                updateGoldDisplay();
                chest.userData.gold = 0;

                scene.remove(chest);

                closeChestPopupUI();
            }

            // --------------------------------------- Additional UI Initializations ---------------------------------------

            function initializeEnergyOrbUI() {
                updateEnergyDisplay();
            }

            function initializeLifeOrbUI() {
                updateHealthDisplay();
            }

            function initializeTeleportationBarUI() {
                // Teleportation Bar is handled in main.js
            }

            function initializeAllUI() {
                initializeUI();
                initializeHotbarUI();
                initializeLootPopupUI();
                initializeNpcPopupUI();
                initializeChestPopupUI();
            }

            // Initialize all UI components
            document.addEventListener('DOMContentLoaded', () => {
                initializeAllUI();
            });

            // spawnzone.js

            function createSpawnZone(scene, walls, enemyWalls, structures, friendlies, npcData) {
                // Create ground and safe zone
                const { ground, safeZoneGround, safeZoneBarrier } = createGroundAndSafeZone(scene, enemyWalls);

                // Create settlement walls
                createSettlementWalls(scene, walls, enemyWalls);

                // Create shrine and teleport pad
                const teleportPad = createShrine(scene);

                // Create structures and NPCs
                createStructuresAndNPCs(scene, walls, structures, friendlies, npcData);

                // Return references if needed
                return {
                    ground: ground,
                    safeZoneGround: safeZoneGround,
                    teleportPad: teleportPad
                };
            }

            function createGroundAndSafeZone(scene, enemyWalls) {
                const groundShape = new THREE.Shape();
                groundShape.moveTo(-5000, -5000);
                groundShape.lineTo(5000, -5000);
                groundShape.lineTo(5000, 5000);
                groundShape.lineTo(-5000, 5000);
                groundShape.lineTo(-5000, -5000);

                const safeZoneSize = 300;
                const holePath = new THREE.Path();
                holePath.moveTo(-safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, -safeZoneSize);
                groundShape.holes.push(holePath);

                const groundGeometry = new THREE.ShapeGeometry(groundShape);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.name = 'ground';
                scene.add(ground);

                const safeZoneGroundGeometry = new THREE.PlaneGeometry(600, 600);
                const safeZoneGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const safeZoneGround = new THREE.Mesh(safeZoneGroundGeometry, safeZoneGroundMaterial);
                safeZoneGround.rotation.x = -Math.PI / 2;
                safeZoneGround.position.y = 0.1;
                scene.add(safeZoneGround);

                const safeZoneBarrierGeometry = new THREE.BoxGeometry(600, 50, 600);
                const safeZoneBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const safeZoneBarrier = new THREE.Mesh(safeZoneBarrierGeometry, safeZoneBarrierMaterial);
                safeZoneBarrier.position.set(0, 25, 0);
                scene.add(safeZoneBarrier);
                enemyWalls.push(safeZoneBarrier);

                return { ground, safeZoneGround, safeZoneBarrier };
            }

            function createShrine(scene) {
                const shrineGroup = new THREE.Group();

                const floorGeometry = new THREE.CircleGeometry(20, 32);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1;
                shrineGroup.add(floor);

                const teleportPadGeometry = new THREE.CircleGeometry(5, 32);
                const teleportPadMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const teleportPad = new THREE.Mesh(teleportPadGeometry, teleportPadMaterial);
                teleportPad.rotation.x = -Math.PI / 2;
                teleportPad.position.y = 0.11;
                teleportPad.name = 'teleportPad';
                shrineGroup.add(teleportPad);

                shrineGroup.position.set(0, 0, 0);
                scene.add(shrineGroup);

                return teleportPad;
            }

            function createStructuresAndNPCs(scene, walls, structures, friendlies, npcData) {
                const structurePositions = [
                    { x: 150, z: 150 },
                    { x: -150, z: 150 },
                    { x: 150, z: -150 },
                    { x: -150, z: -150 },
                    { x: 0, z: 200 },
                ];

                structurePositions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, 0, pos.z);
                    scene.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    // Select a random NPC from npcData
                    const npcInfo = npcData[Math.floor(Math.random() * npcData.length)];

                    // Create the NPC with the selected data
                    const npc = createFriendlyNPC(0x00ff00, npcInfo.name, npcInfo.dialogue);

                    // Position the NPC at the structure's position
                    npc.position.copy(structure.position);

                    // Add the NPC to the scene and friendlies array
                    scene.add(npc);
                    friendlies.push(npc);
                });
            }

            function createSettlementWalls(scene, walls, enemyWalls) {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallHeight = 30;
                const wallThickness = 2;
                const wallLength = 600;

                const northWallLeftGeometry = new THREE.BoxGeometry(wallLength / 2 - 50, wallHeight, wallThickness);
                const northWallLeft = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, -300);
                scene.add(northWallLeft);
                walls.push(northWallLeft);

                const northWallRight = new THREE.Mesh(northWallLeftGeometry, wallMaterial);
                northWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, -300);
                scene.add(northWallRight);
                walls.push(northWallRight);

                const gateBarrierGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
                const gateBarrierMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const northGateBarrier = new THREE.Mesh(gateBarrierGeometry, gateBarrierMaterial);
                northGateBarrier.position.set(0, wallHeight / 2, -300);
                scene.add(northGateBarrier);
                enemyWalls.push(northGateBarrier);

                const southWallLeft = northWallLeft.clone();
                southWallLeft.position.set(-wallLength / 4 - 25, wallHeight / 2, 300);
                scene.add(southWallLeft);
                walls.push(southWallLeft);

                const southWallRight = northWallRight.clone();
                southWallRight.position.set(wallLength / 4 + 25, wallHeight / 2, 300);
                scene.add(southWallRight);
                walls.push(southWallRight);

                const southGateBarrier = northGateBarrier.clone();
                southGateBarrier.position.set(0, wallHeight / 2, 300);
                scene.add(southGateBarrier);
                enemyWalls.push(southGateBarrier);

                const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
                eastWall.position.set(300, wallHeight / 2, 0);
                scene.add(eastWall);
                walls.push(eastWall);

                const westWall = eastWall.clone();
                westWall.position.set(-300, wallHeight / 2, 0);
                scene.add(westWall);
                walls.push(westWall);

                // Add white walls at gate barriers
                const northGateWhiteWall = createWhiteWall();
                northGateWhiteWall.position.set(0, 15, -300); // Position at the gate
                scene.add(northGateWhiteWall);

                const southGateWhiteWall = createWhiteWall();
                southGateWhiteWall.position.set(0, 15, 300); // Position at the gate
                scene.add(southGateWhiteWall);

                // Add to walls array if enemies should collide
                walls.push(northGateWhiteWall);
                walls.push(southGateWhiteWall);
            }

            function createWhiteWall() {
                const wallGeometry = new THREE.BoxGeometry(10, 30, 2); // Adjust size as needed
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White color
                const whiteWall = new THREE.Mesh(wallGeometry, wallMaterial);
                whiteWall.userData.isWhiteWall = true; // Flag to identify white walls
                return whiteWall;
            }

            function createStructure() {
                const building = new THREE.Group();

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;
                const wallColor = 0x8B4513;

                const frontWallShape = new THREE.Shape();
                frontWallShape.moveTo(-wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, 0);

                const doorWidth = 10;
                const doorHeight = 20;
                const doorX = -doorWidth / 2;
                const doorY = 0;

                const doorHole = new THREE.Path();
                doorHole.moveTo(doorX, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY);
                frontWallShape.holes.push(doorHole);

                const frontWallGeometry = new THREE.ShapeGeometry(frontWallShape);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                const backWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.z = wallLength / 2;
                backWall.position.y = wallHeight / 2;
                building.add(backWall);

                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                rightWall.position.x = wallLength / 2;
                rightWall.position.y = wallHeight / 2;
                building.add(rightWall);

                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                return building;
            }

            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }

            function updateStatsDisplay() {
                document.getElementById('level').innerText = characterStats.level;
                document.getElementById('experience').innerText = characterStats.experience;
                document.getElementById('nextLevelExperience').innerText = characterStats.nextLevelExperience;
                document.getElementById('strength').innerText = characterStats.strength;
                document.getElementById('dexterity').innerText = characterStats.dexterity;
                document.getElementById('vitality').innerText = characterStats.vitality;
                document.getElementById('energy').innerText = characterStats.energy;
                document.getElementById('statPoints').innerText = characterStats.statPoints;
            }

            function updateGoldDisplay() {
                document.getElementById('goldAmount').innerText = gold;
            }

            function updateHealthDisplay() {
                document.getElementById('lifeValue').innerText = `${playerHealth}/${playerMaxHealth}`;
                let healthPercent = (playerHealth / playerMaxHealth) * 100;
                document.getElementById('lifeFill').style.height = `${healthPercent}%`;
            }

            function updateEnergyDisplay() {
                document.getElementById('energyValue').innerText = `${playerEnergy}/${playerMaxEnergy}`;
                let energyPercent = (playerEnergy / playerMaxEnergy) * 100;
                document.getElementById('energyOrb').style.clipPath = `inset(${100 - energyPercent}% 0 0 0)`;
            }

            function updateDisplay() {
                document.getElementById('level').textContent = characterStats.level;
                document.getElementById('experience').textContent = characterStats.experience;
                document.getElementById('nextLevelExperience').textContent = characterStats.nextLevelExperience;
                document.getElementById('strength').textContent = characterStats.strength;
                document.getElementById('dexterity').textContent = characterStats.dexterity;
                document.getElementById('vitality').textContent = characterStats.vitality;
                document.getElementById('energy').textContent = characterStats.energy;
                document.getElementById('mana').textContent = characterStats.mana;
                document.getElementById('karma').textContent = characterStats.karma;
                document.getElementById('reputation').textContent = characterStats.reputation;
                document.getElementById('statPoints').textContent = characterStats.statPoints;
                
                applyAppearanceUpdates(); // Update character appearance based on new stats
                renderCharacterSprite(); // Update the character sprite in the inventory
            }



            updateGoldDisplay();
            updateHealthDisplay();
            updateEnergyDisplay();
            updateStatsDisplay();
            updateDisplay();

            function initializeQuestLog() {
                // Initialize quests or other necessary setup
                quests = []; // Example initialization
                questLogOpen = false;
                // Optionally, preload some quests
            }

            // Add a quest to the quest log
            function addQuest(quest) {
                quests.push(quest);
                updateQuestLogDisplay();
            }

            // Update a quest's details
            function updateQuest(questId, updates) {
                const quest = quests.find(q => q.id === questId);
                if (quest) {
                    Object.assign(quest, updates);
                    updateQuestLogDisplay();
                }
            }

            // Mark a quest as completed
            function completeQuest(questId) {
                updateQuest(questId, { completed: true });
            }

            // Update the quest log display in the DOM
            function updateQuestLogDisplay() {
                const questList = document.getElementById('questList');
                if (!questList) {
                    console.error("Element with ID 'questList' not found.");
                    return;
                }

                questList.innerHTML = '';

                quests.forEach(quest => {
                    const questItem = document.createElement('li');
                    questItem.innerHTML = `
                        <strong>${quest.title}</strong> - ${quest.description}
                        ${quest.completed ? '<span style="color: green;">(Completed)</span>' : ''}
                    `;
                    questList.appendChild(questItem);
                });
            }

            // Open the quest log
            function openQuestLog() {
                questLogOpen = true;
                const questLog = document.getElementById('questLog');
                if (questLog) {
                    questLog.style.display = 'block';
                    updateQuestLogDisplay();
                } else {
                    console.error("Element with ID 'questLog' not found.");
                }
            }

            // Close the quest log
            function closeQuestLog() {
                questLogOpen = false;
                const questLog = document.getElementById('questLog');
                if (questLog) {
                    questLog.style.display = 'none';
                } else {
                    console.error("Element with ID 'questLog' not found.");
                }
            }

            // Initialize the quest log on script load
            initializeQuestLog();

            // tooltips.js

            // Create a tooltip element
            const entityTooltip = document.createElement('div');
            entityTooltip.id = 'entityTooltip';
            entityTooltip.style.position = 'absolute';
            entityTooltip.style.pointerEvents = 'none';
            entityTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            entityTooltip.style.color = '#fff';
            entityTooltip.style.padding = '5px 10px';
            entityTooltip.style.borderRadius = '5px';
            entityTooltip.style.fontSize = '14px';
            entityTooltip.style.display = 'none';
            entityTooltip.style.zIndex = '1000'; // Ensure tooltip is above other elements
            document.body.appendChild(entityTooltip);


            // Function to handle mouse move and show tooltip for entities
            function onMouseMove(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                // Separate checks for different entity types
                const enemyIntersects = raycaster.intersectObjects(enemies, true);
                const friendlyIntersects = raycaster.intersectObjects(friendlies, true);
                const quadrupedIntersects = raycaster.intersectObjects(quadrupeds, true);

                // Display tooltip based on the first intersected object
                if (enemyIntersects.length > 0) {
                    const enemy = enemyIntersects[0].object;
                    entityTooltip.innerHTML = `<strong>${enemy.userData.name || 'Enemy'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else if (friendlyIntersects.length > 0) {
                    const friendly = friendlyIntersects[0].object;
                    entityTooltip.innerHTML = `<strong>${friendly.userData.name || 'Friendly NPC'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else if (quadrupedIntersects.length > 0) {
                    const quadruped = quadrupedIntersects[0].object;
                    entityTooltip.innerHTML = `<strong>${quadruped.userData.name || 'Creature'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else {
                    entityTooltip.style.display = 'none';
                }
            }

            // Function to handle tooltips for inventory items
            function onInventoryItemHover(event) {
                const itemSlot = event.target; // The inventory slot being hovered over
                const itemName = itemSlot.getAttribute('data-name');
                const itemDescription = itemSlot.getAttribute('data-description');
                const itemStats = itemSlot.getAttribute('data-stats');
                const itemRarity = itemSlot.getAttribute('data-rarity');

                if (itemName) {
                    entityTooltip.innerHTML = `
                        <strong>${itemName}</strong><br>
                        <em>${itemRarity || 'Common'}</em><br>
                        ${itemDescription || 'No description available.'}<br>
                        ${itemStats || 'No stats available.'}
                    `;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else {
                    entityTooltip.style.display = 'none';
                }
            }

            // Add event listener for mouse move on inventory items
            function setupInventoryTooltips() {
                const inventorySlots = document.querySelectorAll('.inventory-slot');
                inventorySlots.forEach(slot => {
                    slot.addEventListener('mouseenter', onInventoryItemHover);
                    slot.addEventListener('mousemove', onInventoryItemHover);
                    slot.addEventListener('mouseleave', () => {
                        entityTooltip.style.display = 'none';
                    });
                });
            }

            // Add event listeners for mouse move in the game world
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseleave', () => {
                entityTooltip.style.display = 'none';
            }, false);
            
            function startTeleportation() {
                isTeleporting = true;
                teleportProgress = 0;
                document.getElementById('teleportationBarContainer').style.display = 'block';
            }

            function updateTeleportation(delta) {
                if (isTeleporting) {
                    teleportProgress += delta;
                    const progressBar = document.getElementById('teleportationBar');
                    progressBar.style.width = (teleportProgress / teleportationDuration) * 100 + '%';
                    if (teleportProgress >= teleportationDuration) {
                        isTeleporting = false;
                        document.getElementById('teleportationBarContainer').style.display = 'none';
                        progressBar.style.width = '0%';
                        teleportToSafeZone();
                    }
                }
            }

            function teleportToSafeZone() {
                previousPosition = player.position.clone(); // Save current position
                player.position.set(0, 0, 0); // Teleport to the center of the shrine
                destination = null; // Stop any movement
            }

            function teleportPlayer() {
                const x = parseFloat(document.getElementById('teleportXInput').value);
                const z = parseFloat(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    player.position.set(x, player.position.y, z);
                    destination = null;
                    isTeleporting = false; // Reset teleporting state
                    document.getElementById('teleportationBarContainer').style.display = 'none'; // Hide progress bar
                    document.getElementById('teleportationBar').style.width = '0%'; // Reset progress bar
                    alert(`Player teleported to (${x}, ${z}).`);
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // Function to Open Skill Tree
            function openSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'block';
                populateSkillTree();
            }

            // Function to Close Skill Tree
            function closeSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'none';
            }


            // Function to Populate Skill Tree UI
            function populateSkillTree() {
                const skillsContainer = document.getElementById('skillsContainer');
                skillsContainer.innerHTML = ''; // Clear existing skills

                for (const key in skillTreeData) {
                    if (skillTreeData.hasOwnProperty(key)) {
                        const skill = skillTreeData[key];
                        const skillDiv = document.createElement('div');
                        skillDiv.classList.add('skill');
                        if (skill.learned) {
                            skillDiv.classList.add('learned');
                        }
                        skillDiv.innerHTML = `<strong>${skill.name}</strong><br>${skill.description}<br>Cost: ${skill.cost} Stat Points`;
                        
                        // Add click event to learn the skill
                        skillDiv.addEventListener('click', () => {
                            if (!skill.learned && characterStats.statPoints >= skill.cost) {
                                // Learn the skill
                                characterStats.statPoints -= skill.cost;
                                skill.learned = true;
                                applySkillEffects(key);
                                updateDisplay();
                                populateSkillTree(); // Refresh the skill tree
                                alert(`You have learned ${skill.name}!`);
                            } else if (skill.learned) {
                                alert('Skill already learned.');
                            } else {
                                alert('Not enough stat points to learn this skill.');
                            }
                        });

                        // Add CSS classes based on skill availability
                        if (!skill.learned && characterStats.statPoints < skill.cost) {
                            skillDiv.classList.add('unavailable');
                        }

                        skillsContainer.appendChild(skillDiv);
                    }
                }
            }

            // Function to learn a skill
            function learnSkill(skillKey) {
                const skill = skillTreeData[skillKey];
                if (skill && !skill.learned && characterStats.statPoints >= skill.cost) {
                    skill.learned = true;
                    characterStats.statPoints -= skill.cost;
                    applySkillEffects(skillKey);
                    updateSkillTreeUI();
                    updateDisplay();
                } else {
                    alert('Cannot learn this skill.');
                }
            }

            // Function to apply skill effects
            function applySkillEffects(skillKey) {
                const skill = skillTreeData[skillKey];
                if (skill && skill.effects) {
                    Object.keys(skill.effects).forEach(stat => {
                        characterStats[stat] += skill.effects[stat];
                    });
                }
            }

            function generateRandomItems(count) {
                const items = [
                    // ----------------------
                    // Consumables
                    // ----------------------
                    {
                        name: 'Small Health Potion',
                        description: 'Restores 50 health points.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 25,
                        stats: { healthRestore: 50 }
                    },
                    {
                        name: 'Large Health Potion',
                        description: 'Restores 150 health points.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 75,
                        stats: { healthRestore: 150 }
                    },
                    {
                        name: 'Elixir of Vitality',
                        description: 'Restores 300 health points and increases maximum health temporarily.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 200,
                        stats: { healthRestore: 300, maxHealthIncrease: 50, duration: '5 minutes' }
                    },
                    {
                        name: 'Mana Potion',
                        description: 'Restores 30 mana points.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 20,
                        stats: { manaRestore: 30 }
                    },
                    {
                        name: 'Greater Mana Potion',
                        description: 'Restores 100 mana points.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { manaRestore: 100 }
                    },
                    {
                        name: 'Elixir of Wisdom',
                        description: 'Restores 200 mana points and increases intelligence temporarily.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 180,
                        stats: { manaRestore: 200, intelligenceIncrease: 20, duration: '5 minutes' }
                    },
                    {
                        name: 'Stamina Potion',
                        description: 'Replenishes stamina for enhanced physical performance.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 30,
                        stats: { staminaRestore: 40 }
                    },
                    {
                        name: 'Elixir of Strength',
                        description: 'Temporarily boosts your strength.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 90,
                        stats: { strengthIncrease: 15, duration: '10 minutes' }
                    },
                    {
                        name: 'Antidote',
                        description: 'Cures poison effects.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 20,
                        stats: { poisonCure: true }
                    },
                    {
                        name: 'Rejuvenation Elixir',
                        description: 'Gradually restores health and mana over time.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 220,
                        stats: { healthRestore: 50, manaRestore: 30, duration: '10 minutes' }
                    },
                    
                    // ----------------------
                    // Weapons
                    // ----------------------
                    {
                        name: 'Rusty Sword',
                        description: 'A worn-out sword with minimal damage.',
                        type: 'Weapon',
                        rarity: 'Common',
                        value: 15,
                        stats: { damage: 10, speed: 5 }
                    },
                    {
                        name: 'Iron Sword',
                        description: 'A sturdy iron sword dealing moderate damage.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 50,
                        stats: { damage: 25, speed: 7 }
                    },
                    {
                        name: 'Steel Sword',
                        description: 'A sharp steel sword with high damage.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 120,
                        stats: { damage: 40, speed: 8 }
                    },
                    {
                        name: 'Longbow',
                        description: 'A bow suitable for long-range attacks.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { damage: 20, range: 50 }
                    },
                    {
                        name: 'Crossbow',
                        description: 'A mechanical bow that fires bolts with precision.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 70,
                        stats: { damage: 22, range: 55 }
                    },
                    {
                        name: 'Dagger',
                        description: 'A small blade for quick strikes.',
                        type: 'Weapon',
                        rarity: 'Common',
                        value: 10,
                        stats: { damage: 8, speed: 10 }
                    },
                    {
                        name: 'Battle Axe',
                        description: 'A heavy axe capable of dealing significant damage.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 150,
                        stats: { damage: 45, speed: 6 }
                    },
                    {
                        name: 'War Hammer',
                        description: 'A mighty hammer designed to crush armor.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 160,
                        stats: { damage: 50, armorPenetration: 10 }
                    },
                    {
                        name: 'Short Sword',
                        description: 'A versatile sword suitable for both offense and defense.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { damage: 18, speed: 8 }
                    },
                    {
                        name: 'Magic Staff',
                        description: 'A staff imbued with magical properties for spellcasting.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 200,
                        stats: { damage: 30, intelligence: 15, magicDamage: 25 }
                    },
                    {
                        name: 'Spear',
                        description: 'A long-reaching weapon effective against multiple foes.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 55,
                        stats: { damage: 20, range: 40 }
                    },
                    {
                        name: 'Halberd',
                        description: 'A versatile polearm useful in both melee and ranged combat.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 140,
                        stats: { damage: 35, range: 30 }
                    },
                    {
                        name: 'Twin Daggers',
                        description: 'A pair of daggers allowing for dual-wielding attacks.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 65,
                        stats: { damage: 16, speed: 12 }
                    },
                    {
                        name: 'Greatsword',
                        description: 'A massive sword that delivers devastating blows.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 300,
                        stats: { damage: 60, speed: 4 }
                    },
                    {
                        name: 'Blunderbuss',
                        description: 'A short firearm effective at close range.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 80,
                        stats: { damage: 25, range: 35 }
                    },
                    {
                        name: 'Flaming Sword',
                        description: 'A sword engulfed in flames, adding fire damage to attacks.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 350,
                        stats: { damage: 50, fireDamage: 20 }
                    },
                    {
                        name: 'Frozen Bow',
                        description: 'A bow that shoots arrows imbued with ice, slowing targets.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 340,
                        stats: { damage: 28, iceDamage: 15, slowEffect: true }
                    },
                    {
                        name: 'Shadow Blade',
                        description: 'A blade forged from shadows, dealing dark damage.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 360,
                        stats: { damage: 55, darkDamage: 25 }
                    },
                    {
                        name: 'Lightning Staff',
                        description: 'A staff that channels lightning to strike enemies.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 380,
                        stats: { damage: 35, lightningDamage: 30 }
                    },
                    // ----------------------
                    // Armor
                    // ----------------------
                    {
                        name: 'Cloth Armor',
                        description: 'Offers minimal defense but allows easy movement.',
                        type: 'Armor',
                        rarity: 'Common',
                        value: 25,
                        stats: { defense: 10, agility: 5 }
                    },
                    {
                        name: 'Leather Armor',
                        description: 'Provides better protection while maintaining flexibility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 55,
                        stats: { defense: 25, agility: 10 }
                    },
                    {
                        name: 'Chainmail Armor',
                        description: 'A robust armor made of interlocking metal rings.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 120,
                        stats: { defense: 50, agility: -5 }
                    },
                    {
                        name: 'Plate Armor',
                        description: 'Heavy armor that offers excellent protection.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 80, agility: -15 }
                    },
                    {
                        name: 'Mage Robes',
                        description: 'Light robes that enhance magical abilities.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 130,
                        stats: { defense: 15, intelligence: 20 }
                    },
                    {
                        name: 'Hunter\'s Garb',
                        description: 'Lightweight armor designed for stealth and agility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 70,
                        stats: { defense: 20, agility: 15 }
                    },
                    {
                        name: 'Knight\'s Armor',
                        description: 'Standard issue armor for knights, balancing protection and mobility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 90,
                        stats: { defense: 40, agility: -5 }
                    },
                    {
                        name: 'Dragon Scale Armor',
                        description: 'Armor made from dragon scales, offering superior protection.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 300,
                        stats: { defense: 90, fireResistance: 25 }
                    },
                    {
                        name: 'Shadow Cloak',
                        description: 'A cloak that allows the wearer to blend into shadows.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 150,
                        stats: { defense: 25, stealth: 20 }
                    },
                    {
                        name: 'Guardian Plate',
                        description: 'Plate armor imbued with protective magic.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 320,
                        stats: { defense: 85, magicDefense: 30 }
                    },
                    // ----------------------
                    // Shields
                    // ----------------------
                    {
                        name: 'Old Shield',
                        description: 'Provides basic protection against attacks.',
                        type: 'Shield',
                        rarity: 'Common',
                        value: 20,
                        stats: { defense: 15 }
                    },
                    {
                        name: 'Iron Shield',
                        description: 'A sturdy iron shield offering good defense.',
                        type: 'Shield',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { defense: 25 }
                    },
                    {
                        name: 'Steel Shield',
                        description: 'A strong steel shield that can block powerful attacks.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 100,
                        stats: { defense: 45 }
                    },
                    {
                        name: 'Tower Shield',
                        description: 'A large shield providing excellent protection.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 220,
                        stats: { defense: 70, blockChance: 15 }
                    },
                    {
                        name: 'Buckler',
                        description: 'A small shield offering agility and quick defense.',
                        type: 'Shield',
                        rarity: 'Uncommon',
                        value: 35,
                        stats: { defense: 20, speed: 5 }
                    },
                    {
                        name: 'Magic Barrier Shield',
                        description: 'A shield that can generate magical barriers.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 60, magicDefense: 40, barrier: true }
                    },
                    {
                        name: 'Enchanted Shield',
                        description: 'A shield imbued with enchantments to enhance its protective capabilities.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 240,
                        stats: { defense: 65, magicDefense: 35 }
                    },
                    {
                        name: 'Reinforced Shield',
                        description: 'A shield reinforced with metal plates for extra durability.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 130,
                        stats: { defense: 50, durability: 100 }
                    },
                    {
                        name: 'Spiked Shield',
                        description: 'A shield equipped with spikes to inflict damage upon attackers.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 140,
                        stats: { defense: 40, damage: 10 }
                    },
                    {
                        name: 'Reflective Shield',
                        description: 'A shield that can reflect certain types of magic spells.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 260,
                        stats: { defense: 55, magicReflection: 20 }
                    },
                    
                    // ----------------------
                    // Boots
                    // ----------------------
                    {
                        name: 'Leather Boots',
                        description: 'Increases movement speed slightly.',
                        type: 'Boots',
                        rarity: 'Common',
                        value: 20,
                        stats: { speed: 5 }
                    },
                    {
                        name: 'Swift Boots',
                        description: 'Greatly increase movement speed.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { speed: 20 }
                    },
                    {
                        name: 'Heavy Boots',
                        description: 'Provide stability but reduce movement speed.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 50,
                        stats: { speed: -5, defense: 10 }
                    },
                    {
                        name: 'Boots of Silence',
                        description: 'Reduce the noise you make while moving, enhancing stealth.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 110,
                        stats: { stealth: 20 }
                    },
                    {
                        name: 'Firewalkers',
                        description: 'Allow the wearer to walk on hot surfaces without taking damage.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 130,
                        stats: { fireResistance: 25 }
                    },
                    {
                        name: 'Boots of the Eagle',
                        description: 'Enhance jumping ability and vision.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 200,
                        stats: { jumpHeight: 15, visionRange: 10 }
                    },
                    {
                        name: 'Shadowstep Boots',
                        description: 'Allow the wearer to move swiftly and leave behind shadows.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 220,
                        stats: { speed: 25, stealth: 25 }
                    },
                    {
                        name: 'Frostwalk Boots',
                        description: 'Enable the wearer to walk on ice without slipping.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 140,
                        stats: { iceResistance: 20 }
                    },
                    {
                        name: 'Boots of Fortitude',
                        description: 'Increase overall endurance and reduce fatigue.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 75,
                        stats: { endurance: 15 }
                    },
                    {
                        name: 'Traveler\'s Boots',
                        description: 'Provide comfort and reduce travel fatigue.',
                        type: 'Boots',
                        rarity: 'Common',
                        value: 30,
                        stats: { comfort: 10, fatigueReduction: 10 }
                    },
                    
                    // ----------------------
                    // Helmets
                    // ----------------------
                    {
                        name: 'Iron Helmet',
                        description: 'Protects the head from minor attacks.',
                        type: 'Helmet',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { defense: 20 }
                    },
                    {
                        name: 'Steel Helmet',
                        description: 'A strong helmet offering good protection.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 100,
                        stats: { defense: 35 }
                    },
                    {
                        name: 'Wizard Hat',
                        description: 'Enhances magical abilities.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 90,
                        stats: { intelligence: 15 }
                    },
                    {
                        name: 'Helmet of Insight',
                        description: 'Grants the wearer enhanced perception and awareness.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 210,
                        stats: { perception: 20, intelligence: 10 }
                    },
                    {
                        name: 'Beastmaster Helm',
                        description: 'Allows communication with and control over beasts.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 230,
                        stats: { animalControl: 25 }
                    },
                    {
                        name: 'Helmet of Fortification',
                        description: 'Provides additional defense against physical and magical attacks.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 40, magicDefense: 20 }
                    },
                    {
                        name: 'Shadow Hood',
                        description: 'Enhances stealth and dark vision.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 120,
                        stats: { stealth: 25, darkVision: 15 }
                    },
                    {
                        name: 'Helmet of the Ancients',
                        description: 'An ancient helmet that bestows wisdom and power.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 300,
                        stats: { wisdom: 30, power: 20 }
                    },
                    {
                        name: 'Nightmare Helm',
                        description: 'A helmet that instills fear into the hearts of enemies.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 280,
                        stats: { fearInduction: 20 }
                    },
                    {
                        name: 'Helm of the Phoenix',
                        description: 'Allows the wearer to resurrect upon death once.',
                        type: 'Helmet',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1 }
                    },
                    
                    // ----------------------
                    // Accessories
                    // ----------------------
                    {
                        name: 'Silver Ring',
                        description: 'A simple silver ring.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 30,
                        stats: {}
                    },
                    {
                        name: 'Gold Ring',
                        description: 'A shiny gold ring.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 80,
                        stats: {}
                    },
                    {
                        name: 'Ring of Strength',
                        description: 'Increases the wearer\'s strength.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 150,
                        stats: { strength: 10 }
                    },
                    {
                        name: 'Basic Amulet',
                        description: 'A simple amulet with no special properties.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 40,
                        stats: {}
                    },
                    {
                        name: 'Amulet of Protection',
                        description: 'Provides a shield against magical attacks.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 100,
                        stats: { magicDefense: 20 }
                    },
                    {
                        name: 'Amulet of the Mage',
                        description: 'Enhances the wearer\'s magical abilities.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 180,
                        stats: { intelligence: 20, manaRestore: 10 }
                    },
                    {
                        name: 'Charm Bracelet',
                        description: 'A bracelet adorned with various charms for luck.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 35,
                        stats: { luck: 5 }
                    },
                    {
                        name: 'Necklace of Fire',
                        description: 'Allows the wearer to unleash fire spells.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 200,
                        stats: { fireDamage: 25 }
                    },
                    {
                        name: 'Ring of Invisibility',
                        description: 'Grants temporary invisibility to the wearer.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 300,
                        stats: { invisibilityDuration: '30 seconds' }
                    },
                    {
                        name: 'Pendant of Healing',
                        description: 'Gradually restores health over time.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 120,
                        stats: { healthRegen: 5 }
                    },
                    // ----------------------
                    // Miscellaneous Items
                    // ----------------------
                    {
                        name: 'Torch',
                        description: 'Provides light in dark areas.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 5,
                        stats: { lightRadius: 10 }
                    },
                    {
                        name: 'Lockpick Set',
                        description: 'Used to unlock doors and chests.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 25,
                        stats: { lockpickingSkill: 15 }
                    },
                    {
                        name: 'Rope',
                        description: 'A sturdy rope useful for climbing and tying.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 10,
                        stats: { length: '30 meters' }
                    },
                    {
                        name: 'Map',
                        description: 'Shows the layout of the surrounding area.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 15,
                        stats: { areaCovered: 'Local region' }
                    },
                    {
                        name: 'Compass',
                        description: 'Helps in navigation by pointing north.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 20,
                        stats: { accuracy: 'High' }
                    },
                    {
                        name: 'Healing Herb',
                        description: 'A herb used to make health potions.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 5,
                        stats: { healthRestore: 10 }
                    },
                    {
                        name: 'Mana Crystal',
                        description: 'A crystal used to enhance magical items.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 150,
                        stats: { magicBoost: 20 }
                    },
                    {
                        name: 'Scroll of Fireball',
                        description: 'Casts a powerful fireball spell.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 200,
                        stats: { spell: 'Fireball', damage: 50 }
                    },
                    {
                        name: 'Gemstone',
                        description: 'A precious gemstone used in crafting.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { gemType: 'Ruby' }
                    },
                    {
                        name: 'Antique Key',
                        description: 'An old key that might unlock a hidden treasure.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 80,
                        stats: { unlocks: 'Unknown' }
                    },
                    // ----------------------
                    // More Items to Reach 70
                    // ----------------------
                    {
                        name: 'Bronze Shield',
                        description: 'A basic shield made of bronze.',
                        type: 'Shield',
                        rarity: 'Common',
                        value: 25,
                        stats: { defense: 18 }
                    },
                    {
                        name: 'Silver Sword',
                        description: 'A shiny sword effective against dark creatures.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 160,
                        stats: { damage: 35, darkDamageBonus: 15 }
                    },
                    {
                        name: 'Golden Armor',
                        description: 'Radiant armor that dazzles enemies.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 270,
                        stats: { defense: 55, magicDefense: 25, blindingEffect: true }
                    },
                    {
                        name: 'Mystic Ring',
                        description: 'A ring that enhances magical abilities.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 190,
                        stats: { intelligence: 25, manaRestore: 15 }
                    },
                    {
                        name: 'Thief\'s Cloak',
                        description: 'A cloak that enhances stealth and agility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 85,
                        stats: { stealth: 20, agility: 15 }
                    },
                    {
                        name: 'Berserker Helm',
                        description: 'A helmet that boosts attack power at the cost of defense.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 170,
                        stats: { attackPower: 20, defense: -10 }
                    },
                    {
                        name: 'Arcane Robe',
                        description: 'Robes that amplify magical spells.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 210,
                        stats: { intelligence: 30, magicDamage: 20 }
                    },
                    {
                        name: 'Hunter\'s Bow',
                        description: 'A bow crafted for precision and long-range attacks.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 180,
                        stats: { damage: 28, range: 65 }
                    },
                    {
                        name: 'Sorcerer\'s Staff',
                        description: 'A staff that channels potent magical energies.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 240,
                        stats: { damage: 40, intelligence: 25, magicDamage: 30 }
                    },
                    {
                        name: 'Guardian Pendant',
                        description: 'An amulet that provides a protective aura.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 160,
                        stats: { defense: 20, magicDefense: 15 }
                    },
                    {
                        name: 'Dragonbone Dagger',
                        description: 'A dagger made from dragon bones, inflicting severe damage.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 280,
                        stats: { damage: 45, fireDamage: 10 }
                    },
                    {
                        name: 'Enchanted Boots',
                        description: 'Boots that grant the ability to walk on air for short durations.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 250,
                        stats: { speed: 20, flightDuration: '10 seconds' }
                    },
                    {
                        name: 'Phoenix Feather',
                        description: 'A rare feather that can resurrect the bearer once.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1 }
                    },
                    {
                        name: 'Shadow Amulet',
                        description: 'An amulet that enhances dark magic.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 220,
                        stats: { darkDamage: 20, stealth: 15 }
                    },
                    {
                        name: 'Crystal Shield',
                        description: 'A shield made of crystal that absorbs magic.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 260,
                        stats: { defense: 50, magicAbsorption: 30 }
                    },
                    {
                        name: 'Titanium Armor',
                        description: 'Superior armor made from titanium, offering unmatched protection.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 400,
                        stats: { defense: 100, magicDefense: 50 }
                    },
                    {
                        name: 'Ethereal Blade',
                        description: 'A blade that exists partially in the ethereal plane, allowing it to bypass armor.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 450,
                        stats: { damage: 60, armorPenetration: 30 }
                    },
                    {
                        name: 'Ring of the Phoenix',
                        description: 'Grants the wearer the ability to revive once after death.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1, fireResistance: 50 }
                    },
                    {
                        name: 'Dragon Scale Boots',
                        description: 'Boots made from dragon scales, providing fire resistance and increased speed.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 240,
                        stats: { speed: 15, fireResistance: 25 }
                    },
                    {
                        name: 'Amulet of the Titans',
                        description: 'An amulet that significantly boosts strength and endurance.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 520,
                        stats: { strength: 30, endurance: 25 }
                    },
                    {
                        name: 'Ring of the Archmage',
                        description: 'Enhances all magical abilities and reduces mana consumption.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { intelligence: 35, manaEfficiency: 20 }
                    },
                    {
                        name: 'Celestial Robe',
                        description: 'Robes that grant celestial protection and amplify light magic.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 480,
                        stats: { defense: 60, magicDamage: 30, lightResistance: 25 }
                    },
                    {
                        name: 'Infinity Staff',
                        description: 'A staff that never degrades and continuously channels magical energy.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { damage: 70, magicDamage: 50, intelligence: 40 }
                    },
                    {
                        name: 'Shadow Cloak',
                        description: 'A cloak that grants complete invisibility when in darkness.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { stealth: 50, invisibility: true }
                    },
                    {
                        name: 'Guardians Shield',
                        description: 'A shield that summons guardians to protect the bearer.',
                        type: 'Shield',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { defense: 80, summonGuardians: true }
                    },
                    {
                        name: 'Eagle Eye Goggles',
                        description: 'Enhance vision, allowing the wearer to see great distances clearly.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 200,
                        stats: { visionRange: 50 }
                    },
                    {
                        name: 'Berserker Gauntlets',
                        description: 'Gauntlets that increase attack speed and damage at the cost of defense.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 170,
                        stats: { attackSpeed: 20, damage: 15, defense: -10 }
                    },
                    {
                        name: 'Titan Gauntlets',
                        description: 'Gauntlets that grant immense strength and durability.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 400,
                        stats: { strength: 40, defense: 30 }
                    },
                    {
                        name: 'Phoenix Wings',
                        description: 'Grant the ability to fly for short periods.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { flightDuration: '30 seconds' }
                    },
                    {
                        name: 'Arcane Crystal',
                        description: 'A crystal that amplifies magical spells.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 180,
                        stats: { magicBoost: 25 }
                    },
                    {
                        name: 'Vampire Dagger',
                        description: 'A dagger that steals health from enemies with each hit.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 280,
                        stats: { damage: 35, lifeSteal: 10 }
                    },
                    {
                        name: 'Holy Sword',
                        description: 'A sword blessed with holy magic, effective against undead.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { damage: 50, holyDamage: 30 }
                    },
                    {
                        name: 'Necromancer\'s Staff',
                        description: 'A staff that allows control over the dead.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 520,
                        stats: { damage: 40, necromancy: 25 }
                    },
                    {
                        name: 'Shadowstep Boots',
                        description: 'Allow the wearer to move swiftly and leave behind shadows.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 220,
                        stats: { speed: 25, stealth: 25 }
                    },
                    {
                        name: 'Ember Blade',
                        description: 'A sword that burns with eternal flames.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { damage: 55, fireDamage: 35 }
                    },
                    {
                        name: 'Guardian Angel Wings',
                        description: 'Grant the ability to fly and provide a protective aura.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { flightDuration: '60 seconds', defenseAura: 20 }
                    },
                    {
                        name: 'Astral Armor',
                        description: 'Armor forged from celestial materials, offering superior protection.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { defense: 95, magicDefense: 60, lightResistance: 40 }
                    },
                    {
                        name: 'Orb of Eternity',
                        description: 'A mystical orb that grants timelessness to its bearer.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { immortality: true }
                    },
                    {
                        name: 'Dragonfire Amulet',
                        description: 'An amulet that channels dragonfire into spells.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { fireDamage: 40, magicDamage: 20 }
                    },
                    {
                        name: 'Celestial Shield',
                        description: 'A shield that harnesses the power of the stars to protect the bearer.',
                        type: 'Shield',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { defense: 85, starPower: 30 }
                    },
                    {
                        name: 'Eclipse Blade',
                        description: 'A blade that balances light and darkness, adaptable to any combat situation.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 650,
                        stats: { damage: 65, lightDamage: 25, darkDamage: 25 }
                    },
                    {
                        name: 'Phoenix Feather Cloak',
                        description: 'A cloak made from phoenix feathers, granting the ability to resurrect once.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { resurrection: 1, fireResistance: 50 }
                    },
                    {
                        name: 'Starfall Staff',
                        description: 'A staff that calls down meteor showers upon enemies.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 680,
                        stats: { damage: 60, magicDamage: 40, areaEffect: true }
                    },
                    {
                        name: 'Dragonheart Pendant',
                        description: 'An amulet containing the heart of a dragon, bestowing immense power.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 750,
                        stats: { strength: 50, fireDamage: 40 }
                    },
                    {
                        name: 'Infinity Ring',
                        description: 'A ring that grants unlimited power to the wearer.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 800,
                        stats: { unlimitedPower: true }
                    },
                    {
                        name: 'Titanium Greatsword',
                        description: 'A colossal sword made from titanium, dealing unparalleled damage.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { damage: 80, armorPenetration: 40 }
                    },
                    {
                        name: 'Ethereal Cloak',
                        description: 'A cloak that allows the wearer to phase through solid objects.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 720,
                        stats: { phaseThrough: true, stealth: 30 }
                    },
                    {
                        name: 'Scepter of the Archmage',
                        description: 'A scepter that amplifies all forms of magic.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 750,
                        stats: { magicDamage: 50, intelligence: 35 }
                    },
                    {
                        name: 'Guardians Blade',
                        description: 'A blade that summons guardians to fight alongside the bearer.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 770,
                        stats: { damage: 55, summonGuardians: true }
                    },
                    {
                        name: 'Celestial Gauntlets',
                        description: 'Gauntlets that harness celestial energy to enhance strength and magic.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 730,
                        stats: { strength: 30, magicDamage: 25 }
                    },
                    {
                        name: 'Orb of Power',
                        description: 'A powerful orb that significantly boosts all attributes.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 800,
                        stats: { strength: 20, intelligence: 20, defense: 20, magicDamage: 20 }
                    }
                ];

                const randomItems = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * items.length);
                    // Clone the item to avoid reference issues
                    randomItems.push({ ...items[randomIndex] });
                }
                return randomItems;
            }


            function addItemsToInventory(items) {
                console.log('Items added to inventory:', items);
                playerInventory.push(...items);
            }

            function openChestPopup(chest) {
                currentOpenedChest = chest;
                const chestPopup = document.getElementById('chestPopup');
                chestPopup.style.display = 'block';

                const chestInventoryGrid = document.getElementById('chestInventoryGrid');
                const playerInventoryGrid = document.getElementById('playerInventoryInChestGrid');

                const chestColumns = 7;
                const chestRows = 4;
                const playerColumns = 7;
                const playerRows = 8;

                generateInventoryGrid(chestInventoryGrid, chestColumns, chestRows);
                generateInventoryGrid(playerInventoryGrid, playerColumns, playerRows);

                // Ensure items arrays have correct length for chests but not for playerInventory
                if (!chest.userData.items) chest.userData.items = [];
                chest.userData.items.length = chestColumns * chestRows;


                populateInventoryGridChest(chestInventoryGrid, chest.userData.items);
                populateInventoryGridChest(playerInventoryGrid, playerInventory);

                setupInventorySlotEventListeners(chestInventoryGrid, chest.userData.items, playerInventory, playerInventoryGrid);
                setupInventorySlotEventListeners(playerInventoryGrid, playerInventory, chest.userData.items, chestInventoryGrid);
            }

            function closeChestPopup() {
                document.getElementById('chestPopup').style.display = 'none';
                currentOpenedChest = null;

                // Update the main inventory display if it's open
                if (inventoryOpen) {
                    populateInventoryGrid(document.getElementById('inventoryGridTab1'), playerInventory);
                }
            }

            function takeAllChestItems() {
                const chest = currentOpenedChest;
                chest.userData.items.forEach(item => {
                    addItemToInventory(item);
                });
                chest.userData.items = [];
                gold += chest.userData.gold;
                updateGoldDisplay();
                chest.userData.gold = 0;

                scene.remove(chest);

                closeChestPopup();
            }

            // Function to create a quadruped
            function createQuadruped(color = 0x996633) {
                const group = new THREE.Group();

                // Body
                const bodyMaterial = new THREE.MeshLambertMaterial({ color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 5), bodyMaterial);
                body.position.y = 5;
                group.add(body);

                // Head
                const headMaterial = new THREE.MeshLambertMaterial({ color });
                const head = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), headMaterial);
                head.position.set(7, 7, 0);
                group.add(head);

                // Legs
                const legMaterial = new THREE.MeshLambertMaterial({ color });
                const legGeometry = new THREE.BoxGeometry(1, 5, 1);

                const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontLeftLeg.position.set(4, 2.5, 2);
                group.add(frontLeftLeg);

                const frontRightLeg = frontLeftLeg.clone();
                frontRightLeg.position.z = -2;
                group.add(frontRightLeg);

                const backLeftLeg = frontLeftLeg.clone();
                backLeftLeg.position.x = -4;
                group.add(backLeftLeg);

                const backRightLeg = frontRightLeg.clone();
                backRightLeg.position.x = -4;
                group.add(backRightLeg);

                // Tail
                const tailMaterial = new THREE.MeshLambertMaterial({ color });
                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 5), tailMaterial);
                tail.position.set(-7, 6, 0);
                tail.rotation.y = Math.PI / 4;
                group.add(tail);

                // Animation properties
                group.isMoving = false;
                group.animationTime = 0;
                group.animationSpeed = 5.0;

                // Store legs for animation
                group.legs = [frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg];

                // Direction for movement
                group.userData.direction = new THREE.Vector3();

                // Assign user data
                group.userData.type = 'nonHostile';
                group.userData.name = 'Quadruped';

                return group;
            }

            // Function to add quadrupeds to the scene
            function addQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    const quadruped = createQuadruped();
                    quadruped.position.set(position.x, 0, position.z);
                    quadrupeds.push(quadruped);
                    scene.add(quadruped);
                    quadruped.userData.homePosition = quadruped.position.clone();
                    quadruped.userData.wanderRadius = 500; // Adjust as needed
                }
            }

            // Function to animate quadrupeds
            function animateQuadruped(quadruped, delta) {
                if (quadruped.isMoving) {
                    quadruped.animationTime += delta * quadruped.animationSpeed;
                    const angle = Math.sin(quadruped.animationTime) * (Math.PI / 6);

                    // Front Left & Back Right Legs
                    quadruped.legs[0].rotation.x = angle;
                    quadruped.legs[3].rotation.x = angle;

                    // Front Right & Back Left Legs
                    quadruped.legs[1].rotation.x = -angle;
                    quadruped.legs[2].rotation.x = -angle;
                } else {
                    // Reset leg rotations
                    quadruped.legs.forEach(leg => leg.rotation.x = 0);
                }
            }

            // Function to move quadrupeds
            function moveQuadrupeds(delta) {
                quadrupeds.forEach((quadruped) => {
                    if (quadruped.userData.isDead) return; // Optional: Handle dead quadrupeds

                    // Simple wandering logic
                    if (!quadruped.isMoving) {
                        // Decide to move or stay
                        if (Math.random() < 0.01) { // 1% chance to start moving each frame
                            quadruped.isMoving = true;
                            // Random direction
                            const angle = Math.random() * 2 * Math.PI;
                            quadruped.userData.direction.set(Math.cos(angle), 0, Math.sin(angle));
                            // Rotate to face direction
                            quadruped.rotation.y = angle;
                        }
                    } else {
                        // Move in the set direction
                        const moveDistance = globalEnemySpeed * delta * 10; // Adjust speed as needed
                        quadruped.position.add(quadruped.userData.direction.clone().multiplyScalar(moveDistance));

                        // Clamp quadruped's position within -5000 to 5000 on both axes
                        quadruped.position.x = Math.max(-5000, Math.min(5000, quadruped.position.x));
                        quadruped.position.z = Math.max(-5000, Math.min(5000, quadruped.position.z));

                        // Check for collisions with walls
                        let collided = false;
                        for (let wall of walls) {
                            const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (quadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        for (let wall of enemyWalls) {
                            const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (quadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            quadruped.position.sub(quadruped.userData.direction.clone().multiplyScalar(moveDistance));
                            quadruped.isMoving = false;
                        } else {
                            quadruped.isMoving = true;
                        }

                        // Stop moving after a certain distance or time
                        if (Math.random() < 0.005) { // 0.5% chance to stop moving each frame
                            quadruped.isMoving = false;
                        }
                    }

                    // Animate quadruped
                    animateQuadruped(quadruped, delta);
                });
            }

            // hostilequadrupeds.js

            // Array to hold hostile quadrupeds
            let hostileQuadrupeds = [];

            // Function to create a hostile quadruped
            function createHostileQuadruped(x, y, z) {
                const color = 0xFFA500; // Orange color

                const hostileQuadruped = createQuadruped(color);

                hostileQuadruped.position.set(x, y, z);

                hostileQuadruped.userData.type = 'hostileQuadruped';
                hostileQuadruped.userData.isDead = false;
                hostileQuadruped.userData.hasBeenLooted = false;
                hostileQuadruped.userData.deathTime = 0;
                hostileQuadruped.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                hostileQuadruped.isMoving = true;
                hostileQuadruped.userData.damageRate = 3; // Adjust damage rate as needed
                hostileQuadruped.userData.homePosition = hostileQuadruped.position.clone();
                hostileQuadruped.userData.wanderRadius = 500; // Adjust as needed

                scene.add(hostileQuadruped);
                hostileQuadrupeds.push(hostileQuadruped);

                return hostileQuadruped;
            }

            // Function to move hostile quadrupeds
            function moveHostileQuadrupeds(delta) {
                hostileQuadrupeds.forEach((hostileQuadruped) => {
                    if (hostileQuadruped.userData.isDead) return;

                    const threatRange = 100;
                    const attackRange = 10;
                    const enemySpeed = globalEnemySpeed;

                    const directionToPlayer = new THREE.Vector3().subVectors(player.position, hostileQuadruped.position);
                    const distanceToPlayer = directionToPlayer.length();

                    if (distanceToPlayer <= attackRange) {
                        hostileQuadruped.isMoving = false;
                        attackPlayerByHostileQuadruped(hostileQuadruped, delta);
                    } else if (distanceToPlayer <= threatRange) {
                        directionToPlayer.normalize();
                        const oldPosition = hostileQuadruped.position.clone();
                        hostileQuadruped.position.add(directionToPlayer.multiplyScalar(enemySpeed));

                        let collided = false;
                        for (let wall of walls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        for (let wall of enemyWalls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            hostileQuadruped.position.copy(oldPosition);
                            hostileQuadruped.isMoving = false;
                        } else {
                            hostileQuadruped.isMoving = true;
                            // Rotate hostile quadruped to face player
                            const angle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                            hostileQuadruped.rotation.y = angle;
                        }
                    } else {
                        // Wandering behavior
                        const oldPosition = hostileQuadruped.position.clone();
                        const moveVector = hostileQuadruped.userData.direction.clone().multiplyScalar(0.5);
                        hostileQuadruped.position.add(moveVector);

                        // Clamp position within bounds
                        hostileQuadruped.position.x = Math.max(-5000, Math.min(5000, hostileQuadruped.position.x));
                        hostileQuadruped.position.z = Math.max(-5000, Math.min(5000, hostileQuadruped.position.z));

                        let collided = false;
                        for (let wall of walls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            hostileQuadruped.position.copy(oldPosition);
                            hostileQuadruped.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                            hostileQuadruped.isMoving = false;
                        } else {
                            hostileQuadruped.isMoving = true;
                            // Rotate hostile quadruped to face movement direction
                            const angle = Math.atan2(moveVector.x, moveVector.z);
                            hostileQuadruped.rotation.y = angle;
                        }
                    }

                    // Animate hostile quadruped
                    animateQuadruped(hostileQuadruped, delta);
                });
            }

            // Function for hostile quadrupeds to attack player
            function attackPlayerByHostileQuadruped(hostileQuadruped, delta) {
                if (hostileQuadruped.userData.isDead || playerInvulnerable) return;

                // Calculate damage based on damageRate and delta time
                const damage = hostileQuadruped.userData.damageRate * delta;
                const actualDamage = Math.max(0, damage - (characterStats.vitality / 10));

                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            // Function to handle defeating a hostile quadruped
            function defeatHostileQuadruped(hostileQuadruped) {
                addExperience(30); // Adjust experience as needed
                gold += 15; // Adjust gold as needed
                updateGoldDisplay();
                alert('Hostile quadruped defeated! You gained 30 experience and 15 gold.');

                hostileQuadruped.isMoving = false;
                hostileQuadruped.userData.isDead = true;
                hostileQuadruped.userData.deathTime = 0;
            }

            // Function to loot a hostile quadruped
            function lootHostileQuadruped(hostileQuadruped) {
                if (hostileQuadruped.userData.hasBeenLooted) {
                    alert('This creature has already been looted.');
                    return;
                }

                isLooting = true;
                lootProgress = 0;
                currentLootingEnemy = hostileQuadruped;
                document.getElementById('lootBarContainer').style.display = 'block';
            }

            // Generate random items from the hostile_mob_loot table
            function generateHostileMobLoot(count) {
                const items = [
                    { name: 'Beast Claw', description: 'A sharp claw from a ferocious beast.' },
                    { name: 'Tough Hide', description: 'A piece of thick hide, useful for crafting.' },
                    { name: 'Wild Fang', description: 'A fang that exudes a dangerous aura.' },
                    { name: 'Savage Horn', description: 'A horn that could be valuable to collectors.' },
                    { name: 'Enchanted Fur', description: 'Fur that seems to have magical properties.' },
                    // Add more items as needed
                ];
                const randomItems = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * items.length);
                    // Clone the item to avoid reference issues
                    randomItems.push({ ...items[randomIndex] });
                }
                return randomItems;
            }

            // Modify openLootPopup to handle hostile quadruped loot
            function openLootPopupHostileQuadruped() {
                lootedItems = generateHostileMobLoot(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            // Modify lootAllItems to handle hostile quadrupeds
            function lootAllItemsHostileQuadruped() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change quadruped color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            // Function to spawn hostile quadrupeds
            function addHostileQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(500, 1500);
                    createHostileQuadruped(position.x, 0, position.z);
                }
            }


            // Function to attack a hostile quadruped
            function attackHostileQuadruped(hostileQuadruped) {
                const attackRange = 20;

                const distance = player.position.distanceTo(hostileQuadruped.position);

                if (distance <= attackRange) {
                    playAttackAnimation();

                    setTimeout(() => {
                        defeatHostileQuadruped(hostileQuadruped);
                    }, 500);
                } else {
                    alert('Creature is too far away!');
                }
            }

            const npc = createHumanoid(color);
        </script>
        <!-- <script src="characterCreation.js"></script> --> 
        <!-- <script src="characterSprite.js"></script> --> 
        
        


        
    


    </body>
</html>