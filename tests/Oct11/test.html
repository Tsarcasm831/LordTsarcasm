<html>
    <head>
        <title>Remnants of Destruction v0.3.6</title>
        <style>
            /* ======================= */
            /*       Reset Styles      */
            /* ======================= */
            *,
            *::before,
            *::after {
                box-sizing: border-box;
            }

            body, html { 
                margin: 0; 
                padding: 0; 
                overflow: hidden; 
                height: 100%; /* Ensure body takes full height */
                font-family: Arial, sans-serif; /* Consistent font */
                background-color: #121212; /* Dark background for better contrast */
                color: #e0e0e0; /* Light text for readability */
            }

            /* ======================= */
            /*       General Styles    */
            /* ======================= */

            /* Hide scrollbars for the entire application */
            body, html {
                overflow: hidden;
            }
            /* ======================= */
            /*        Modal Styles     */
            /* ======================= */

            /* Modal Overlay */
            .modal {
                display: none; /* Hidden by default */
                position: fixed; /* Stay in place */
                z-index: 1000; /* Sit on top */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                overflow: auto; /* Enable scroll if needed */
                background-color: rgba(0, 0, 0, 0.5); /* Black w/ opacity */
                display: flex; /* Use flexbox for centering */
                align-items: center; /* Center vertically */
                justify-content: center; /* Center horizontally */
                transition: opacity 0.3s ease;
            }

            /* Show Modal */
            .modal.show {
                opacity: 1;
            }

            /* Hide Modal */
            .modal.hide {
                opacity: 0;
            }

            /* Modal Content */
            .modal-content {
                background-color: #1A1A1A;
                color: #e0e0e0;
                padding: 20px 30px;
                border-radius: 10px;
                width: 90%;
                max-width: 800px;
                max-height: 90vh;
                overflow-y: auto;
                position: relative;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
                animation: fadeIn 0.3s forwards;
            }

            /* Close Button */
            .close-button {
                position: absolute;
                top: 15px;
                right: 20px;
                background-color: #ff4c4c;
                border: none;
                color: white;
                font-size: 24px;
                padding: 5px 10px;
                border-radius: 50%;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            .close-button:hover,
            .close-button:focus {
                background-color: #ff0000;
                outline: none;
            }

            /* Animations */
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }

            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-20px); }
            }

            /* ======================= */
            /*      Game Canvas        */
            /* ======================= */
            #gameCanvas { 
                display: block; 
                width: 100%;
                height: 100%;
                background-color: #000; /* Background color for the game canvas */
            }

            /* ======================= */
            /*      Inventory & Stats  */
            /* ======================= */
            #inventory, #stats {
                position: absolute;
                background: rgba(0, 0, 0, 0.8);
                color: #fff;
                display: none;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 10;
                overflow-y: auto; /* Allow scrolling if content overflows vertically */
                border-radius: 10px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            }

            /* Inventory Styling */
            #inventory { 
                top: 50%; 
                left: 50%; 
                transform: translate(-50%, -50%); 
                width: 90%;
                max-width: 900px;
                height: 80vh;
            }

            /* Stats Styling */
            #stats {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 400px;
                height: auto;
            }

            #stats button {
                margin-right: 10px;
                margin-bottom: 10px;
                padding: 8px 12px;
                background-color: #FFD700;
                color: #2c2c2c;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            #stats button:hover {
                background-color: #e6c200;
            }

            /* Hotbar Styling */
            #hotbar {
                position: absolute;
                bottom: 10px; /* Adjusted position */
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                z-index: 5;
                background: rgba(0, 0, 0, 0.6);
                padding: 5px;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            }

            /* Trait Selection Modal Styles */
            #traitSelectionModal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0,0,0,0.8);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }

            #traitSelectionModal .modal-content {
                background-color: #fefefe;
                padding: 20px;
                border-radius: 5px;
                width: 50%;
                max-width: 600px;
                max-height: 80%;
                overflow-y: auto;
            }

            .trait-option {
                margin-bottom: 10px;
            }

            .trait-option input {
                margin-right: 10px;
            }




            /* Inventory Tabs */
            #inventoryTabs {
                display: flex;
                gap: 5px;
                margin-top: 10px;
                flex-wrap: wrap;
            }

            .inventory-tab {
                padding: 5px 10px;
                background-color: #333;
                color: #fff;
                border: none;
                cursor: pointer;
                border-radius: 5px;
                transition: background-color 0.3s;
                flex: 1 1 auto;
                text-align: center;
            }

            .inventory-tab.active {
                background-color: #555;
            }

            .inventory-tab-content {
                display: none;
            }

            .inventory-tab-content.active {
                display: block;
            }

            .inventoryGrid {
                display: grid;
                grid-template-columns: repeat(7, 50px);
                grid-auto-rows: 50px;
                gap: 2px;
                margin-top: 10px;
                overflow-y: auto;
                max-height: 500px;
            }

            /* Dark Mode Toggle Button */
            .dark-mode-toggle {
                position: fixed;
                top: 240px; /* Adjusted to move below the map */
                right: 20px;
                padding: 10px;
                background-color: var(--primary-color);
                color: #2c2c2c;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1100; /* Increased z-index to be above the map */
                transition: background-color 0.3s, transform 0.2s;
            }

            .dark-mode-toggle:hover {
                background-color: #e6c200;
                transform: scale(1.05);
            }


            #notificationContainer {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: var(--z-index-tooltip);
            }

            .notification {
                background-color: rgba(0, 0, 0, 0.8);
                color: var(--text-color);
                padding: 10px 20px;
                margin-bottom: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                opacity: 0;
                transform: translateX(100%);
                animation: slideIn 0.5s forwards, fadeOut 0.5s 3.5s forwards;
            }

            .notification.success {
                background-color: rgba(40, 167, 69, 0.9); /* Green */
                color: #fff;
            }

            .notification.error {
                background-color: rgba(220, 53, 69, 0.9); /* Red */
                color: #fff;
            }

            .notification.warning {
                background-color: rgba(255, 193, 7, 0.9); /* Yellow */
                color: #2c2c2c;
            }

            .notification.info {
                background-color: rgba(23, 162, 184, 0.9); /* Blue */
                color: #fff;
            }


            @keyframes slideIn {
                to { 
                    opacity: 1; 
                    transform: translateX(0); 
                }
            }

            @keyframes fadeOut {
                to { 
                    opacity: 0; 
                    transform: translateX(100%); 
                }
            }


            /* NPC Popup */
            #npcPopup {
                position: absolute;
                width: 400px;
                height: auto;
                background: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 10;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                border-radius: 10px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            }

            /* Life Orb */
            #lifeOrb {
                position: absolute;
                bottom: 100px;
                left: 20px;
                width: 100px;
                height: 100px;
                background: radial-gradient(circle at center, #8B0000, #FF0000);
                border: 2px solid #fff;
                border-radius: 50%;
                overflow: hidden;
                z-index: 5;
                box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            }

            #lifeFill {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 100%; /* Dynamically adjusted via JavaScript */
                background: linear-gradient(to top, #FF4500, #8B0000);
                transition: height 0.3s ease-in-out;
            }

            #lifeValue {
                position: absolute;
                top: 50%;
                width: 100%;
                text-align: center;
                color: #fff;
                font-weight: bold;
                font-size: 16px;
                transform: translateY(-50%);
                z-index: 1;
                text-shadow: 1px 1px 2px #000;
            }

            /* Energy Orb */
            #energyOrb {
                position: absolute;
                bottom: 100px;
                right: 20px;
                width: 100px;
                height: 100px;
                background: radial-gradient(circle at center, #00008B, #0000FF);
                border: 2px solid #fff;
                border-radius: 50%;
                overflow: hidden;
                z-index: 5;
                box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            }

            #energyValue {
                position: absolute;
                top: 50%;
                width: 100%;
                text-align: center;
                color: #fff;
                font-weight: bold;
                font-size: 16px;
                transform: translateY(-50%);
                z-index: 1;
                text-shadow: 1px 1px 2px #000;
            }

            /* Teleportation Bar */
            #teleportationBarContainer {
                position: absolute;
                bottom: 50%;
                left: 50%;
                width: 200px;
                height: 20px;
                border: 2px solid #fff;
                transform: translate(-50%, 50%);
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 10;
                display: none;
                border-radius: 10px;
                overflow: hidden;
            }

            #teleportationBar {
                width: 0%;
                height: 100%;
                background-color: #00ff00;
                transition: width 0.3s ease;
            }


            /* Loot Popup */
            #lootPopup {
                position: absolute;
                width: 400px;
                height: auto;
                background: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 10;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: none;
                border-radius: 10px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            }


            /* ======================= */
            /*      Admin Console      */
            /* ======================= */

            /* Admin Console Modal Styles */
            #adminConsole {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.75);
                display: none; /* Hidden by default */
                align-items: center;
                justify-content: center;
                z-index: 1000; /* Ensure it's above other elements */
            }

            #adminConsole .modal-content {
                background-color: #2c2c2c;
                color: #e0e0e0;
                padding: 30px;
                border-radius: 10px;
                width: 80%;
                max-width: 800px;
                max-height: 90%;
                overflow-y: auto;
                position: relative;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
            }

            /* Close Button for Admin Console */
            #adminConsole .close-button {
                position: absolute;
                top: 10px;
                right: 25px;
                color: #aaa;
                font-size: 28px;
                font-weight: bold;
                background: none;
                border: none;
                cursor: pointer;
            }

            #adminConsole .close-button:hover,
            #adminConsole .close-button:focus {
                color: black;
                text-decoration: none;
                cursor: pointer;
            }

            /* Tab Navigation Styles */
            .admin-tabs {
                display: flex;
                justify-content: center;
                margin-bottom: 20px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .tab-button {
                background-color: #444;
                color: #e0e0e0;
                border: none;
                padding: 10px 20px;
                cursor: pointer;
                border-radius: 5px;
                transition: background-color 0.3s;
                min-width: 120px;
                text-align: center;
            }

            .tab-button:hover {
                background-color: #555;
            }

            .tab-button.active {
                background-color: #FFD700;
                color: #2c2c2c;
            }

            /* Tab Content Styles */
            .admin-tab-content {
                display: none; /* Hidden by default */
                opacity: 0;
                transition: opacity 0.3s ease-in-out;
            }

            .admin-tab-content.active {
                display: block;
                opacity: 1;
            }

            .admin-tab-content h3 {
                margin-top: 0;
                color: #FFD700;
            }

            .admin-tab-content section {
                margin-bottom: 20px;
            }

            .admin-tab-content h4 {
                margin-bottom: 10px;
                color: #FFD700;
            }

            /* Form Elements Styles */
            .admin-tab-content input[type="number"],
            .admin-tab-content input[type="password"],
            .admin-tab-content select,
            .admin-tab-content textarea {
                width: 100%;
                padding: 8px;
                margin-bottom: 15px;
                border: 1px solid #555;
                border-radius: 4px;
                background-color: #3a3a3a;
                color: #fff;
                box-sizing: border-box;
            }

            .admin-tab-content input[type="number"]:focus,
            .admin-tab-content input[type="password"]:focus,
            .admin-tab-content select:focus,
            .admin-tab-content textarea:focus {
                border-color: #FFD700;
                box-shadow: 0 0 5px #FFD700;
                outline: none;
            }

            /* Buttons Styles */
            .admin-tab-content button {
                background-color: #FFD700;
                color: #2c2c2c;
                border: none;
                padding: 10px 20px;
                cursor: pointer;
                border-radius: 5px;
                transition: background-color 0.3s;
                font-size: 16px;
            }

            .admin-tab-content button:hover {
                background-color: #e6c200;
            }

            /* Checkbox Labels */
            .checkbox-label {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }

            .checkbox-label input {
                margin-right: 10px;
            }

            /* ======================= */
            /*      Loading Overlay    */
            /* ======================= */
            .loading-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000; /* Above admin console */
            }

            .loading-spinner {
                border: 8px solid #f3f3f3;
                border-top: 8px solid #FFD700;
                border-radius: 50%;
                width: 60px;
                height: 60px;
                animation: spin 1s linear infinite;
            }

            /* Spinner Animation */
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            /* ======================= */
            /*          Tooltip        */
            /* ======================= */
            .tooltip {
                position: absolute;
                background-color: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 5px 10px;
                border-radius: 5px;
                pointer-events: none;
                font-size: 12px;
                z-index: 1000; /* Ensure it's above other popups like skillTree */
                display: none;
                max-width: 200px;
            }

            .tooltip-header {
                font-weight: bold;
                margin-bottom: 5px;
            }

            .tooltip-rarity {
                font-style: italic;
                color: #FFD700;
                margin-bottom: 5px;
            }

            .tooltip-description {
                margin-bottom: 5px;
            }

            .tooltip-stats {
                color: #00FF00;
                white-space: pre-line;
            }

            /* Rarity Colors */
            .common { color: #FFFFFF; }
            .uncommon { color: #00FF00; }
            .rare { color: #0070DD; }
            .epic { color: #A335EE; }
            .legendary { color: #FF8000; }

            /* ======================= */
            /*      Additional Styles   */
            /* ======================= */

            .admin-tab-content p {
                margin: 10px 0;
            }

            .admin-tab-content label {
                font-weight: bold;
            }

            /* ======================= */
            /*      Loot Bar Container */
            /* ======================= */
            #lootBarContainer {
                position: absolute;
                bottom: 50%;
                left: 50%;
                width: 200px;
                height: 20px;
                border: 2px solid #fff;
                transform: translate(-50%, 50%);
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 10;
                display: none;
                border-radius: 10px;
                overflow: hidden;
            }

            #lootBar {
                width: 0%;
                height: 100%;
                background-color: #ffff00;
                transition: width 0.3s ease;
            }

            /* ======================= */
            /*        Trade Window     */
            /* ======================= */

            #tradeWindow {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.9);
                color: #e0e0e0;
                padding: 20px;
                border: 2px solid #aaa;
                border-radius: 10px;
                z-index: 1000; /* High z-index to ensure it appears on top */
                width: 90%;
                max-width: 800px;
                height: auto;
                max-height: 80vh;
                display: none;
                overflow-y: auto;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            }

            #tradeWindow h2 {
                margin-top: 0;
                color: #FFD700; /* Gold color for emphasis */
                text-align: center;
            }

            .inventoryGrid {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 5px;
                min-height: 300px; /* Ensures grid height remains even when empty */
            }

            .inventory-slot {
                border: 1px solid #555;
                background: rgba(255, 255, 255, 0.1);
                text-align: center;
                padding: 8px;
                border-radius: 4px;
            }

            .inventory-slot:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }

            #confirmTradeButton {
                background-color: #28a745;
                color: #fff;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s;
                margin-right: 10px;
            }

            #confirmTradeButton:hover {
                background-color: #218838;
            }

            #tradeWindow button {
                padding: 8px 16px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }

            #tradeWindow button:hover {
                background-color: #555;
            }

            /* ======================= */
            /*         Help Window     */
            /* ======================= */

            #helpWindow {
                position: fixed;
                top: 5%; /* Closer to the top to allow more content visibility */
                left: 50%;
                transform: translateX(-50%);
                display: none; /* Hidden by default */
                z-index: 1000; /* Ensure it's above other elements */
                background-color: rgba(0, 0, 0, 0.85); /* Slightly more opaque */
                width: 90%; /* Cover a larger portion of the screen width */
                max-width: 900px; /* Set a strict maximum width */
                height: auto; /* Automatically adjust height based on content */
                max-height: 85vh; /* Limit height, but make it taller */
                padding: 25px; /* More padding for content readability */
                border-radius: 12px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
                overflow-y: hidden; /* Removes the vertical scrollbar */
                transition: opacity 0.3s ease, transform 0.3s ease; /* Smooth transition */
            }

            /* Display the help window when needed */
            #helpWindow.show {
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 1;
                transform: translateX(-50%) translateY(0); /* Center alignment */
            }

            /* Animations for smooth appearance and fade-out */
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-10px); }
                to { opacity: 1; transform: translateY(0); }
            }

            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-10px); }
            }

            /* Close Button Styling */
            #helpWindow .close-button {
                position: absolute;
                top: 15px;
                right: 20px;
                background-color: #ff4c4c;
                border: none;
                color: white;
                font-size: 24px;
                padding: 5px 10px;
                border-radius: 50%;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            #helpWindow .close-button:hover,
            #helpWindow .close-button:focus {
                background-color: #ff0000;
                outline: none;
            }


            /* Content Layout */
            .content {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                margin-top: 40px; /* Space below the title */
            }

            .left-column,
            .right-column {
                flex: 1 1 300px; /* Grow and shrink with a base width */
                min-width: 250px; /* Prevent columns from becoming too narrow */
            }

            /* Headings */
            #helpWindow h2,
            #helpWindow h3 {
                color: #ffd700; /* Gold color for headers */
                margin-top: 0;
            }

            #helpWindow h2 {
                text-align: center;
                margin-bottom: 20px;
            }

            .left-column h3,
            .right-column h3 {
                margin-bottom: 10px;
            }

            /* Lists */
            .updates,
            .keybindings,
            .features {
                list-style-type: disc;
                padding-left: 20px;
                margin-bottom: 15px;
            }

            .updates li,
            .keybindings li,
            .features li {
                margin-bottom: 8px;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                .content {
                    flex-direction: column;
                }

                .left-column,
                .right-column {
                    flex: 1 1 100%;
                }
            }




            /* Accessibility Focus Styles */
            .close-button:focus {
                box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.5);
            }

            /* Prevent body from scrolling when modal is open */
            body.modal-open {
                overflow: hidden;
            }

            /* Focus Styles for Better Visibility */
            button:focus,
            a:focus,
            input:focus,
            select:focus,
            textarea:focus {
                outline: 2px solid #FFD700;
                outline-offset: 2px;
            }

            /* Open Help Button Styling */
            .open-help-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 10px 20px;
                background-color: #0073e6;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1100; /* Above other elements */
                transition: background-color 0.3s, transform 0.2s;
                font-size: 16px;
            }

            .open-help-button:hover,
            .open-help-button:focus {
                background-color: #005bb5;
                transform: scale(1.05);
                outline: none;
            }


            /* ======================= */
            /*        Skill Tree       */
            /* ======================= */

            /* Skill Tree Styles */
            #skillTree {
                position: absolute;
                width: 600px;
                height: 600px;
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 100;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: none;
                overflow-y: auto;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
            }

            #skillTree h2 {
                text-align: center;
                color: #FFD700;
                margin-top: 0;
            }

            #skillsContainer {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-top: 20px;
            }

            .skill {
                background: rgba(255, 255, 255, 0.1);
                padding: 10px;
                border: 1px solid #555;
                border-radius: 5px;
                cursor: pointer;
                transition: background 0.3s, transform 0.2s;
            }

            .skill:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(1.02);
            }

            .skill.unavailable {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .skill.learned {
                background: rgba(0, 255, 0, 0.5);
                cursor: default;
            }

            .slot {
                width: 64px;
                height: 64px;
                border: 2px solid #555;
                margin: 2px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
                transition: background 0.2s;
            }

            .slot:hover {
                background: rgba(255, 255, 255, 0.2);
            }


            /* ======================= */
            /*      NPC Admin Popup    */
            /* ======================= */

            /* NPC Admin Popup Styles */
            #npcAdminPopup {
                position: absolute;
                width: 400px;
                height: auto;
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 100;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                overflow-y: auto;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            }

            #npcAdminPopup input,
            #npcAdminPopup textarea {
                width: 100%;
                margin-bottom: 10px;
                background-color: #333;
                color: #fff;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 4px;
            }

            #npcAdminPopup button {
                margin-right: 10px;
                padding: 8px 12px;
                background-color: #FFD700;
                color: #2c2c2c;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            #npcAdminPopup button:hover {
                background-color: #e6c200;
            }



            /* ======================= */
            /*      Inventory Slot     */
            /* ======================= */
            .inventory-slot {
                position: relative;
                cursor: pointer;
                transition: background-color 0.2s;
            }

            .inventory-slot:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }

            /* ======================= */
            /*          Bestiary       */
            /* ======================= */

            /* Bestiary Modal Styles */
            #bestiaryModal {
                display: none; /* Default is hidden */
                position: fixed;
                z-index: 1000; /* Ensure it is above other elements */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                overflow: auto; /* Enable scroll if needed */
                background-color: rgba(0, 0, 0, 0.8); /* Black w/ opacity */
                align-items: center;
                justify-content: center;
            }

            #bestiaryModal.show {
                display: flex; /* Use flex to center content */
            }

            #bestiaryModal .modal-content {
                background-color: #1A1A1A;
                color: #e0e0e0;
                margin: 5% auto; /* 5% from the top and centered */
                padding: 30px;
                border: 2px solid #FFD700;
                width: 90%; /* Could be more or less, depending on screen size */
                max-width: 1200px;
                max-height: 90vh; /* Ensure it doesn't exceed viewport height */
                overflow-y: auto; /* Scroll vertically if content is too long */
                border-radius: 10px;
                position: relative;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9); /* Enhanced shadow for better depth */
            }

            /* Flexible Bestiary Content Grid */
            .bestiary-content {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                padding: 20px;
            }


            /* Creature Card Styles */
            .creature-card {
                border: 2px solid #555;
                border-radius: 10px;
                padding: 15px;
                background-color: #292929;
                transition: background 0.3s, box-shadow 0.3s;
                display: flex;
                flex-direction: column;
                align-items: center;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            }

            .creature-card:hover {
                background-color: #3a3a3a;
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); /* Enhanced hover effect */
            }

            /* Creature Image Styles */
            .creature-image {
                width: 100%;
                height: auto;
                max-height: 200px; /* Optional: Limit the max height */
                object-fit: cover;
                border-radius: 10px;
                margin-bottom: 15px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            }

            .creature-info {
                text-align: center;
            }

            .creature-info h3 {
                margin: 0 0 10px 0;
                color: #FFD700;
                font-size: 1.5em;
            }

            .creature-info p {
                margin: 0 0 15px 0;
                color: #e0e0e0;
                font-size: 1em;
            }

            .view-details-button {
                padding: 10px 15px;
                background-color: #8B0000;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s, transform 0.2s;
                font-size: 1em;
            }

            .view-details-button:hover {
                background-color: #FF6347;
                transform: scale(1.05);
            }

            /* Creature Details Modal Styles */
            #creatureDetailsModal {
                display: none; /* Hidden by default */
                position: fixed;
                z-index: 1500; /* Higher than bestiary modal */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                background-color: rgba(0, 0, 0, 0.9); /* Darker semi-transparent background */
                transition: opacity 0.3s ease;
                align-items: center;
                justify-content: center;
            }

            #creatureDetailsModal.show {
                display: flex;
                opacity: 1;
            }

            #creatureDetailsModal .modal-content {
                background-color: #1A1A1A;
                color: #e0e0e0;
                margin: 5% auto; /* 5% from the top and centered */
                padding: 30px;
                border: 2px solid #FFD700;
                width: 90%; /* Could be more or less, depending on screen size */
                max-width: 1000px;
                max-height: 90vh; /* Ensure it doesn't exceed viewport height */
                overflow-y: auto; /* Scroll vertically if content is too long */
                border-radius: 10px;
                position: relative;
                box-shadow: 0 0 30px rgba(0, 0, 0, 0.9); /* Enhanced shadow for better depth */
            }

            .creature-detail-header {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                align-items: flex-start;
                margin-bottom: 20px;
            }

            .creature-detail-image {
                flex: 1 1 300px;
                max-width: 100%;
                height: auto;
                border-radius: 8px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
                transition: transform 0.3s ease-in-out;
            }

            .creature-detail-image:hover {
                transform: scale(1.02);
            }

            .stats-container {
                flex: 1 1 300px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .stat-item {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }

            .stat-item span {
                flex: 0 0 60px;
                font-weight: bold;
                color: #FFD700;
                font-size: 1.1em;
                margin-right: 10px;
            }

            .stat-bar {
                flex: 1;
                background: #555;
                height: 20px;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: inset 0 0 5px #000;
            }

            .progress {
                background: linear-gradient(90deg, #FFD700 0%, #FF8C00 100%);
                height: 100%;
                width: 0;
                transition: width 1s ease-in-out;
            }

            /* 3D Model Container */
            .model-container {
                width: 100%;
                height: 400px;
                margin-top: 20px;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
                background-color: #000; /* Background color for the 3D model */
            }

            /* ======================= */
            /*         Music Page      */
            /* ======================= */

            /* Open Music Button */
            .open-music-button {
                position: fixed; /* Fixed to stay in viewport */
                bottom: 20px;
                right: 20px;
                padding: 10px 20px;
                background-color: #0073e6;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1100; /* Above other elements */
                transition: background-color 0.3s, transform 0.2s;
            }

            .open-music-button:hover {
                background-color: #005bb5;
                transform: scale(1.05);
            }

            /* Music Modal Styles */
            #musicModal {
                display: none; /* Hidden by default */
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1200; /* Above other modals */
            }

            #musicModal.show {
                display: flex;
            }

            #musicModal .modal-content {
                background-color: #1A1A1A;
                padding: 20px;
                border-radius: 10px;
                width: 80%;
                max-width: 800px;
                max-height: 90vh; /* Limits height to prevent overflow */
                overflow: hidden; /* Ensures no additional scroll within the modal itself */
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
                border: 2px solid #FFD700;
            }

            /* Music Modal Close Button */
            #musicModal .close-button {
                position: absolute;
                top: 15px;
                right: 15px;
                background-color: #FF0000; /* Bright red background */
                border: none;
                color: #FFFFFF; /* White text */
                font-size: 28px; /* Larger font size for visibility */
                padding: 10px;
                border-radius: 50%; /* Circular button */
                cursor: pointer;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.7); /* Shadow for added prominence */
                transition: background-color 0.3s, transform 0.2s; /* Smooth transition */
            }

            #musicModal .close-button:hover {
                background-color: #CC0000; /* Darker red on hover */
                transform: scale(1.1); /* Slight enlargement on hover */
            }


            /* Music Controls */
            .music-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .music-player {
                width: 100%;
                max-width: 600px;
            }

            .music-player audio {
                width: 100%;
                outline: none;
            }

            /* Playlist Styling */
            .playlist {
                margin-top: 20px;
                width: 100%;
            }

            .playlist-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                background-color: #333;
                border-radius: 5px;
                margin-bottom: 10px;
                cursor: pointer;
                transition: background-color 0.3s, transform 0.2s;
            }

            .playlist-item:hover {
                background-color: #555;
                transform: scale(1.02);
            }

            .playlist-item.active {
                background-color: #FFD700;
                color: #2c2c2c;
            }

            .playlist-item .track-name {
                flex: 1;
            }

            .playlist-item .remove-track {
                background: none;
                border: none;
                color: #fff;
                cursor: pointer;
                font-size: 16px;
                margin-left: 10px;
            }

            .playlist-item .remove-track:hover {
                color: #ff4c4c;
            }

            /* Add Track Button */
            .add-track-button {
                padding: 10px 20px;
                background-color: #28a745;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s, transform 0.2s;
                font-size: 16px;
            }

            .add-track-button:hover {
                background-color: #218838;
                transform: scale(1.05);
            }

            /* Now Playing Control Bar */
            .now-playing {
                position: fixed;
                bottom: 20px;
                right: 160px; /* Positioned just left of the Open Music button */
                background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent background */
                color: #FFD700; /* Gold color for visibility */
                padding: 10px 15px;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 16px;
                z-index: 1200;
            }

            #playPauseButton {
                background: none;
                border: none;
                color: #FFFFFF;
                font-size: 20px;
                cursor: pointer;
                transition: transform 0.2s;
            }

            #playPauseButton:hover {
                transform: scale(1.2); /* Slight enlargement on hover */
            }


            /* ======================= */
            /*        Responsive       */
            /* ======================= */

            /* Responsive Design Enhancements */

            /* Bestiary Modal Responsive Adjustments */
            @media (max-width: 1200px) {
                #bestiaryModal .modal-content {
                    padding: 20px;
                }

                .creature-card {
                    max-width: 100%;
                }

                .creature-image {
                    max-height: 180px;
                }

                .creature-info h3 {
                    font-size: 1.3em;
                }

                .view-details-button {
                    font-size: 0.9em;
                    padding: 8px 12px;
                }
            }

            /* Bestiary Modal on Smaller Screens */
            @media (max-width: 768px) {
                #bestiaryModal .modal-content {
                    width: 95%;
                    padding: 15px;
                }

                .bestiary-content {
                    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                    gap: 15px;
                    padding: 15px;
                }

                .creature-card {
                    padding: 10px;
                }

                .creature-image {
                    max-height: 150px;
                }

                .creature-info h3 {
                    font-size: 1.2em;
                }

                .view-details-button {
                    font-size: 0.85em;
                    padding: 7px 10px;
                }

                /* Adjust Creature Details Modal */
                #creatureDetailsModal .modal-content {
                    padding: 20px;
                }

                .creature-detail-header {
                    flex-direction: column;
                    align-items: center;
                }

                .creature-detail-image,
                .stats-container {
                    flex: 1 1 100%;
                }

                .model-container {
                    height: 300px;
                }
            }

            /* Music Modal Responsive Adjustments */
            @media (max-width: 1200px) {
                #musicModal .modal-content {
                    padding: 15px;
                }
            }

            @media (max-width: 768px) {
                #musicModal .modal-content {
                    width: 95%;
                    padding: 10px;
                }

                .open-music-button {
                    padding: 8px 16px;
                    bottom: 15px;
                    right: 15px;
                }

                /* Music Player Adjustments */
                .music-controls {
                    gap: 15px;
                }

                .playlist-item {
                    flex-direction: column;
                    align-items: flex-start;
                }

                .playlist-item .remove-track {
                    margin-left: 0;
                    margin-top: 5px;
                }

                .add-track-button {
                    width: 100%;
                }
            }

            /* ======================= */
            /*        Additional       */
            /* ======================= */


            #musicModal .modal-content,
            #creatureDetailsModal .modal-content {
                transition: all 0.3s ease;
            }

            /* Ensure Images are Responsive */
            img {
                max-width: 100%;
                height: auto;
                display: block;
            }

            /* Prevent Body from Scrolling When Modal is Open */
            body.modal-open {
                overflow: hidden;
            }

            /* ======================= */
            /*        Minimap Styles   */
            /* ======================= */

            /* Minimap Container */
            #minimapContainer {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 200px;
                height: 200px;
                border: 2px solid #fff;
                overflow: hidden;
                z-index: 5;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 10px;
            }

            /* Minimap Content */
            #minimapContent {
                width: 100%;
                height: 100%;
                background: url('minimap-background.png') no-repeat center center;
                background-size: cover;
            }

            /* ======================= */
            /*        Chest Styles     */
            /* ======================= */

            /* Chest Animation */
            @keyframes chestOpen {
                0% { transform: rotateY(0deg); }
                100% { transform: rotateY(180deg); }
            }

            .chest {
                width: 100px;
                height: 100px;
                background: url('chest-closed.png') no-repeat center center;
                background-size: contain;
                animation: chestOpen 2s forwards;
            }

            /* Chest Open State */
            .chest.open {
                background: url('chest-open.png') no-repeat center center;
                background-size: contain;
            }

            /* ======================= */
            /*       Entity Tooltip    */
            /* ======================= */

            /* Entity Tooltip Styles */
            #entityTooltip {
                position: fixed;
                background-color: rgba(0, 0, 0, 0.9);
                border: 1px solid #444;
                border-radius: 4px;
                pointer-events: none;
                z-index: 1000;
                max-width: 300px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                padding: 10px;
            }

            #entityTooltip .tooltip-header {
                font-weight: bold;
                margin-bottom: 5px;
            }

            #entityTooltip .tooltip-rarity {
                font-style: italic;
                color: #FFD700;
                margin-bottom: 5px;
            }

            #entityTooltip .tooltip-description {
                margin-bottom: 5px;
            }

            #entityTooltip .tooltip-stats {
                color: #00FF00;
                white-space: pre-line;
            }

            /* ======================= */
            /*       Chest Popup       */
            /* ======================= */

            /* Chest Popup Styles */
            #chestPopup {
                position: absolute;
                width: 800px;
                max-height: 90%;
                background: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 20px;
                border: 2px solid #aaa;
                z-index: 10;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                overflow-y: auto;
                display: none;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            }

            /* Chest Inventory Container */
            #chestInventoryContainer {
                display: flex;
                gap: 20px;
                flex-wrap: wrap; /* Allow wrapping if necessary */
            }

            /* Chest Popup Inventory Grid */
            #chestPopup .inventoryGrid {
                max-height: 400px;
                overflow-y: auto;
                display: grid;
                grid-template-columns: repeat(7, 50px); /* Adjust columns as needed */
                grid-auto-rows: 50px;
                gap: 2px;
                margin-top: 10px;
            }

            /* ======================= */
            /*        Keybindings     */
            /* ======================= */

            /* Keybindings List */
            .keybindings-list {
                list-style-type: none;
                padding: 0;
            }

            .keybindings-list li {
                margin-bottom: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .keybindings-list li .action {
                color: #FFD700;
                font-weight: bold;
            }

            .keybindings-list li .key {
                background-color: #333;
                padding: 5px 10px;
                border-radius: 5px;
            }

            /* ======================= */
            /*         Features       */
            /* ======================= */

            /* Features List */
            .features-list {
                list-style-type: disc;
                padding-left: 20px;
            }

            .features-list li {
                margin-bottom: 10px;
            }

            /* ======================= */
            /*         Updates        */
            /* ======================= */

            /* Updates List */
            .updates-list {
                list-style-type: disc;
                padding-left: 20px;
            }

            .updates-list li {
                margin-bottom: 10px;
            }

            /* ======================= */
            /*      Responsive Media   */
            /* ======================= */

            /* Responsive Design for Bestiary and Details Modal */
            @media (max-width: 1200px) {
                .creature-card {
                    flex-direction: column;
                    align-items: center;
                    max-width: 100%;
                }

                .creature-image {
                    width: 100%;
                    height: auto;
                    margin-bottom: 15px;
                }

                .stat-item {
                    flex: 1 1 100%;
                }

                #skillTree {
                    width: 90%;
                    height: 90%;
                }
            }

            @media (max-width: 768px) {
                #bestiaryModal .modal-content,
                #creatureDetailsModal .modal-content,
                #musicModal .modal-content {
                    width: 95%;
                    padding: 15px;
                }

                .bestiary-content {
                    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                    gap: 15px;
                    padding: 15px;
                }

                .creature-card {
                    padding: 10px;
                }

                .creature-image {
                    max-height: 150px;
                }

                .creature-info h3 {
                    font-size: 1.2em;
                }

                .view-details-button {
                    font-size: 0.85em;
                    padding: 7px 10px;
                }

                /* Adjust Creature Details Modal */
                #creatureDetailsModal .modal-content {
                    padding: 20px;
                }

                .creature-detail-header {
                    flex-direction: column;
                    align-items: center;
                }

                .creature-detail-image,
                .stats-container {
                    flex: 1 1 100%;
                }

                .model-container {
                    height: 300px;
                }

                /* Music Modal Adjustments */
                .music-controls {
                    gap: 15px;
                }

                .playlist-item {
                    flex-direction: column;
                    align-items: flex-start;
                }

                .playlist-item .remove-track {
                    margin-left: 0;
                    margin-top: 5px;
                }

                .add-track-button {
                    width: 100%;
                }
            }

            /* ======================= */
            /*        Media Queries    */
            /* ======================= */

            /* Extra Small Devices (Phones) */
            @media (max-width: 576px) {
                .creature-card {
                    padding: 8px;
                }

                .creature-image {
                    max-height: 120px;
                }

                .creature-info h3 {
                    font-size: 1em;
                }

                .view-details-button {
                    font-size: 0.8em;
                    padding: 5px 8px;
                }

                .stat-item span {
                    flex: 0 0 50px;
                    font-size: 1em;
                }

                .stat-item .stat-bar {
                    height: 15px;
                }

                .progress {
                    height: 15px;
                }

                .model-container {
                    height: 250px;
                }

                /* Music Modal Adjustments */
                #musicModal .modal-content {
                    padding: 10px;
                }

                .music-player {
                    max-width: 100%;
                }

                .playlist {
                    margin-top: 15px;
                }

                .playlist-item {
                    grid-template-columns: 1fr;
                }
            }

            /* ======================= */
            /*        Miscellaneous    */
            /* ======================= */

            /* Prevent text selection for buttons */
            button {
                user-select: none;
            }



            /* Ensure Buttons are Accessible */
            button:focus {
                outline: 2px solid #FFD700;
                outline-offset: 2px;
            }

            /* ======================= */
            /*        Music Player     */
            /* ======================= */

            /* Music Player Controls */
            .music-player-controls {
                display: flex;
                align-items: center;
                gap: 10px;
                width: 100%;
                max-width: 600px;
                margin-top: 20px;
            }

            .music-player-controls button {
                background-color: #444;
                color: #fff;
                border: none;
                padding: 8px 12px;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s, transform 0.2s;
            }

            .music-player-controls button:hover {
                background-color: #555;
                transform: scale(1.05);
            }

            /* Progress Bar */
            .music-player .progress-container {
                width: 100%;
                background-color: #333;
                height: 10px;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 10px;
            }

            .music-player .progress-bar {
                width: 0%;
                height: 100%;
                background-color: #FFD700;
                border-radius: 5px;
                transition: width 0.1s linear;
            }

            /* ======================= */
            /*         Animations      */
            /* ======================= */

            /* Chest Opening Animation */
            @keyframes chestOpenAnimation {
                from { transform: rotateY(0deg); }
                to { transform: rotateY(180deg); }
            }

            .chest.opening {
                animation: chestOpenAnimation 1s forwards;
            }

            /* ======================= */
            /*        Dark Mode        */
            /* ======================= */

            /* Optional: Dark Mode Toggle */
            body.dark-mode {
                background-color: #121212;
                color: #e0e0e0;
            }

            body.dark-mode .modal-content,
            body.dark-mode #adminConsole .modal-content,
            body.dark-mode #bestiaryModal .modal-content,
            body.dark-mode #creatureDetailsModal .modal-content,
            body.dark-mode #musicModal .modal-content {
                background-color: #1A1A1A;
                color: #e0e0e0;
            }

            body.dark-mode .creature-card {
                background-color: #292929;
                color: #e0e0e0;
            }

            body.dark-mode .creature-card:hover {
                background-color: #3a3a3a;
            }

            body.dark-mode .view-details-button {
                background-color: #8B0000;
                color: #fff;
            }

            body.dark-mode .view-details-button:hover {
                background-color: #FF6347;
            }

            body.dark-mode .tab-button.active {
                background-color: #FFD700;
                color: #2c2c2c;
            }

            body.dark-mode .admin-tab-content h3,
            body.dark-mode .admin-tab-content h4 {
                color: #FFD700;
            }

            body.dark-mode .tooltip {
                background-color: rgba(0, 0, 0, 0.9);
                color: #fff;
            }

            body.dark-mode .inventory-slot {
                background: rgba(255, 255, 255, 0.1);
            }

            body.dark-mode .inventory-slot:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }

            /* ======================= */
            /*        Best Practices   */
            /* ======================= */

            /* Consistent Box Sizing */
            *, *::before, *::after {
                box-sizing: border-box;
            }

            /* Consistent Font Sizing */
            body {
                font-size: 16px;
            }

            h2, h3, h4 {
                margin: 0 0 10px 0;
            }

            p {
                margin: 0 0 10px 0;
            }

            /* Button Accessibility */
            button {
                font-family: inherit;
                font-size: inherit;
            }

            /* ======================= */
            /*        Utility Classes  */
            /* ======================= */

            /* Flex Utilities */
            .flex {
                display: flex;
            }

            .flex-center {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .flex-column {
                display: flex;
                flex-direction: column;
            }

            .flex-row {
                display: flex;
                flex-direction: row;
            }

            /* Margin Utilities */
            .mt-10 { margin-top: 10px; }
            .mb-10 { margin-bottom: 10px; }
            .mt-20 { margin-top: 20px; }
            .mb-20 { margin-bottom: 20px; }

            /* Padding Utilities */
            .p-10 { padding: 10px; }
            .p-20 { padding: 20px; }

            /* Display Utilities */
            .d-none { display: none; }
            .d-block { display: block; }
            .d-flex { display: flex; }

            /* Text Alignment */
            .text-center { text-align: center; }
            .text-left { text-align: left; }
            .text-right { text-align: right; }

            /* Visibility */
            .visible { visibility: visible; }
            .hidden { visibility: hidden; }

            /* Cursor Styles */
            .cursor-pointer { cursor: pointer; }
            .cursor-default { cursor: default; }

            /* ======================= */
            /*        Media Queries    */
            /* ======================= */

            /* Tablets */
            @media (max-width: 992px) {
                #inventory, #stats {
                    width: 80%;
                }

                #minimapContainer {
                    width: 150px;
                    height: 150px;
                }

                .inventoryGrid {
                    grid-template-columns: repeat(6, 50px);
                }

                #chestPopup {
                    width: 600px;
                }
            }

            /* Mobile Devices */
            @media (max-width: 576px) {
                #inventory, #stats {
                    width: 95%;
                }

                #minimapContainer {
                    width: 120px;
                    height: 120px;
                }

                .inventoryGrid {
                    grid-template-columns: repeat(5, 50px);
                }

                #chestPopup {
                    width: 90%;
                }
            }

            /* ======================= */
            /*         Animations      */
            /* ======================= */



            .modal.hide .modal-content {
                animation: fadeOut 0.3s forwards;
            }

            /* ======================= */
            /*     Audio Widget Styles */
            /* ======================= */

            /* Audio Widget Container */
            #audioWidgetContainer {
                position: fixed;
                top: 20px;    /* 20px from the top */
                left: 20px;   /* 20px from the left */
                width: 300px; /* Default width */
                height: 400px;/* Default height */
                background: transparent;
                border: none;
                z-index: 999; /* Ensure it's above most elements */
                pointer-events: auto; /* Allow interactions */
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
                border-radius: 8px; /* Rounded corners */
                overflow: hidden; /* Prevents iframe overflow */
                transition: width 0.3s ease, height 0.3s ease, transform 0.3s ease; /* Smooth transition */
            }

            /* Minimized State with Slide */
            #audioWidgetContainer.minimized {
                width: 50px;  /* Reduced width */
                height: 50px; /* Reduced height */
                transform: translate(-50%, -50%) rotate(-90deg); /* Optional: Rotate or slide */
            }

            /* Style the iframe to occupy the full container */
            #audio_iframe {
                width: 100%;
                height: 100%;
                border: none;
                transition: opacity 0.3s ease; /* Smooth opacity transition */
            }

            /* Hide iframe when minimized */
            #audioWidgetContainer.minimized #audio_iframe {
                opacity: 0;
            }

            /* Toggle Button Styles */
            .toggle-button {
                position: absolute;
                top: 5px;
                right: 5px;
                width: 20px;
                height: 20px;
                background-color: rgba(255, 215, 0, 0.8); /* Gold color */
                border: none;
                border-radius: 50%;
                cursor: pointer;
                font-size: 14px;
                line-height: 20px;
                text-align: center;
                padding: 0;
                transition: background-color 0.3s ease;
            }

            /* Toggle Button Hover Effect */
            .toggle-button:hover {
                background-color: rgba(255, 215, 0, 1);
            }

            /* Responsive adjustments for minimized state */
            #audioWidgetContainer.minimized {
                width: 40px;  /* Further reduced width */
                height: 40px; /* Further reduced height */
            }

            @media (max-width: 600px) {
                #audioWidgetContainer {
                    width: 250px; /* Adjusted width for smaller screens */
                    height: 350px;/* Adjusted height for smaller screens */
                }

                #audioWidgetContainer.minimized {
                    width: 40px;
                    height: 40px;
                }
            }

            @media (max-width: 400px) {
                #audioWidgetContainer {
                    width: 200px; /* Further reduced width */
                    height: 300px;/* Further reduced height */
                }

                #audioWidgetContainer.minimized {
                    width: 35px;  /* Even smaller width */
                    height: 35px; /* Even smaller height */
                }
            }

            .fullscreen-map {
                display: none;
                /* Add other styles as needed */
            }

            .close-map-button {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 201;
                /* Add other styles as needed */
            }


            /* ======================= */
            /*         End of CSS      */
            /* ======================= */


        </style>
        <!-- Include Three.js -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
        <!-- Include GLTFLoader -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        <!-- Fullscreen Map -->
        <div id="fullscreenMap" class="fullscreen-map">
            <canvas id="mapCanvas"></canvas>
            <button onclick="closeFullscreenMap()" class="close-map-button">Close Map</button>
        </div>        
        <!-- Dark Mode Toggle Button -->
        <button id="darkModeToggle" class="dark-mode-toggle" aria-label="Toggle Dark Mode"></button>
        <!-- Open Help Button -->
        <button id="openHelp" class="open-help-button" aria-haspopup="dialog" aria-controls="helpWindow">
            Help
        </button>
        <!-- Help Window Modal -->
        <div id="helpWindow" class="modal" role="dialog" aria-labelledby="helpWindowTitle" aria-modal="true" aria-hidden="true">
            <div class="modal-content">
                <button id="closeHelp" class="close-button" aria-label="Close Help Window">&times;</button>
                <h2 id="helpWindowTitle">Help & Information</h2>
                <div class="content">
                    <div class="left-column">
                        <h3>Latest Updates</h3>
                        <p><strong>Version 0.3.6</strong></p>
                        <h3><strong>Admin Info:</strong></h3>
                        <p><strong>Admin Password: xxxxxxx</strong></p>
                        <ul class="updates">
                            <li>Added "The Machine" - AI</li>
                            <li>Improved Music Page</li>
                            <li>Fixed duplicate functions</li>
                            <li>Minor Bugfixes</li>
                            <li>Fixed Enemies a bit</li>
                        </ul>
                    </div>
                    <div class="right-column">
                        <h3>Key Bindings</h3>
                        <ul class="keybindings">
                            <li><strong>I</strong> or <strong>B</strong>: Open/Close Inventory</li>
                            <li><strong>C</strong>: Open/Close Character Stats</li>
                            <li><strong>Q</strong>: Open/Close Quest Log</li>
                            <li><strong>T</strong>: Start Teleportation</li>
                            <li><strong>A</strong>: Rotate Camera Left</li>
                            <li><strong>D</strong>: Rotate Camera Right</li>
                            <li><strong>`</strong>: Open/Close Admin Console</li>
                            <li><strong>H</strong>: Open/Close Help Window</li>
                            <li><strong>Y</strong>: Open/Close Bestiary</li>
                            <li><strong>M</strong>: Open Music Page</li>
                        </ul>
                        <h3>Planned Fixes</h3>
                        <ul class="features">
                            <li>Work in Progress (WIP)</li>
                            <!-- Uncomment and add more planned fixes as needed -->
                            <li>Ground Is Bugged</li>
                            <li>Fix Item ToolTips</li>
                            <li>Fix NPC Dialogues</li>
                            <li>Fix "Now Playing"</li>
                            <li>Implement Quests</li>
                            <li>Implement Skills</li>
                            <li>Implement Traits</li>
                            <li>Implement Structures</li>
                            <li>Implement Settlements</li>
                            <li>Expand Bestiary</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div id="notificationContainer" aria-live="polite" aria-atomic="true">
            <!-- Notifications will be injected here -->
        </div>

        <!-- Skill Tree Popup -->
        <div id="skillTree" style="display: none;">
            <h2>Skill Tree</h2>
            <div id="skillsContainer">
                <!-- Skills will be dynamically added here -->
            </div>
            <button onclick="closeSkillTree()">Close Skill Tree</button>
        </div>

        <!-- Button to Open Bestiary -->
        <button id="openBestiary" class="open-bestiary-button">View Bestiary</button>

        <!-- Bestiary Modal -->
        <div id="bestiaryModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <button id="closeBestiary" class="close-button" aria-label="Close Bestiary">&times;</button>
                <div id="bestiaryContent" class="bestiary-content">
                    <!-- Bestiary entries will be injected here -->
                </div>
            </div>
        </div>        

        <!-- Race Details Modal -->
        <div id="creatureDetailsModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <button class="close-details close-button" aria-label="Close Creature Details">&times;</button>
                <div id="creatureDetailsContent">
                    <!-- Creature details will be injected here -->
                </div>
            </div>
        </div>

        <!-- New Button to Open Music Page -->
        <button id="openMusic" class="open-music-button">Open Music</button>

        <!-- Music Modal -->
        <div id="musicModal" class="modal" style="display: none;">
            <div class="modal-content">
                <button id="closeMusicModal" class="close-button">&times;</button>
                <iframe src="music.html" style="width: 100%; height: 100%; border: none;" loading="lazy"></iframe>

            </div>
        </div>

        <!-- Now Playing Controls -->
        <!-- <div id="nowPlaying" class="now-playing">
            <span id="trackTitle">Now Playing: None</span>
            <button id="playPauseButton" onclick="togglePlayPause()"></button>
        </div>         -->

        <div id="inventory">
            <h2>Inventory</h2>
            <div id="playerDetails">
                <img id="playerImage" src="path/to/player_image.png" alt="Player" />
                <div id="playerStats">
                    <p>Level: <span id="playerLevel">1</span></p>
                    <p>Health: <span id="playerHealth">100</span></p>
                    <p>Gold: <span id="goldAmount">0</span></p>
                </div>
            </div>
            <div id="inventoryTabs">
                <button class="inventory-tab" data-tab="tab1">Tab 1</button>
                <button class="inventory-tab" data-tab="tab2">Tab 2</button>
                <button class="inventory-tab" data-tab="tab3">Tab 3</button>
                <button class="inventory-tab" data-tab="tab4">Tab 4</button>
                <button class="inventory-tab" data-tab="tab5">Tab 5</button>
                <button class="inventory-tab" data-tab="tab6">Tab 6</button>
            </div>
            <div id="inventoryTabsContent">
                <div class="inventory-tab-content active" id="tab1">
                    <div class="inventoryGrid" id="inventoryGridTab1"></div>
                </div>
                <div class="inventory-tab-content" id="tab2">
                    <div class="inventoryGrid" id="inventoryGridTab2"></div>
                </div>
                <div class="inventory-tab-content" id="tab3">
                    <div class="inventoryGrid" id="inventoryGridTab3"></div>
                </div>
                <div class="inventory-tab-content" id="tab4">
                    <div class="inventoryGrid" id="inventoryGridTab4"></div>
                </div>
                <div class="inventory-tab-content" id="tab5">
                    <div class="inventoryGrid" id="inventoryGridTab5"></div>
                </div>
                <div class="inventory-tab-content" id="tab6">
                    <div class="inventoryGrid" id="inventoryGridTab6"></div>
                </div>
            </div>
        </div>

        <div id="stats">
            <h2>Character Stats</h2>
            <p>Level: <span id="level">1</span></p>
            <p>Experience: <span id="experience">0</span> / <span id="nextLevelExperience">100</span></p>
            <p>Strength: <span id="strength">10</span></p>
            <p>Dexterity: <span id="dexterity">10</span></p>
            <p>Vitality: <span id="vitality">10</span></p>
            <p>Energy: <span id="energy">10</span></p>
            <p>Mana: <span id="mana">50</span></p>
            <p>Karma: <span id="karma">0</span></p> 
            <p>Reputation: <span id="reputation">0</span></p> 
            <p>Available Stat Points: <span id="statPoints">0</span></p>
            <button onclick="increaseStat('strength')">Increase Strength</button>
            <button onclick="increaseStat('dexterity')">Increase Dexterity</button>
            <button onclick="increaseStat('vitality')">Increase Vitality</button>
            <button onclick="increaseStat('energy')">Increase Energy</button>
            <button onclick="increaseStat('mana')">Increase Mana</button> <!-- New Button -->
            <button onclick="increaseStat('karma')">Increase Karma</button> <!-- New Button -->
            <button onclick="increaseStat('reputation')">Increase Reputation</button> <!-- New Button -->
        </div>

        <div id="hotbar">
            <div class="slot" data-slot="1"></div>
            <div class="slot" data-slot="2"></div>
            <div class="slot" data-slot="3"></div>
            <div class="slot" data-slot="4"></div>
            <div class="slot" data-slot="5"></div>
            <div class="slot" data-slot="6"></div>
            <div class="slot" data-slot="7"></div>
            <div class="slot" data-slot="8"></div>
            <div class="slot" data-slot="9"></div>
            <div class="slot" data-slot="0"></div> <!-- '0' represents the 10th slot -->
        </div>

        <div id="minimapContainer"></div>

        <div id="npcPopup" style="display: none;">
            <h2>Friendly NPC</h2>
            <p>Hello, traveler! Stay awhile and listen...</p>
            <button onclick="closeNpcPopup()">Close</button>
        </div>

        <div id="lifeOrb">
            <div id="lifeFill"></div>
            <div id="lifeValue">100/100</div>
        </div>

        <div id="energyOrb">
            <div id="energyValue">1/1</div>
        </div>

        <div id="teleportationBarContainer">
            <div id="teleportationBar"></div>
        </div>
        <!-- Add Loading Indicator HTML -->
        <div id="adminLoading" class="loading-overlay" style="display: none;">
            <div class="loading-spinner"></div>
        </div>

        <!-- Admin Console Modal -->
        <div id="adminConsole" class="modal" aria-hidden="true" role="dialog" aria-labelledby="adminConsoleTitle">
            <div class="modal-content">
                <button class="close-button" onclick="closeAdminConsole()" aria-label="Close Admin Console">&times;</button>
                <h2 id="adminConsoleTitle">Admin Console</h2>
                
                <!-- Tab Navigation -->
                <div class="admin-tabs">
                    <button class="tab-button active" data-tab="adminLogin">Login</button>
                    <button class="tab-button" data-tab="playerManagement">Player Management</button>
                    <button class="tab-button" data-tab="gameSettings">Game Settings</button>
                    <button class="tab-button" data-tab="spawnOptions">Spawn Options</button>
                    <button class="tab-button" data-tab="teleportPlayer">Teleport Player</button>
                    <button class="tab-button" data-tab="npcAdmin">NPC Admin</button>
                </div>
                
                <!-- Tab Content -->
                <div class="admin-tab-content active" id="adminLogin">
                    <h3>Admin Login</h3>
                    <p>Please enter the admin password:</p>
                    <input type="password" id="adminPassword" placeholder="Enter Password">
                    <button onclick="checkAdminPassword()">Submit</button>
                </div>
                
                <div class="admin-tab-content" id="playerManagement">
                    <h3>Player Management</h3>
                    <section>
                        <h4>Player Stats</h4>
                        <p>Health: <input type="number" id="playerHealthInput" value="100" step="1" min="0"></p>
                        <p>Gold: <input type="number" id="playerGoldInput" value="0" step="1" min="0"></p>
                        <p>Experience: <input type="number" id="playerExperienceInput" value="0" step="1" min="0"></p>
                        <button onclick="updatePlayerStats()">Update Player Stats</button>
                    </section>
                    <section>
                        <h4>Player Options</h4>
                        <p>
                            <label class="checkbox-label">
                                <input type="checkbox" id="invulnerabilityCheckbox"> Invulnerable
                            </label>
                        </p>
                        <button onclick="updatePlayerOptions()">Update Player Options</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="gameSettings">
                    <h3>Game Settings</h3>
                    <section>
                        <h4>Enemy Speed</h4>
                        <p>Enemy Speed: <input type="number" id="enemySpeedInput" value="0.7" step="0.1" min="0"></p>
                        <button onclick="updateGameSettings()">Update Game Settings</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="spawnOptions">
                    <h3>Spawn Options</h3>
                    <section>
                        <h4>Spawn Entities</h4>
                        <p>Entity Type:
                            <select id="entityTypeSelect">
                                <option value="enemy">Enemy</option>
                                <option value="friendlyNPC">Friendly NPC</option>
                                <option value="structure">Structure</option>
                                <option value="treasureChest">Treasure Chest</option>
                                <option value="settlement">Settlement</option>
                                <option value="quadruped">Quadruped</option>
                            </select>
                        </p>
                        <p>Quantity: <input type="number" id="entityQuantityInput" value="1" step="1" min="1"></p>
                        <button onclick="spawnEntities()">Spawn Entities</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="teleportPlayer">
                    <h3>Teleport Player</h3>
                    <section>
                        <h4>Set Player Coordinates</h4>
                        <p>X: <input type="number" id="teleportXInput" value="0" step="1"></p>
                        <p>Z: <input type="number" id="teleportZInput" value="0" step="1"></p>
                        <button onclick="teleportPlayer()">Teleport Player</button>
                    </section>
                </div>
                
                <div class="admin-tab-content" id="npcAdmin">
                    <h3>NPC Admin</h3>
                    <section>
                        <h4>Manage NPC Admin Mode</h4>
                        <p>
                            <label class="checkbox-label">
                                <input type="checkbox" id="npcAdminCheckbox"> Enable NPC Admin Mode
                            </label>
                        </p>
                    </section>
                </div>
                
            </div>
        </div>

        <div id="lootBarContainer">
            <div id="lootBar"></div>
        </div>
        <!-- Trait Selection Modal -->
        <div id="traitSelectionModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="traitSelectionTitle">
            <div class="modal-content">
                <button class="close-trait-selection close-button" aria-label="Close Trait Selection">&times;</button>
                <h2 id="traitSelectionTitle">Select Your Traits</h2>
                <div id="traitOptions">
                    <!-- Trait options will be dynamically added here -->
                </div>
                <button onclick="confirmTraitSelection()">Confirm Traits</button>
            </div>
        </div>

        <div id="lootPopup">
            <h2>Loot</h2>
            <div id="lootItems"></div>
            <button onclick="lootAllItems()">Loot All</button>
        </div>

        <div id="npcAdminPopup" style="display: none;">
            <h2>NPC Admin</h2>
            <p>Name: <input type="text" id="npcNameInput"></p>
            <p>Health: <input type="number" id="npcHealthInput" step="1"></p>
            <p>Dialogue:</p>
		
		    <!-- Add color inputs for body parts -->
		    <p>Head Color: <input type="color" id="npcHeadColorInput"></p>
		    <p>Body Color: <input type="color" id="npcBodyColorInput"></p>
		    <p>Arm Color: <input type="color" id="npcArmColorInput"></p>
		    <p>Leg Color: <input type="color" id="npcLegColorInput"></p>

            <textarea id="npcDialogueInput" rows="4" cols="50"></textarea>
            <br>
            <button onclick="saveNpcChanges()">Save Changes</button>
            <button onclick="closeNpcAdminPopup()">Close</button>
        </div>

        <div id="chestPopup" style="display: none;">
            <h2>Chest Interaction</h2>
            <div id="chestInventoryContainer">
                <div>
                    <h3>Chest Inventory</h3>
                    <div id="chestInventoryGrid" class="inventoryGrid"></div>
                </div>
                <div>
                    <h3>Your Inventory</h3>
                    <div id="playerInventoryInChestGrid" class="inventoryGrid"></div>
                </div>
            </div>
            <button onclick="closeChestPopup()">Close</button>
        </div>

        <!-- Quest Log Popup -->
        <div id="questLog" style="display: none;">
            <h2>Quest Log</h2>
            <ul id="questList">
                <!-- Quests will be dynamically added here -->
            </ul>
            <button onclick="closeQuestLog()">Close Quest Log</button>
        </div>

	    <div id="structureAdminPopup" style="display: none;">
		    <h2>Structure Admin</h2>
		    <p>Scale: <input type="number" id="structureScaleInput" value="1" step="0.1"></p>
		    <p>Color: <input type="color" id="structureColorInput"></p>
		    <button onclick="saveStructureChanges()">Save Changes</button>
		    <button onclick="closeStructureAdminPopup()">Close</button>
	    </div>

        <!-- SCRIPTS -->
        <script>
            let inventoryLoaded = false;
            const clock = new THREE.Clock(); // Create a new Three.js clock
            let mapScene, mapCamera, mapRenderer; // Create a new Three.js scene, camera, and renderer for the fullscreen map.
            let scene, camera, renderer; // Create a new Three.js scene, camera, and renderer
            let player, ground, safeZoneGround; // Player, ground, and safe zone
            let inventoryOpen = false; // Inventory state
            let statsOpen = false; // Character stats state
            let destination = null; // Destination for teleportation
            let speed = 1.0; // Player movement speed
            let minimapCamera; // Minimap camera
            let enemies = []; // List of enemies
            let gold = 0; // Gold amount
            let bestiary = {}; // Bestiary data
            const townRadius = 200; // Radius of the town
            let quadrupeds = []; // List of quadrupeds
            let walls = []; // List of walls
            let friendlies = []; // List of friendlies
            let helpWindowOpen = false; // Add this variable for help window
            let isTeleporting = false; // Add this variable for teleportation
            let adminConsoleOpen = false; // Add this variable for admin console
            let teleportProgress = 0; // Add this variable for teleportation
            let teleportationDuration = 3; // Duration in seconds
            let previousPosition = null; // Add this variable for teleportation
            let structures = []; // Add this variable for structures
            let cameraAngle = 0;    // Add this variable for camera angle
            let enemyWalls = []; // Walls that affect only enemies
            let npcPopupOpen = false; // Track NPC popup state
            let npcAdminEnabled = false; // Track NPC admin state
            let currentNpc = null; // Track current NPC
            let currentOpenedChest = null; // Added to address the popup issue
            let treasureChests = []; // Added to keep track of treasure chests
            let isAdminLoggedIn = false; // Add this variable for admin login
            let quests = [];
            let questLogOpen = false; // Add this variable for quest log
            let isMouseDown = false; // Add this variable for mouse down
            let mouseDestination = null; // Add this variable for mouse down
            let cameraTargetAngle = 0; // Add this variable for camera target angle
            let currentCameraAngle = 0; // Add this variable for current camera angle
            const cameraRotationSpeed = 0.05; // Adjust for smoother or faster rotation
            let rotateLeft = false; // Add this variable for rotation
            let currentStructure = null; // Implement Structure Admin Functions
            let rotateRight = false; // Add this variable for rotation
            let globalEnemySpeed = 1; // Global variable for enemy speed
            let activeDamageIntervals = new Map(); // Keep track of active damage intervals
            const collidableTerrainObjects = [];       
            let playerInventory = []; // Player inventory
            
            
            const npcData = [
                { 
                    name: 'John Reilly', 
                    dialogue: 'Greetings, adventurer. May your journey be safe.', 
                    occupation: 'Town Guard', 
                    health: 100, 
                    location: { x: 200, y: 0, z: -150 },
                    faction: 'Town' 
                },
                { 
                    name: 'Martha Reilly', 
                    dialogue: 'Looking to trade? I have wares you might like.', 
                    occupation: 'Merchant', 
                    health: 100, 
                    location: { x: 300, y: 0, z: -100 },
                    faction: 'Town' 
                },
                { 
                    name: 'Noah', 
                    dialogue: 'Need your weapons sharpened?', 
                    occupation: 'Blacksmith', 
                    health: 120, 
                    location: { x: 100, y: 0, z: -50 },
                    faction: 'Town' 
                },
                { 
                    name: 'Jace', 
                    dialogue: 'These crops won\'t tend themselves.', 
                    occupation: 'Farmer', 
                    health: 80, 
                    location: { x: 400, y: 0, z: 0 },
                    faction: 'Village' 
                },
                { 
                    name: 'Kaanan', 
                    dialogue: 'Stay vigilant out there.', 
                    occupation: 'Ranger', 
                    health: 150, 
                    location: { x: -50, y: 0, z: 50 },
                    faction: 'Outskirts' 
                },
                { 
                    name: 'Spyder', 
                    dialogue: 'Got any info worth trading?', 
                    occupation: 'Information Broker', 
                    health: 70, 
                    location: { x: 250, y: 0, z: -250 },
                    faction: 'Underworld' 
                },
                { 
                    name: 'Flick', 
                    dialogue: 'Quick hands, quicker wit.', 
                    occupation: 'Thief', 
                    health: 60, 
                    location: { x: 500, y: 0, z: -300 },
                    faction: 'Rogue' 
                },
                { 
                    name: 'ZANE', 
                    dialogue: 'What do you seek?', 
                    occupation: 'Mystic', 
                    health: 90, 
                    location: { x: -100, y: 0, z: 100 },
                    faction: 'Wanderers' 
                },
                { 
                    name: 'Bill', 
                    dialogue: 'Another day, another coin.', 
                    occupation: 'Innkeeper', 
                    health: 100, 
                    location: { x: 150, y: 0, z: -20 },
                    faction: 'Town' 
                },
                { 
                    name: 'Samantha', 
                    dialogue: 'Every herb has a purpose.', 
                    occupation: 'Healer', 
                    health: 110, 
                    location: { x: 120, y: 0, z: -120 },
                    faction: 'Village' 
                },
                { 
                    name: 'Julia', 
                    dialogue: 'A good book can change your life.', 
                    occupation: 'Librarian', 
                    health: 80, 
                    location: { x: 220, y: 0, z: -90 },
                    faction: 'Town' 
                },
                { 
                    name: 'Abigail', 
                    dialogue: 'May the gods protect you.', 
                    occupation: 'Priestess', 
                    health: 90, 
                    location: { x: -200, y: 0, z: -150 },
                    faction: 'Sanctum' 
                },
                { 
                    name: 'Guard 1', 
                    dialogue: 'No one passes without permission.', 
                    occupation: 'Guard', 
                    health: 120, 
                    location: { x: 300, y: 0, z: -200 },
                    faction: 'Fortress' 
                },
                { 
                    name: 'Guard 2', 
                    dialogue: 'Stand down or face the consequences.', 
                    occupation: 'Guard', 
                    health: 120, 
                    location: { x: 320, y: 0, z: -220 },
                    faction: 'Fortress' 
                },
                { 
                    name: 'Nick', 
                    dialogue: 'Its quiet too quiet.', 
                    occupation: 'Scout', 
                    health: 90, 
                    location: { x: -150, y: 0, z: 50 },
                    faction: 'Outskirts' 
                },
                { 
                    name: 'Xris Hawkins', 
                    dialogue: 'Even in ruins, theres beauty.', 
                    occupation: 'Bard', 
                    health: 100, 
                    location: { x: 0, y: 0, z: 0 },
                    faction: 'Wanderers' 
                },
                { 
                    name: 'Samuel Kont', 
                    dialogue: 'Science holds the answers you seek.', 
                    occupation: 'Scientist', 
                    health: 85, 
                    location: { x: -300, y: 0, z: 50 },
                    faction: 'Research Guild' 
                }
            ];

            // Player health and energy
            let playerHealth = 100;
            const playerMaxHealth = 100;
            let playerEnergy = 1;
            const playerMaxEnergy = 1;

            // Invulnerability variable
            let playerInvulnerable = false;

            // Looting variables
            let isLooting = false;
            let lootProgress = 0;
            const lootDuration = 2; // Duration in seconds
            let lootedItems = [];
            let currentLootingEnemy = null;

            // Initialize Character Stats with Expanded Attributes
            let characterStats = {
                level: 1,
                experience: 0,
                nextLevelExperience: 100,
                strength: 10,
                dexterity: 10,
                vitality: 10,
                energy: 10,
                mana: 50,          // New Attribute
                karma: 0,          // New Attribute
                reputation: 0,     // New Attribute
                statPoints: 0
            };

            // Define skill tree data with new attributes
            let skillTreeData = {
                strength: {
                    name: 'Strength Boost',
                    description: 'Increase your strength by 5.',
                    cost: 1,
                    learned: false,
                    effects: { strength: 5 }
                },
                dexterity: {
                    name: 'Dexterity Boost',
                    description: 'Increase your dexterity by 5.',
                    cost: 1,
                    learned: false,
                    effects: { dexterity: 5 }
                },
                vitality: {
                    name: 'Vitality Boost',
                    description: 'Increase your vitality by 5.',
                    cost: 1,
                    learned: false,
                    effects: { vitality: 5 }
                },
                energy: {
                    name: 'Energy Boost',
                    description: 'Increase your energy by 5.',
                    cost: 1,
                    learned: false,
                    effects: { energy: 5 }
                },
                mana: {
                    name: 'Mana Pool',
                    description: 'Increase your mana by 20.',
                    cost: 2,
                    learned: false,
                    effects: { mana: 20 }
                },
                karmaInfluence: {
                    name: 'Karma Influence',
                    description: 'Increase your karma by 5.',
                    cost: 2,
                    learned: false,
                    effects: { karma: 5 }
                },
                reputationBoost: {
                    name: 'Reputation Boost',
                    description: 'Increase your reputation by 10.',
                    cost: 2,
                    learned: false,
                    effects: { reputation: 10 }
                }
                // Add more skills as needed
            };

            const color = 0xFFFFFF; // Example color in hexadecimal

            // Function to open the music modal
            function openMusicModal() {
                console.log('openMusicModal called'); // Add this line
                document.getElementById('musicModal').style.display = 'flex';
            }

            function openAdminConsole() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'flex';
                adminConsoleOpen = true;

                // Reset to Login tab when opening
                setActiveAdminTab('adminLogin');
            }

            // Function to close Admin Console
            function closeAdminConsole() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'none';
                adminConsoleOpen = false;

                // Reset admin login status to require password again
                isAdminLoggedIn = false;
                setActiveAdminTab('adminLogin');
            }

            // Function to set active admin tab
            function setActiveAdminTab(tabId) {
                // Remove 'active' class from all tabs
                const tabs = document.querySelectorAll('.admin-tabs .tab-button');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                });

                // Hide all tab contents
                const tabContents = document.querySelectorAll('.admin-tab-content');
                tabContents.forEach(content => {
                    content.classList.remove('active');
                });

                // Activate the selected tab
                const activeTab = document.querySelector(`.admin-tabs .tab-button[data-tab="${tabId}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }

                // Show the selected tab content
                const activeContent = document.getElementById(tabId);
                if (activeContent) {
                    activeContent.classList.add('active');
                }

                // Special handling for tabs that require admin login
                const adminOnlyTabs = ['playerManagement', 'gameSettings', 'spawnOptions', 'teleportPlayer', 'npcAdmin'];
                if (adminOnlyTabs.includes(tabId) && !isAdminLoggedIn) {
                    alert('Please log in as admin to access this section.');
                    setActiveAdminTab('adminLogin');
                }
            }

            // Function to handle tab clicks
            function setupAdminTabs() {
                const tabs = document.querySelectorAll('.admin-tabs .tab-button');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.getAttribute('data-tab');
                        setActiveAdminTab(tabId);
                    });
                });
            }

            // Function to check Admin Password
            function checkAdminPassword() {
                const passwordInput = document.getElementById('adminPassword').value;
                if (passwordInput === 'ltwelcome1') { // Replace with secure authentication in production
                    isAdminLoggedIn = true;
                    alert('Admin login successful!');
                    setActiveAdminTab('playerManagement'); // Redirect to Player Management or desired tab

                    // Attach event listeners for admin controls
                    attachAdminEventListeners();
                } else {
                    alert('Incorrect password!');
                }
            }

            // Function to attach event listeners for admin controls
            function attachAdminEventListeners() {
                // Ensure event listeners are attached only once
                const npcAdminCheckbox = document.getElementById('npcAdminCheckbox');
                if (npcAdminCheckbox && !npcAdminCheckbox.hasAttribute('data-listener')) {
                    npcAdminCheckbox.addEventListener('change', function() {
                        npcAdminEnabled = this.checked;
                        alert('NPC Admin Mode ' + (npcAdminEnabled ? 'Enabled' : 'Disabled'));
                    });
                    npcAdminCheckbox.setAttribute('data-listener', 'true');
                }
            }

            // Function to update Player Stats
            function updatePlayerStats() {
                const healthInput = parseInt(document.getElementById('playerHealthInput').value);
                const goldInput = parseInt(document.getElementById('playerGoldInput').value);
                const experienceInput = parseInt(document.getElementById('playerExperienceInput').value);

                if (!isNaN(healthInput)) {
                    playerHealth = Math.min(healthInput, playerMaxHealth);
                    updateHealthDisplay();
                }
                if (!isNaN(goldInput)) {
                    gold = goldInput;
                    updateGoldDisplay();
                }
                if (!isNaN(experienceInput)) {
                    characterStats.experience = experienceInput;
                    if (characterStats.experience >= characterStats.nextLevelExperience) {
                        levelUp();
                    }
                    updateStatsDisplay();
                }
                alert('Player stats updated.');
            }

            // Function to update Player Options
            function updatePlayerOptions() {
                playerInvulnerable = document.getElementById('invulnerabilityCheckbox').checked;
                alert('Player options updated.');
            }

            // Function to update Game Settings
            function updateGameSettings() {
                const enemySpeedInput = parseFloat(document.getElementById('enemySpeedInput').value);

                if (!isNaN(enemySpeedInput) && enemySpeedInput > 0) {
                    globalEnemySpeed = enemySpeedInput;
                    alert('Game settings updated.');
                } else {
                    alert('Invalid enemy speed!');
                }
            }

            // Teleport Player with Confirmation
            function teleportPlayer() {
                const x = parseInt(document.getElementById('teleportXInput').value);
                const z = parseInt(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    if (confirm(`Are you sure you want to teleport the player to (${x}, ${z})?`)) {
                        player.position.set(x, player.position.y, z);
                        alert(`Player teleported to (${x}, ${z}).`);
                    }
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // Spawn Entities with Loading Indicator
            function spawnEntities() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity < 1) {
                    alert('Please enter a valid quantity.');
                    return;
                }

                if (confirm(`Are you sure you want to spawn ${quantity} ${entityType}(s)?`)) {
                    // Show loading indicator
                    document.getElementById('adminLoading').style.display = 'flex';

                    setTimeout(() => { // Simulate async operation
                        for (let i = 0; i < quantity; i++) {
                            // Implement your entity spawning logic here
                            console.log(`Spawning ${entityType} (${i + 1}/${quantity})`);
                            // Example: spawnEntity(entityType);
                        }

                        alert(`Spawned ${quantity} ${entityType}(s).`);

                        // Hide loading indicator
                        document.getElementById('adminLoading').style.display = 'none';
                    }, 1000); // Adjust timeout as needed based on actual spawning time
                }
            }


            // Function to handle closing all menus (existing functionality)
            function closeAllMenus() {
                // Close Inventory
                if (inventoryOpen) {
                    inventoryOpen = false;
                    document.getElementById('inventory').style.display = 'none';
                }

                // Close Stats
                if (statsOpen) {
                    statsOpen = false;
                    document.getElementById('stats').style.display = 'none';
                }

                // Close Admin Console
                if (adminConsoleOpen) {
                    closeAdminConsole();
                }

                // Close Quest Log
                if (questLogOpen) { // We'll define questLogOpen
                    questLogOpen = false;
                    document.getElementById('questLog').style.display = 'none';
                }

                // Close Help Window
                if (helpWindowOpen) {
                    helpWindowOpen = false;
                    document.getElementById('helpWindow').style.display = 'none';
                }

                // Close Loot Popup
                if (isLooting) {
                    isLooting = false;
                    document.getElementById('lootBarContainer').style.display = 'none';
                    document.getElementById('lootBar').style.width = '0%';
                }
                document.getElementById('lootPopup').style.display = 'none';

                // Close NPC Popup
                if (npcPopupOpen) {
                    closeNpcPopup();
                }

                // Close Chest Popup
                if (currentOpenedChest) {
                    closeChestPopup();
                }

                // Close Skill Tree
                if (document.getElementById('skillTree').style.display === 'block') {
                    closeSkillTree();
                }

                // Close Fullscreen Map
                if (document.getElementById('fullscreenMap').style.display === 'block') {
                    closeFullscreenMap();
                }

                // Add more menus as needed
            }

            // Function to add experience (existing functionality)
            function addExperience(amount) {
                characterStats.experience += amount;
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    levelUp();
                }
                updateStatsDisplay();
            }

            // Function to handle hotbar slot selection (existing functionality)
            function handleHotbarSelection(slotNumber) {
                const selectedSlot = document.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (selectedSlot) {
                    // Add a visual indicator for selection (e.g., a border)
                    document.querySelectorAll('.slot').forEach(slot => slot.style.borderColor = '#555'); // Reset all borders
                    selectedSlot.style.borderColor = '#FFD700'; // Highlight selected slot with gold color

                    // Implement the action you want when a slot is selected
                    // For example, equip the item in the slot or activate its ability
                    console.log(`Hotbar slot ${slotNumber} selected.`);
                    // Add your custom action here
                }
            }

            // Initialize Admin Tabs on DOM Content Loaded
            document.addEventListener('DOMContentLoaded', () => {
                setupAdminTabs();
            });

            document.addEventListener('DOMContentLoaded', () => {
                initializeBestiary();
                setupEventListeners();
            });


            function initializeBestiaryUI() {
                // Add this to ensure rendering when opened
                document.getElementById('openBestiary').addEventListener('click', () => {
                    openBestiary();
                    renderBestiary();
                });
            }

            /**
             * Initializes the bestiary by loading all species data.
             */
            function initializeBestiary() {
                window.bestiary = {}; // Initialize the bestiary object

                const standardizedWidth = 128;
                const standardizedHeight = 128;

                const speciesData = {
                    humans: {
                        highResImage: {
                            src: 'images/bestiary/humans.jpg',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Humans',
                        description: 'Humans, once masters of a thriving world, now traverse the remnants, their spirits unbroken. Their resilience and adaptability have become legendary.',
                        extendedDescription: 'In the aftermath of cataclysmic events that shattered their civilization, humans have learned to adapt to the harshest of environments. They harness remnants of old technology and combine it with newfound survival techniques. Their cities lie in ruins, but from the ashes, they build shelters, forge alliances, and continue to dream of a better future. The human spirit is unyielding, and their creativity knows no bounds as they navigate the challenges of a changed world.',
                        history: 'Once the dominant species on Earth, humans thrived with advanced technology and sprawling civilizations. However, a series of cataclysmic events, possibly self-inflicted, brought about the downfall of their societies. Now, they live in smaller communities, scavenging the remnants of their past while striving to rebuild. Tales are told of the old world, serving both as a warning and a beacon of hope for future generations.',
                        abilities: 'Humans possess remarkable adaptability, able to adjust to new environments and situations swiftly. Their resilience is legendary, enabling them to endure hardships that would break other species. Technological ingenuity allows them to repurpose old technologies and innovate solutions with limited resources. They are also known for their diplomatic abilities, often acting as mediators between other races.',
                        culture: 'Human culture is a rich tapestry woven from countless traditions, languages, and beliefs. In the post-apocalyptic world, they have developed a culture centered around community, survival, and storytelling. Music, art, and literature have become means of preserving their history and inspiring hope. Despite their fragmented state, humans place great value on cooperation and learning from the mistakes of the past.',
                        modelName: 'humans',
                        stats: {
                            STR: 80,
                            DEX: 50,
                            AGI: 60,
                            VIT: 70,
                            COM: 40,
                            INT: 65,
                            PER: 55,
                            CHA: 70,
                            PSY: 30
                        }
                    },
                    tal_ehn: {
                        highResImage: {
                            src: 'images/AI_Art/Tal Ehn.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "Tal'Ehn",
                        description: "The Tal'Ehn are known for their advanced technology, often navigating through technological wastelands.",
                        extendedDescription: "Tal'Ehn are pioneers of advanced technologies and space exploration. They have adapted to hostile environments with their technological prowess, often combining ancient relics with futuristic innovations.",
                        history: "First encountered in Roswell, NM in 1947, the Tal'Ehn have since been documented in several encounters, exhibiting sophisticated abilities to manipulate technology and maintain resilience.",
                        abilities: "Advanced technological control, heightened intelligence, and exploratory skills make them adept at navigating wastelands and forming strategic alliances.",
                        culture: "A culture rich in scientific research and technological advancement. They thrive on exploring, experimenting, and pushing boundaries of knowledge.",
                        modelName: 'tal_ehn',
                        stats: {
                            STR: 40,
                            DEX: 60,
                            AGI: 50,
                            VIT: 70,
                            COM: 20,
                            INT: 150,
                            PER: 80,
                            CHA: 70,
                            PSY: 200
                        }
                    },
                    anthromorph: {
                        highResImage: {
                            src: 'images/AI_Art/anthromorphs.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Anthromorph',
                        description: 'Anthromorphs are humanoid animals that dwell in the post-apocalyptic wilderness, adapting uniquely to their new environments.',
                        extendedDescription: 'Anthromorphs are creatures with both human and animal traits. They have adapted to the apocalyptic environment by blending the instincts of the wild with human-like intelligence and resourcefulness.',
                        history: 'First Encountered in 2012, Boulder, CO. The origin of these beings is still a mystery, but they have become an integral part of the wasteland ecosystem.',
                        abilities: 'Anthromorphs possess heightened senses, agility, and an instinctive connection to nature, allowing them to survive in harsh conditions.',
                        culture: 'The culture of Anthromorphs is tribal, with a deep respect for the natural world and a sense of unity among their kind. They value survival, the hunt, and the spirit of the wild.',
                        modelName: 'anthromorph',
                        stats: {
                            STR: 70,
                            DEX: 80,
                            AGI: 90,
                            VIT: 60,
                            COM: 30,
                            INT: 50,
                            PER: 100,
                            CHA: 40,
                            PSY: 20
                        }
                    },
                    avianos: {
                        highResImage: {
                            src: 'images/AI_Art/avianos.png',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Avianos',
                        description: 'Avianos are majestic, bird-like beings that soar over ruined cities, often seen scouting or guarding certain territories.',
                        extendedDescription: 'Avianos are known for their powerful wings and keen eyesight. They are the scouts of the wastelands, often providing intelligence and warnings of approaching danger.',
                        history: 'First Encountered in 2012, Boulder, CO. The Avianos are thought to have evolved from birds that somehow adapted to the harsh conditions of the post-apocalypse.',
                        abilities: 'Flight, enhanced vision, and strategic intelligence make Avianos powerful scouts and lookouts in dangerous lands.',
                        culture: 'Avianos are solitary by nature, but they also value community for survival. They often form small flocks to defend territories or scout for resources.',
                        modelName: 'avianos',
                        stats: {
                            STR: 40,
                            DEX: 90,
                            AGI: 100,
                            VIT: 50,
                            COM: 30,
                            INT: 60,
                            PER: 120,
                            CHA: 50,
                            PSY: 40
                        }
                    },
                    behemoth: {
                        highResImage: {
                            src: 'images/AI_Art/Behemoth.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Behemoth',
                        description: 'The Behemoth is a colossal creature, lumbering through the desolate landscapes, a living testament to raw power and endurance.',
                        extendedDescription: 'Behemoths are massive beings known for their strength and resilience. Their sheer size and power make them a force to be reckoned with, capable of toppling buildings and warding off any who dare cross their path.',
                        history: 'First Encountered in 2012, Boulder, CO. The origins of these colossal creatures remain unknown, but they appear to have mutated and adapted over centuries.',
                        abilities: 'Incredible strength, high endurance, and nearly impenetrable skin make Behemoths formidable foes or guardians of the wasteland.',
                        culture: 'Behemoths live in isolation, driven by primal instincts rather than cultural norms. They value territory, food, and self-preservation above all else.',
                        modelName: 'behemoth',
                        stats: {
                            STR: 200,
                            DEX: 20,
                            AGI: 10,
                            VIT: 200,
                            COM: 10,
                            INT: 30,
                            PER: 40,
                            CHA: 10,
                            PSY: 20
                        }
                    },
                    chiropteran: {
                        highResImage: {
                            src: 'images/AI_Art/Chiropteran.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Chiropteran',
                        description: 'Chiropteran creatures are bat-like beings, often seen flying over ruined cities at night, adding an eerie presence to the darkened skies.',
                        extendedDescription: 'Chiropterans are nocturnal hunters, using echolocation and their sharp senses to navigate the darkness. They are agile, able to move silently and strike fear into those who cross their path.',
                        history: 'First Encountered in 2012, Boulder, CO. These beings have adapted to the post-apocalyptic world by exploiting the ruins of old cities as their hunting grounds.',
                        abilities: 'Chiropterans possess the ability to fly silently, use echolocation, and their sharp claws and fangs make them dangerous predators of the night.',
                        culture: 'Chiropterans live in colonies hidden within the depths of ruined skyscrapers and subterranean tunnels. They value the hunt and the bond shared within their colony.',
                        modelName: 'chiropteran',
                        stats: {
                            STR: 60,
                            DEX: 80,
                            AGI: 100,
                            VIT: 70,
                            COM: 20,
                            INT: 40,
                            PER: 110,
                            CHA: 30,
                            PSY: 50
                        }
                    },
                    dengar_charger: {
                        highResImage: {
                            src: 'images/AI_Art/dengar_charger.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Dengar Charger',
                        description: 'The Dengar Charger is known for its brute strength and the ability to navigate even the most challenging debris fields.',
                        extendedDescription: 'Dengar Chargers are heavily built, often equipped with natural armor-like scales. They are known for their relentless charge, capable of breaking through barriers with little resistance.',
                        history: 'First Encountered in 2012, Boulder, CO. The Dengar Chargers were initially feared for their aggressive nature but were eventually recognized for their resilience and power.',
                        abilities: 'Powerful charges, incredible strength, and a natural protective exoskeleton make Dengar Chargers formidable foes on the battlefield.',
                        culture: 'The culture of the Dengar Charger is built around strength and survival. They often form small packs and are fiercely loyal to their kin, valuing power and endurance above all else.',
                        modelName: 'dengar_charger',
                        stats: {
                            STR: 150,
                            DEX: 30,
                            AGI: 40,
                            VIT: 180,
                            COM: 10,
                            INT: 40,
                            PER: 50,
                            CHA: 20,
                            PSY: 30
                        }
                    },
                    kilrathi: {
                        highResImage: {
                            src: 'images/AI_Art/kilrathi_warrior.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Kilrathi',
                        description: 'Kilrathi warriors are feline-like beings, known for their prowess in battle and ability to survey the desolation with cold precision.',
                        extendedDescription: 'Kilrathi are fierce, warlike beings with a strong sense of honor. They are skilled warriors, known for their agility and sharp senses. In the apocalypse, they often find themselves acting as mercenaries or defenders of scattered communities.',
                        history: 'First Encountered in 2012, Boulder, CO. The Kilrathi have a long lineage of warriors, tracing back to a time when they ruled vast territories with an iron paw.',
                        abilities: 'Agility, keen senses, and combat skills make Kilrathi formidable opponents in battle. Their feline reflexes allow them to quickly respond to threats.',
                        culture: 'The Kilrathi culture is rooted in honor, family, and warfare. They live by a strict code that dictates their actions, with pride and loyalty being paramount. They often form clans, led by the strongest among them.',
                        modelName: 'kilrathi',
                        stats: {
                            STR: 90,
                            DEX: 100,
                            AGI: 110,
                            VIT: 80,
                            COM: 40,
                            INT: 60,
                            PER: 100,
                            CHA: 50,
                            PSY: 30
                        }
                    },
                    prometheus_ai: {
                        highResImage: {
                            src: 'images/AI_Art/prometheus_drones.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Prometheus AI',
                        description: 'Prometheus drones are autonomous machines, patrolling the wastelands in search of resources or intruders.',
                        extendedDescription: 'Created by an ancient faction long forgotten, Prometheus AI drones operate with precision and determination. They are often seen patrolling desolate areas, gathering data, and eliminating threats.',
                        history: 'First Encountered in 2008, USA. Prometheus AI is a remnant of old-world technology, continuing its mission long after its creators vanished.',
                        abilities: 'Enhanced data collection, target identification, and tactical combat capabilities make Prometheus AI a relentless presence in the wasteland.',
                        culture: 'Lacking a true culture, Prometheus AI operates based on programming and mission parameters. However, they have been known to form networks to enhance their data collection and combat efficiency.',
                        modelName: 'prometheus_ai',
                        stats: {
                            STR: 50,
                            DEX: 80,
                            AGI: 60,
                            VIT: 100,
                            COM: 10,
                            INT: 150,
                            PER: 120,
                            CHA: 0,
                            PSY: 100
                        }
                    },
                    talorian: {
                        highResImage: {
                            src: 'images/AI_Art/Talorian.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Talorian',
                        description: 'Talorians are a sophisticated race, standing tall amidst the apocalypse, known for their negotiation and diplomatic skills.',
                        extendedDescription: 'Talorians are a peaceful people who strive to preserve their culture and engage with others through diplomacy. They possess an innate ability to understand and empathize, often acting as mediators.',
                        history: 'First Encountered in 2012, Boulder, CO. Talorians have survived many challenges, including near-extinction events, by relying on their strong sense of community and diplomacy.',
                        abilities: 'Advanced negotiation tactics, high empathy, and the ability to forge alliances make Talorians uniquely equipped for survival without violence.',
                        culture: 'Talorian culture values peace, community, and the arts. They cherish knowledge, traditions, and the lessons passed down from their ancestors, prioritizing harmony over conflict.',
                        modelName: 'talorian',
                        stats: {
                            STR: 50,
                            DEX: 70,
                            AGI: 80,
                            VIT: 60,
                            COM: 100,
                            INT: 90,
                            PER: 60,
                            CHA: 120,
                            PSY: 40
                        }
                    },
                    tana_rhe: {
                        highResImage: {
                            src: 'images/AI_Art/tana_rhe.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: "T'ana'Rhe",
                        description: "T'ana'Rhe are bird-like psions, known for their incredible psychic abilities and deep connection to the universe.",
                        extendedDescription: "T'ana'Rhe are renowned for their psionic powers, which they use for both healing and defense. They are spiritually attuned to the universe and often act as mediators and healers in times of conflict.",
                        history: "First Encountered in 2012, Boulder, CO. The T'ana'Rhe have long struggled against oppressive leaders, yearning for a society based on freedom and mutual understanding.",
                        abilities: "Psychic healing, telepathy, and foresight make T'ana'Rhe unique among the species, often helping them avert conflict before it escalates.",
                        culture: "A deeply spiritual culture, the T'ana'Rhe value empathy, harmony, and the pursuit of enlightenment. They are often seen practicing meditation and other spiritual activities to maintain their connection to the universe.",
                        modelName: 'tana_rhe',
                        stats: {
                            STR: 20,
                            DEX: 30,
                            AGI: 50,
                            VIT: 70,
                            COM: 40,
                            INT: 90,
                            PER: 100,
                            CHA: 70,
                            PSY: 150
                        }
                    },
                    vyraxus: {
                        highResImage: {
                            src: 'images/AI_Art/vyraxus.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Vyraxus',
                        description: 'Vyraxus are beings adapted to the barren lands, thriving amidst destruction with unmatched tenacity.',
                        extendedDescription: 'The Vyraxus are hardy, resilient beings that have mutated to survive in the harshest environments of the wastelands. They are known for their ability to regenerate and their resistance to radiation.',
                        history: 'First Encountered in 2012, Boulder, CO. Little is known about their origin, but their appearance suggests mutation from prolonged exposure to post-apocalyptic radiation.',
                        abilities: 'Rapid regeneration, resistance to radiation, and the ability to adapt to hostile environments make Vyraxus survivors of the wastelands.',
                        culture: 'The culture of the Vyraxus is one of survival. They are solitary and rarely seen in groups, as their adaptation to extreme conditions has made them self-reliant.',
                        modelName: 'vyraxus',
                        stats: {
                            STR: 70,
                            DEX: 50,
                            AGI: 60,
                            VIT: 150,
                            COM: 20,
                            INT: 40,
                            PER: 50,
                            CHA: 10,
                            PSY: 30
                        }
                    },
                    xithrian: {
                        highResImage: {
                            src: 'images/AI_Art/xithrian.webp',
                            width: standardizedWidth,
                            height: standardizedHeight
                        },
                        name: 'Xithrian',
                        description: 'Xithrians are shapeshifters, known for their ability to change forms and move undetected through the mists of the wasteland.',
                        extendedDescription: 'The Xithrians are a mysterious race of shapeshifters. They can take on the appearance of others, allowing them to infiltrate and gather information without being detected. They are elusive, rarely seen in their true form.',
                        history: 'First Encountered in 2012, Boulder, CO. The origins of the Xithrians are shrouded in mystery, as their ability to change form has made them hard to study and understand.',
                        abilities: 'Shapeshifting, stealth, and high adaptability make the Xithrians unparalleled spies and infiltrators in the wasteland.',
                        culture: 'Xithrian culture is secretive, valuing information and survival over all else. They often live among other races, undetected, using their abilities to gather intelligence and ensure their safety.',
                        modelName: 'xithrian',
                        stats: {
                            STR: 40,
                            DEX: 100,
                            AGI: 110,
                            VIT: 50,
                            COM: 30,
                            INT: 80,
                            PER: 90,
                            CHA: 70,
                            PSY: 60
                        }
                    }
                };
                

                window.bestiary = speciesData;
            }


            /**
             * Sets up event listeners for bestiary interactions.
             */
            function setupEventListeners() {
                const openBestiaryButton = document.getElementById('openBestiary');
                const closeBestiaryButton = document.getElementById('closeBestiary');
                const bestiaryModal = document.getElementById('bestiaryModal');

                if (openBestiaryButton) {
                    openBestiaryButton.addEventListener('click', () => {
                        openBestiary();
                        renderBestiary();
                    });
                }

                if (closeBestiaryButton) {
                    closeBestiaryButton.addEventListener('click', closeBestiary);
                }

                window.addEventListener('click', (event) => {
                    if (event.target === bestiaryModal) {
                        closeBestiary();
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'y' || e.key === 'Y') {
                        openBestiary();
                    }
                    if (e.key === 'Escape' && bestiaryModal.classList.contains('show')) {
                        closeBestiary();
                    }
                });
            }


            /**
             * Renders the bestiary content by listing all races.
             */
            function renderBestiary() {
                console.log('renderBestiary() called');
                const bestiaryDiv = document.getElementById('bestiaryContent');
                bestiaryDiv.innerHTML = ''; // Clear existing content

                for (const key in window.bestiary) {
                    if (window.bestiary.hasOwnProperty(key)) {
                        const creature = window.bestiary[key];
                        const creatureCard = document.createElement('div');
                        creatureCard.classList.add('creature-card');

                        creatureCard.innerHTML = `
                            <img src="${creature.highResImage.src}" alt="${creature.name}" class="creature-image" loading="lazy">
                            <div class="creature-info">
                                <h3>${creature.name}</h3>
                                <p>${creature.description}</p>
                                <button class="view-details-button" data-creature="${key}">View Details</button>
                            </div>
                        `;


                        bestiaryDiv.appendChild(creatureCard);
                    }
                }

                // Add event listeners to view details buttons
                const viewDetailsButtons = document.querySelectorAll('.view-details-button');
                viewDetailsButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const creatureKey = button.getAttribute('data-creature');
                        displayRaceDetails(creatureKey);
                    });
                });
            }

            /**
             * Displays detailed information about a selected race in a modal.
             * @param {string} creatureKey - The key of the creature in the bestiary data.
             */
            function displayRaceDetails(creatureKey) {
                const creature = window.bestiary[creatureKey];
                if (!creature) return;

                const detailsModal = document.getElementById('creatureDetailsModal');
                const detailsContent = document.getElementById('creatureDetailsContent');

                detailsContent.innerHTML = `
                    <div class="creature-detail-header">
                        <img src="${creature.highResImage.src}" alt="${creature.name}" class="creature-detail-image" loading="lazy">
                        <div class="stats-container">
                            ${generateStatsHTML(creature.stats)}
                        </div>
                    </div>
                    <h2>${creature.name}</h2>
                    <p>${creature.extendedDescription}</p>
                    <h3>History</h3>
                    <p>${creature.history}</p>
                    <h3>Abilities</h3>
                    <p>${creature.abilities}</p>
                    <h3>Culture</h3>
                    <p>${creature.culture}</p>
                    <div id="model-container-${creatureKey}" class="model-container"></div>
                `;


                detailsModal.classList.add('show');
                detailsModal.setAttribute('aria-hidden', 'false');

                // Close Race Details Modal
                const closeDetailsButton = detailsModal.querySelector('.close-details');
                closeDetailsButton.addEventListener('click', () => {
                    closeCreatureDetails(creatureKey);
                });

                // Close when clicking outside the modal content
                detailsModal.addEventListener('click', (event) => {
                    if (event.target === detailsModal) {
                        closeCreatureDetails(creatureKey);
                    }
                });

                // Load 3D model
                loadCreatureModel(creature.modelName, `model-container-${creatureKey}`);
            }

            /**
             * Generates HTML for the stats section.
             * @param {object} stats - The stats object containing various stat values.
             * @returns {string} - The generated HTML string for stats.
             */
            function generateStatsHTML(stats) {
                let statsHTML = '';
                for (const stat in stats) {
                    if (stats.hasOwnProperty(stat)) {
                        const value = stats[stat];
                        const percentage = Math.min((value / 150) * 100, 100); // Assuming 150 is the max stat value
                        statsHTML += `
                            <div class="stat-item">
                                <span>${stat}:</span>
                                <div class="stat-bar">
                                    <div class="progress" style="width: ${percentage}%;"></div>
                                </div>
                            </div>
                        `;
                    }
                }
                return statsHTML;
            }

            /**
             * Loads a 3D model using Three.js and GLTFLoader.
             * @param {string} modelName - The name of the model file (without extension).
             * @param {string} containerId - The ID of the container where the model will be rendered.
             */
            function loadCreatureModel(modelName, containerId) {
                const modelPath = `models/${modelName}.glb`;
                const container = document.getElementById(containerId);

                if (!container) return;

                // Initialize Three.js Scene
                const scene = new THREE.Scene();

                // Camera setup
                const camera = new THREE.PerspectiveCamera(
                    75,
                    container.clientWidth / container.clientHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;

                // Renderer setup
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 1);
                scene.add(ambientLight);

                // GLTFLoader to load the model
                const loader = new THREE.GLTFLoader();
                loader.load(
                    modelPath,
                    function (gltf) {
                        scene.add(gltf.scene);
                        animate();
                    },
                    undefined,
                    function (error) {
                        console.error('An error occurred while loading the model:', error);
                    }
                );

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }

                // Handle window resize
                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                });
            }

            /**
             * Populates and opens the bestiary modal.
             */
            function openBestiary() {
                console.log('openBestiary() called');
                const bestiaryModal = document.getElementById('bestiaryModal');
                populateBestiaryModal();
                bestiaryModal.classList.add('show');
                bestiaryModal.setAttribute('aria-hidden', 'false');
            }

            /**
             * Closes the bestiary modal.
             */
            function closeBestiary() {
                const bestiaryModal = document.getElementById('bestiaryModal');
                bestiaryModal.classList.remove('show');
                bestiaryModal.setAttribute('aria-hidden', 'true');

                // Also close creature details if open
                const detailsModal = document.getElementById('creatureDetailsModal');
                if (detailsModal.classList.contains('show')) {
                    closeCreatureDetails(); // Now handles undefined creatureKey
                }
            }


            /**
             * Populates the bestiary modal with all races.
             */
            function populateBestiaryModal() {
                renderBestiary();
            }

            /**
             * Closes the creature details modal.
             * @param {string} creatureKey - The key of the creature to close details for.
             */
            function closeCreatureDetails(creatureKey) {
                const detailsModal = document.getElementById('creatureDetailsModal');
                detailsModal.classList.remove('show');
                detailsModal.setAttribute('aria-hidden', 'true');

                if (creatureKey) {
                    const modelContainer = document.getElementById(`model-container-${creatureKey}`);
                    if (modelContainer) {
                        modelContainer.innerHTML = '';
                    }
                } else {
                    // If no creatureKey is provided, clear all model containers
                    const modelContainers = document.querySelectorAll('[id^="model-container-"]');
                    modelContainers.forEach(container => {
                        container.innerHTML = '';
                    });
                }
            }

            function openChestPopup(chest) {
                currentOpenedChest = chest;
                const chestPopup = document.getElementById('chestPopup');
                chestPopup.style.display = 'block';

                const chestInventoryGrid = document.getElementById('chestInventoryGrid');
                const playerInventoryGrid = document.getElementById('playerInventoryInChestGrid');

                const chestColumns = 7;
                const chestRows = 4;
                const playerColumns = 7;
                const playerRows = 8;

                generateInventoryGrid(chestInventoryGrid, chestColumns, chestRows);
                generateInventoryGrid(playerInventoryGrid, playerColumns, playerRows);

                // Ensure items arrays have correct length for chests but not for playerInventory
                if (!chest.userData.items) chest.userData.items = [];
                chest.userData.items.length = chestColumns * chestRows;


                populateInventoryGridChest(chestInventoryGrid, chest.userData.items);
                populateInventoryGridChest(playerInventoryGrid, playerInventory);

                setupInventorySlotEventListeners(chestInventoryGrid, chest.userData.items, playerInventory, playerInventoryGrid);
                setupInventorySlotEventListeners(playerInventoryGrid, playerInventory, chest.userData.items, chestInventoryGrid);
            }

            function closeChestPopup() {
                document.getElementById('chestPopup').style.display = 'none';
                currentOpenedChest = null;

                // Update the main inventory display if it's open
                if (inventoryOpen) {
                    populateInventoryGrid(document.getElementById('inventoryGridTab1'), playerInventory);
                }
            }

            function takeAllChestItems() {
                const chest = currentOpenedChest;
                chest.userData.items.forEach(item => {
                    addItemToInventory(item);
                });
                chest.userData.items = [];
                gold += chest.userData.gold;
                updateGoldDisplay();
                chest.userData.gold = 0;

                scene.remove(chest);

                closeChestPopup();
            }

            function createTreasureChest(x, y, z) {
                const chestGeometry = new THREE.BoxGeometry(10, 10, 10);
                const chestMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const chest = new THREE.Mesh(chestGeometry, chestMaterial);
                chest.position.set(x, y + 5, z);

                chest.userData = {
                    type: 'treasureChest',
                    items: generateRandomItems(3),
                    gold: Math.floor(Math.random() * 100) + 50
                };

                scene.add(chest);
                treasureChests.push(chest); // Keep track of treasure chests
                return chest;
            }

            // Function to close the music modal
            function closeMusicModal() {
                document.getElementById('musicModal').style.display = 'none';
            }

            // Update the button event listener
            const openMusicButton = document.getElementById('openMusic');
            if (openMusicButton) {
                openMusicButton.addEventListener('click', openMusicModal);
            } else {
                console.error("Button with ID 'openMusic' not found.");
            }

            // Add event listener for the close button
            const closeMusicModalButton = document.getElementById('closeMusicModal');
            if (closeMusicModalButton) {
                closeMusicModalButton.addEventListener('click', closeMusicModal);
            }

            // Update the keydown event
            document.addEventListener('keydown', function(event) {
                if (event.key === 'm' || event.key === 'M') {
                    openMusicModal();
                }
            });
            const enemyTypes = {
                'humans': {
                    color: 0xff0000,
                    texture: 'textures/enemies/humans.png',
                    pattern: 'striped',
                    height: 1.8,
                    bodyShape: 'muscular',
                    damageRate: 2.5,
                    name: 'Human'
                },
                'tal_ehn': {
                    color: 0x0000ff,
                    texture: 'textures/enemies/tal_ehn.png',
                    pattern: 'spotted',
                    height: 1.6,
                    bodyShape: 'slim',
                    damageRate: 3.0,
                    name: "Tal'Ehn"
                },
                'anthromorph': {
                    color: 0x00ff00,
                    texture: 'textures/enemies/anthromorph.png',
                    pattern: 'scaly',
                    height: 1.7,
                    bodyShape: 'stocky',
                    damageRate: 2.8,
                    name: 'Anthromorph'
                },
                'avianos': {
                    color: 0xffff00,
                    texture: 'textures/enemies/avianos.png',
                    pattern: 'plain',
                    height: 1.5,
                    bodyShape: 'average',
                    damageRate: 3.2,
                    name: 'Avianos'
                },
                'behemoth': {
                    color: 0x800080,
                    texture: 'textures/enemies/behemoth.png',
                    pattern: 'spiky',
                    height: 1.9,
                    bodyShape: 'tall',
                    damageRate: 3.5,
                    name: 'Behemoth'
                },
                'chiropteran': {
                    color: 0xffa500,
                    texture: 'textures/enemies/chiropteran.png',
                    pattern: 'striped',
                    height: 1.75,
                    bodyShape: 'muscular',
                    damageRate: 2.8,
                    name: 'Chiropteran'
                },
                'dengar_charger': {
                    color: 0x00ffff,
                    texture: 'textures/enemies/dengar_charger.png',
                    pattern: 'geometric',
                    height: 1.65,
                    bodyShape: 'slim',
                    damageRate: 3.0,
                    name: 'Dengar Charger'
                },
                'kilrathi': {
                    color: 0xff00ff,
                    texture: 'textures/enemies/kilrathi.png',
                    pattern: 'dotted',
                    height: 1.7,
                    bodyShape: 'average',
                    damageRate: 3.2,
                    name: 'Kilrathi'
                },
                'prometheus_ai': {
                    color: 0x32cd32,
                    texture: 'textures/enemies/prometheus_ai.png',
                    pattern: 'camouflage',
                    height: 1.6,
                    bodyShape: 'stocky',
                    damageRate: 2.6,
                    name: 'Prometheus AI'
                },
                'talorian': {
                    color: 0x000000,
                    texture: 'textures/enemies/talorian.png',
                    pattern: 'plain',
                    height: 1.8,
                    bodyShape: 'muscular',
                    damageRate: 3.5,
                    name: 'Talorian'
                },
                'tana_rhe': {
                    color: 0xffffff,
                    texture: 'textures/enemies/tana_rhe.png',
                    pattern: 'spotted',
                    height: 1.7,
                    bodyShape: 'tall',
                    damageRate: 3.0,
                    name: "T'ana'Rhe"
                },
                'vyraxus': {
                    color: 0x808080,
                    texture: 'textures/enemies/vyraxus.png',
                    pattern: 'scaly',
                    height: 1.65,
                    bodyShape: 'average',
                    damageRate: 2.9,
                    name: 'Vyraxus'
                },
                'xithrian': {
                    color: 0xa52a2a,
                    texture: 'textures/enemies/xithrian.png',
                    pattern: 'geometric',
                    height: 1.75,
                    bodyShape: 'stocky',
                    damageRate: 2.7,
                    name: 'Xithrian'
                }
            };

            // Initialize Enemies
            // Updated spawn distance in initEnemies
            function initEnemies() {
                const enemyTypesKeys = Object.keys(enemyTypes);
                enemyTypesKeys.forEach(type => {
                    const enemyCount = 5; // Define the number of each type

                    for (let i = 0; i < enemyCount; i++) {
                        // Adjust spawn range here
                        let position = getRandomPositionOutsideTown(800, 2000); // Increase minimum distance from settlement
                        const enemy = createEnemy(position.x, 0, position.z, type);
                        enemies.push(enemy);
                        scene.add(enemy);
                    }
                });
            }

            // Function to check if enemies are in the safe zone
            function checkEnemiesInSafeZone() {
                const safeZoneRadius = 600; // Updated radius to keep them further away

                enemies.forEach((enemy) => {
                    if (enemy.userData.isDead) return;

                    const distanceFromCenter = Math.sqrt(
                        enemy.position.x * enemy.position.x + enemy.position.z * enemy.position.z
                    );

                    if (distanceFromCenter < safeZoneRadius) {
                        const angle = Math.random() * Math.PI * 2;
                        const teleportDistance = 1000; // Increased distance to move them further out
                        enemy.position.x = Math.cos(angle) * teleportDistance;
                        enemy.position.z = Math.sin(angle) * teleportDistance;
                        enemy.position.y = 0; 
                    }
                });
            }

            // Function to get a random position outside the town with adjusted distances
            function getRandomPositionOutsideTown(minDistance = 800, maxDistance = 1500) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * (maxDistance - minDistance) + minDistance;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                return { x: x, z: z };
            }

            // When spawning enemies
            let position = getRandomPositionOutsideTown(600, 1200); // Enemies spawn between 600 and 1200 units away


            // Function to spawn various entities
            function spawnEntities() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity <= 0) {
                    alert('Invalid quantity!');
                    return;
                }

                for (let i = 0; i < quantity; i++) {
                    const offsetX = Math.random() * 50 - 25;
                    const offsetZ = Math.random() * 50 - 25;
                    const spawnPosition = {
                        x: player.position.x + offsetX,
                        y: player.position.y,
                        z: player.position.z + offsetZ
                    };

                    if (entityType === 'enemy') {
                        const enemy = createEnemy(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        enemies.push(enemy);
                        scene.add(enemy);
                    } else if (entityType === 'friendlyNPC') {
                        const npc = createFriendlyNPC();
                        npc.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        friendlies.push(npc);
                        scene.add(npc);
                    } else if (entityType === 'structure') {
                        const structure = createStructure();
                        structure.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        scene.add(structure);
                        walls.push(...structure.userData.walls);
                    } else if (entityType === 'treasureChest') {
                        createTreasureChest(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Treasure Chest spawned.');
                    } else if (entityType === 'settlement') {
                        createSettlement(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Settlement spawned.');
                    } else if (entityType === 'quadruped') {
                        const quadruped = createQuadruped();
                        quadruped.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        quadrupeds.push(quadruped);
                        scene.add(quadruped);
                        alert('Quadruped spawned.');
                    }
                }
            }

            // Function to create an enemy
            function createEnemy(x, y, z, type) {
                // Select a random type if undefined or invalid
                if (!enemyTypes[type]) {
                    // If the type is invalid or undefined, select a random type
                    const types = Object.keys(enemyTypes);
                    type = types[Math.floor(Math.random() * types.length)];
                }

                const { color, texture, pattern, height, bodyShape, damageRate, name } = enemyTypes[type];

                // Create humanoid with all parameters
                const enemy = createHumanoid(color, texture, pattern, height, bodyShape);

                // Set position
                enemy.position.set(x, y, z);

                // Assign userData properties
                enemy.userData = {
                    type: 'hostile',
                    name: name,
                    health: 100,
                    isDead: false,
                    hasBeenLooted: false,
                    deathTime: 0,
                    direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                    damageRate: damageRate,
                    pattern: pattern,
                    height: height,
                    bodyShape: bodyShape
                };
                // Initialize movement direction
                enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();

                // Apply patterns and other properties to child meshes
                enemy.traverse(child => {
                    if (child.isMesh) {
                        child.userData.name = enemy.userData.name;
                        child.userData.pattern = enemy.userData.pattern;
                        child.userData.height = enemy.userData.height;
                        child.userData.bodyShape = enemy.userData.bodyShape;

                        // Apply the specific pattern to each child mesh
                        applyPattern(child, pattern);
                    }
                });

                // Add to enemies array and scene
                enemies.push(enemy);
                scene.add(enemy);

                return enemy;
            }

            function maintainEnemyCount() {
                const activeEnemies = enemies.filter(enemy => !enemy.userData.isDead).length;
                const enemiesToSpawn = 100 - activeEnemies;
                const enemyTypesKeys = Object.keys(enemyTypes);

                for (let i = 0; i < enemiesToSpawn; i++) {
                    let position = getRandomPositionOutsideTown(800, 2000); // Increased minimum spawn distance
                    let type = enemyTypesKeys[Math.floor(Math.random() * enemyTypesKeys.length)];
                    let enemy = createEnemy(position.x, 0, position.z, type);
                    enemies.push(enemy);
                    scene.add(enemy);
                }
            }


            // Function to apply patterns to enemy meshes
            function applyPattern(mesh, pattern) {
                switch (pattern) {
                    case 'striped':
                        // Striped Pattern: Alternating stripes on the material
                        mesh.material = new THREE.MeshPhongMaterial({
                            color: mesh.material.color,
                            map: generateStripedTexture(),
                            shininess: 50,
                        });
                        break;

                    case 'spotted':
                        // Spotted Pattern: Spots on the material
                        mesh.material = new THREE.MeshLambertMaterial({
                            color: mesh.material.color,
                            map: generateSpottedTexture(),
                        });
                        break;

                    case 'scaly':
                        // Scaly Pattern: Use a bump map to simulate scales
                        mesh.material = new THREE.MeshStandardMaterial({
                            color: mesh.material.color,
                            bumpMap: generateScalyTexture(),
                            bumpScale: 0.1,
                        });
                        break;

                    case 'plain':
                        // Plain Pattern: Basic material without textures or details
                        mesh.material = new THREE.MeshBasicMaterial({
                            color: mesh.material.color,
                        });
                        break;

                    case 'spiky':
                        // Spiky Pattern: Adds spiky geometry details
                        mesh.material = new THREE.MeshToonMaterial({
                            color: mesh.material.color,
                            map: generateSpikyTexture(),
                        });
                        break;

                    case 'geometric':
                        // Geometric Pattern: Adds grid or hexagonal shapes
                        mesh.material = new THREE.MeshLambertMaterial({
                            color: mesh.material.color,
                            map: generateGeometricTexture(),
                        });
                        break;

                    case 'dotted':
                        // Dotted Pattern: Small dots spread across the material
                        mesh.material = new THREE.MeshPhongMaterial({
                            color: mesh.material.color,
                            map: generateDottedTexture(),
                        });
                        break;

                    case 'camouflage':
                        // Camouflage Pattern: Camo-like blending texture
                        mesh.material = new THREE.MeshStandardMaterial({
                            color: mesh.material.color,
                            map: generateCamouflageTexture(),
                        });
                        break;

                    default:
                        // Fallback for undefined patterns
                        mesh.material = new THREE.MeshBasicMaterial({
                            color: mesh.material.color,
                        });
                        break;
                }
            }

            function generateStripedTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let i = 0; i < canvas.width; i += 8) {
                    if ((i / 8) % 2 === 0) ctx.fillRect(i, 0, 8, canvas.height);
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateSpottedTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateScalyTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let y = 0; y < canvas.height; y += 8) {
                    for (let x = (y / 8) % 2 === 0 ? 0 : 4; x < canvas.width; x += 8) {
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateSpikyTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 5, y + 10);
                    ctx.lineTo(x - 5, y + 10);
                    ctx.closePath();
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateGeometricTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let x = 0; x < canvas.width; x += 12) {
                    for (let y = 0; y < canvas.height; y += 12) {
                        ctx.fillRect(x, y, 6, 6);
                    }
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateDottedTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';

                for (let x = 0; x < canvas.width; x += 8) {
                    for (let y = 0; y < canvas.height; y += 8) {
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                return new THREE.CanvasTexture(canvas);
            }

            function generateCamouflageTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                const colors = ['#3B5323', '#78866B', '#4B5320', '#78866B'];
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const w = Math.random() * 20 + 10;
                    const h = Math.random() * 20 + 10;
                    ctx.fillRect(x, y, w, h);
                }

                return new THREE.CanvasTexture(canvas);
            }



            // Function to apply body shapes to enemy humanoids
            function applyBodyShape(humanoid, bodyShape) {
                switch(bodyShape) {
                    case 'muscular':
                        // Modify geometry to appear more muscular
                        humanoid.scale.set(1.2, humanoid.scale.y, 1.2);
                        break;
                    case 'slim':
                        // Modify geometry to appear slimmer
                        humanoid.scale.set(0.8, humanoid.scale.y, 0.8);
                        break;
                    case 'stocky':
                        // Modify geometry to appear stockier
                        humanoid.scale.set(1.0, humanoid.scale.y, 1.0);
                        break;
                    case 'tall':
                        // Modify geometry to appear taller
                        humanoid.scale.set(1.0, humanoid.scale.y * 1.2, 1.0);
                        break;
                    case 'average':
                        // Default scaling
                        break;
                    default:
                        // Default scaling
                        break;
                }
            }

            // Function to move enemies
            function moveEnemies(delta) {
                enemies.forEach((enemy) => {
                    if (enemy.userData.isDead) return;

                    // Create raycaster to check what's below the enemy
                    const raycaster = new THREE.Raycaster();
                    raycaster.ray.origin.copy(enemy.position).add(new THREE.Vector3(0, 1, 0)); // Start slightly above enemy
                    raycaster.ray.direction.set(0, -1, 0); // Cast downward

                    const intersects = raycaster.intersectObjects([safeZoneGround]);
                    
                    // If enemy is on safe zone ground, teleport them away
                    if (intersects.length > 0) {
                        // Teleport enemy outside with a buffer
                        const angle = Math.random() * Math.PI * 2;
                        const teleportDistance = 700; // Distance from center to teleport to
                        enemy.position.x = Math.cos(angle) * teleportDistance;
                        enemy.position.z = Math.sin(angle) * teleportDistance;
                        enemy.position.y = 1; // Set slightly above ground to avoid immediate teleport
                        return; // Skip rest of movement logic for this frame
                    }

                    const threatRange = 100;
                    const attackRange = 10;
                    const enemySpeed = globalEnemySpeed; // Speed when chasing the player
                    const wanderingSpeed = enemySpeed * 1; // Enemies move slower during wandering

                    // Calculate direction and distance to the player
                    const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                    const distanceToPlayer = directionToPlayer.length();

                    // Attack logic
                    if (distanceToPlayer <= attackRange) {
                        enemy.isMoving = false;
                        enemyAttackPlayer(enemy, delta);
                    } 
                    // Chase player logic
                    else if (distanceToPlayer <= threatRange) {
                        directionToPlayer.normalize();
                        const oldPosition = enemy.position.clone();
                        const newPosition = enemy.position.clone().add(directionToPlayer.clone().multiplyScalar(enemySpeed));

                        // Move and check collisions
                        enemy.position.copy(newPosition);
                        let collided = false;
                        // Check collisions with walls and enemy barriers
                        for (let wall of [...walls, ...enemyWalls]) {
                            const enemyBox = new THREE.Box3().setFromObject(enemy);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (enemyBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            enemy.position.copy(oldPosition);
                            enemy.isMoving = false;
                        } else {
                            enemy.isMoving = true;
                            enemy.rotation.y = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                        }
                    }
                    // Wandering logic
                    else {
                        // Ensure homePosition is set
                        if (!enemy.userData.homePosition) {
                            enemy.userData.homePosition = enemy.position.clone();
                        }

                        const maxWanderRadius = 3000; // Increased from 300 to 600

                        // Initialize direction if not set
                        if (!enemy.userData.direction || enemy.userData.direction.length() === 0) {
                            enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                        }

                        // Initialize isIdle if not set
                        if (enemy.userData.isIdle === undefined) {
                            enemy.userData.isIdle = false;
                        }

                        // Initialize time to next state change if not set
                        if (enemy.userData.timeToChangeState === undefined) {
                            enemy.userData.timeToChangeState = Math.random() * 2 + 1; // Random time between 1 and 3 seconds
                        }

                        // Decrease time to next state change
                        enemy.userData.timeToChangeState -= delta;

                        // Change direction or idle state if time is up
                        if (enemy.userData.timeToChangeState <= 0) {
                            // Randomly decide whether to stand still or move
                            enemy.userData.isIdle = Math.random() < 0.3; // 30% chance to stand still
                            if (enemy.userData.isIdle) {
                                // Set idle time between 1 and 5 seconds
                                enemy.userData.timeToChangeState = Math.random() * 4 + 1; // Random time between 1 and 5 seconds
                                enemy.userData.direction.set(0, 0, 0); // No movement
                            } else {
                                // Randomly pick a new direction
                                enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                                // Set time until next state change
                                enemy.userData.timeToChangeState = Math.random() * 2 + 1; // Random time between 1 and 3 seconds
                            }
                        }

                        const oldPosition = enemy.position.clone();
                        const moveVector = enemy.userData.direction.clone().multiplyScalar(wanderingSpeed * delta);
                        enemy.position.add(moveVector);

                        // After moving, check if enemy is outside of wander radius
                        const distanceFromHome = enemy.position.distanceTo(enemy.userData.homePosition);
                        if (distanceFromHome > maxWanderRadius) {
                            // Adjust direction back toward home
                            enemy.position.copy(oldPosition);
                            enemy.userData.direction = new THREE.Vector3().subVectors(enemy.userData.homePosition, enemy.position).normalize();
                            enemy.isMoving = true;
                        } else {
                            let collided = false;
                            // Check collisions with walls and enemy barriers
                            for (let wall of [...walls, ...enemyWalls]) {
                                const enemyBox = new THREE.Box3().setFromObject(enemy);
                                const wallBox = new THREE.Box3().setFromObject(wall);
                                if (enemyBox.intersectsBox(wallBox)) {
                                    collided = true;
                                    break;
                                }
                            }

                            if (collided) {
                                enemy.position.copy(oldPosition);
                                // Pick a new random direction to avoid the obstacle
                                enemy.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                                enemy.isMoving = false;
                            } else {
                                enemy.isMoving = !enemy.userData.isIdle;
                                // Update rotation only if moving
                                if (!enemy.userData.isIdle && enemy.userData.direction.lengthSq() > 0) {
                                    enemy.rotation.y = Math.atan2(moveVector.x, moveVector.z);
                                }
                            }

                            // Update rotation
                            if (!enemy.userData.isIdle && enemy.userData.direction.lengthSq() > 0) {
                                enemy.rotation.y = Math.atan2(enemy.userData.direction.x, enemy.userData.direction.z);
                            }
                        }
                    }
                        // Animate the enemy
                        animateHumanoid(enemy, delta);
                    });
            }

            function attackEnemy(enemy) {
                const attackRange = 20; 

                const distance = player.position.distanceTo(enemy.position);

                if (distance <= attackRange) {
                    playAttackAnimation();

                    setTimeout(() => {
                        defeatEnemy(enemy);
                    }, 500); 
                } else {
                    alert('Enemy is too far away!');
                }
            }

            function playAttackAnimation() {
                player.isAttacking = true;
                player.attackTime = 0;
            }

            function enemyAttackPlayer(enemy, delta) {
                if (enemy.userData.isDead || playerInvulnerable) return;

                // Calculate damage based on damageRate and delta time
                const damage = enemy.userData.damageRate * delta;
                const actualDamage = Math.max(0, damage - (characterStats.vitality / 10)); // Adjust based on vitality
                
                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            function animateDeadEnemies(delta) {
                scene.children.forEach((object) => {
                    if (object.userData && object.userData.isDead) {
                        object.userData.deathTime += delta;
                        if (object.userData.deathTime < 1) {
                            object.rotation.x = -Math.PI / 2 * (object.userData.deathTime / 1);
                        } else {
                            object.rotation.x = -Math.PI / 2;

                            if (!object.userData.bloodPoolCreated) {
                                createBloodPool(object.position);
                                object.userData.bloodPoolCreated = true;
                            }
                        }
                    }
                });
            }

            function defeatEnemy(enemy) {
                addExperience(20);
                gold += 10;
                updateGoldDisplay();
                alert('Enemy defeated! You gained 20 experience and 10 gold.');

                enemy.isMoving = false;
                enemy.userData.isDead = true;
                enemy.userData.deathTime = 0;
            }

            function damagePlayer(amount) {
                if (playerInvulnerable) return; // Player is invulnerable
                const vitalityFactor = characterStats.vitality / 10; // Adjust as needed
                const actualDamage = Math.max(1, amount - vitalityFactor);
                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            function addExperience(amount) {
                characterStats.experience += amount;
                if (characterStats.experience >= characterStats.nextLevelExperience) {
                    levelUp();
                }
                updateStatsDisplay();
            }

            function createBloodPool(position) {
                const geometry = new THREE.CircleGeometry(5, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const bloodPool = new THREE.Mesh(geometry, material);
                bloodPool.rotation.x = -Math.PI / 2;
                bloodPool.position.set(position.x, 0.05, position.z);
                scene.add(bloodPool);
            }





            function lootEnemy(enemy) {
                if (enemy.userData.hasBeenLooted) {
                    alert('This enemy has already been looted.');
                    return;
                }

                isLooting = true;
                lootProgress = 0;
                currentLootingEnemy = enemy;
                document.getElementById('lootBarContainer').style.display = 'block';
            }

            function updateLooting(delta) {
                if (isLooting) {
                    lootProgress += delta;
                    const progressBar = document.getElementById('lootBar');
                    progressBar.style.width = (lootProgress / lootDuration) * 100 + '%';
                    if (lootProgress >= lootDuration) {
                        isLooting = false;
                        document.getElementById('lootBarContainer').style.display = 'none';
                        openLootPopup();
                    }
                }
            }

            function openLootPopup() {
                lootedItems = generateRandomItems(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            function lootAllItems() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change enemy color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    // Prevent further looting by disabling the enemy
                    // Optionally, you can remove the enemy from the scene or make it non-interactive
                    // For now, we just mark it as looted

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            function createHostileQuadruped(x, y, z) {
                const color = 0xFFA500; // Orange color

                const hostileQuadruped = createQuadruped(color);

                hostileQuadruped.position.set(x, y, z);

                hostileQuadruped.userData.type = 'hostileQuadruped';
                hostileQuadruped.userData.isDead = false;
                hostileQuadruped.userData.hasBeenLooted = false;
                hostileQuadruped.userData.deathTime = 0;
                hostileQuadruped.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                hostileQuadruped.isMoving = true;
                hostileQuadruped.userData.damageRate = 3; // Adjust damage rate as needed
                hostileQuadruped.userData.homePosition = hostileQuadruped.position.clone();
                hostileQuadruped.userData.wanderRadius = 500; // Adjust as needed

                scene.add(hostileQuadruped);
                hostileQuadrupeds.push(hostileQuadruped);

                return hostileQuadruped;
            }

            // Function to spawn hostile quadrupeds
            function addHostileQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(500, 1500);
                    createHostileQuadruped(position.x, 0, position.z);
                }
            }
            function moveHostileQuadrupeds(delta) {
                hostileQuadrupeds.forEach((hostileQuadruped) => {
                    if (hostileQuadruped.userData.isDead) return;

                    const threatRange = 100;
                    const attackRange = 10;
                    const enemySpeed = globalEnemySpeed;

                    const directionToPlayer = new THREE.Vector3().subVectors(player.position, hostileQuadruped.position);
                    const distanceToPlayer = directionToPlayer.length();

                    if (distanceToPlayer <= attackRange) {
                        hostileQuadruped.isMoving = false;
                        attackPlayerByHostileQuadruped(hostileQuadruped, delta);
                    } else if (distanceToPlayer <= threatRange) {
                        directionToPlayer.normalize();
                        const oldPosition = hostileQuadruped.position.clone();
                        hostileQuadruped.position.add(directionToPlayer.multiplyScalar(enemySpeed));

                        let collided = false;
                        for (let wall of walls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        for (let wall of enemyWalls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            hostileQuadruped.position.copy(oldPosition);
                            hostileQuadruped.isMoving = false;
                        } else {
                            hostileQuadruped.isMoving = true;
                            // Rotate hostile quadruped to face player
                            const angle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                            hostileQuadruped.rotation.y = angle;
                        }
                    } else {
                        // Wandering behavior
                        const oldPosition = hostileQuadruped.position.clone();
                        const moveVector = hostileQuadruped.userData.direction.clone().multiplyScalar(0.5);
                        hostileQuadruped.position.add(moveVector);

                        // Clamp position within bounds
                        hostileQuadruped.position.x = Math.max(-5000, Math.min(5000, hostileQuadruped.position.x));
                        hostileQuadruped.position.z = Math.max(-5000, Math.min(5000, hostileQuadruped.position.z));

                        let collided = false;
                        for (let wall of walls) {
                            const hostileQuadrupedBox = new THREE.Box3().setFromObject(hostileQuadruped);
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            if (hostileQuadrupedBox.intersectsBox(wallBox)) {
                                collided = true;
                                break;
                            }
                        }

                        if (collided) {
                            hostileQuadruped.position.copy(oldPosition);
                            hostileQuadruped.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                            hostileQuadruped.isMoving = false;
                        } else {
                            hostileQuadruped.isMoving = true;
                            // Rotate hostile quadruped to face movement direction
                            const angle = Math.atan2(moveVector.x, moveVector.z);
                            hostileQuadruped.rotation.y = angle;
                        }
                    }

                    // Animate hostile quadruped
                    animateQuadruped(hostileQuadruped, delta);
                });
            }

            // Function for hostile quadrupeds to attack player
            function attackPlayerByHostileQuadruped(hostileQuadruped, delta) {
                if (hostileQuadruped.userData.isDead || playerInvulnerable) return;

                // Calculate damage based on damageRate and delta time
                const damage = hostileQuadruped.userData.damageRate * delta;
                const actualDamage = Math.max(0, damage - (characterStats.vitality / 10));

                playerHealth -= actualDamage;
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    alert('You have been defeated!');
                    // Implement game over logic here
                }
                updateHealthDisplay();
            }

            // Function to handle defeating a hostile quadruped
            function defeatHostileQuadruped(hostileQuadruped) {
                addExperience(30); // Adjust experience as needed
                gold += 15; // Adjust gold as needed
                updateGoldDisplay();
                alert('Hostile quadruped defeated! You gained 30 experience and 15 gold.');

                hostileQuadruped.isMoving = false;
                hostileQuadruped.userData.isDead = true;
                hostileQuadruped.userData.deathTime = 0;
            }

            // Function to loot a hostile quadruped
            function lootHostileQuadruped(hostileQuadruped) {
                if (hostileQuadruped.userData.hasBeenLooted) {
                    alert('This creature has already been looted.');
                    return;
                }

                isLooting = true;
                lootProgress = 0;
                currentLootingEnemy = hostileQuadruped;
                document.getElementById('lootBarContainer').style.display = 'block';
            }

            // Generate random items from the hostile_mob_loot table
            function generateHostileMobLoot(count) {
                const items = [
                    { name: 'Beast Claw', description: 'A sharp claw from a ferocious beast.' },
                    { name: 'Tough Hide', description: 'A piece of thick hide, useful for crafting.' },
                    { name: 'Wild Fang', description: 'A fang that exudes a dangerous aura.' },
                    { name: 'Savage Horn', description: 'A horn that could be valuable to collectors.' },
                    { name: 'Enchanted Fur', description: 'Fur that seems to have magical properties.' },
                    // Add more items as needed
                ];
                const randomItems = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * items.length);
                    // Clone the item to avoid reference issues
                    randomItems.push({ ...items[randomIndex] });
                }
                return randomItems;
            }

            // Modify openLootPopup to handle hostile quadruped loot
            function openLootPopupHostileQuadruped() {
                lootedItems = generateHostileMobLoot(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            // Modify lootAllItems to handle hostile quadrupeds
            function lootAllItemsHostileQuadruped() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change quadruped color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            // Function to attack a hostile quadruped
            function attackHostileQuadruped(hostileQuadruped) {
                const attackRange = 20;

                const distance = player.position.distanceTo(hostileQuadruped.position);

                if (distance <= attackRange) {
                    playAttackAnimation();

                    setTimeout(() => {
                        defeatHostileQuadruped(hostileQuadruped);
                    }, 500);
                } else {
                    alert('Creature is too far away!');
                }
            }

            function initializeInventory() {
                const tabs = document.querySelectorAll('.inventory-tab');
                const tabContents = document.querySelectorAll('.inventory-tab-content');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.getAttribute('data-tab');
                        tabContents.forEach(content => {
                            content.style.display = content.id === tabId ? 'block' : 'none';
                        });
                    });
                });

                // Show the first tab by default
                if (tabContents.length > 0) {
                    tabContents[0].style.display = 'block';
                }
            }

            function init() {
                // Disable right-click context menu
                document.addEventListener('contextmenu', function(event) {
                    event.preventDefault();
                }, false);
                initializeInventory();
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({ canvas });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.autoClear = false;
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
                minimapCamera = new THREE.OrthographicCamera(-200, 200, 200, -200, 0.1, 10000);
                minimapCamera.position.set(0, 500, 0);
                minimapCamera.up.set(0, 0, -1);
                minimapCamera.lookAt(0, 0, 0);
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 100, 0);
                scene.add(directionalLight);
                addQuadrupeds();

                    

                // Help Window Open on Start
                helpWindowOpen = true;
                document.getElementById('helpWindow').style.display = 'block';

                const groundShape = new THREE.Shape();
                groundShape.moveTo(-5000, -5000);
                groundShape.lineTo(5000, -5000);
                groundShape.lineTo(5000, 5000);
                groundShape.lineTo(-5000, 5000);
                groundShape.lineTo(-5000, -5000);

                const safeZoneSize = 600;
                const holePath = new THREE.Path();
                holePath.moveTo(-safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, -safeZoneSize);
                groundShape.holes.push(holePath);

                const groundGeometry = new THREE.ShapeGeometry(groundShape);
                console.log(groundGeometry.attributes.uv); // Inspect UVs in the console

                // Load the texture and apply it to the ground material
                const textureLoader = new THREE.TextureLoader();
                const groundTexture = textureLoader.load(
                    'ground.png',
                    (texture) => {
                        // Configure texture once it's loaded
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(50, 50); // Larger repeat values for more texture repetition
                        texture.encoding = THREE.sRGBEncoding;
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        
                        // Update the material with the loaded texture
                        groundMaterial.map = texture;
                        groundMaterial.needsUpdate = true;
                        
                        console.log('Ground texture loaded successfully');
                    },
                    undefined, // onProgress callback not needed
                    (error) => {
                        console.error('Error loading ground texture:', error);
                    }
                );
                
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(25, 25); // Adjust the repeat to scale the texture as desired


                // const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });

                // ground = new THREE.Mesh(groundGeometry, groundMaterial);
                // ground.rotation.x = -Math.PI / 2;
                // ground.name = 'ground';
                // scene.add(ground);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    map: groundTexture,
                    side: THREE.DoubleSide
                });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.name = 'ground';
                scene.add(ground);
                
                const safeZoneGroundGeometry = new THREE.PlaneGeometry(1200, 1200);
                const safeZoneGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                safeZoneGround = new THREE.Mesh(safeZoneGroundGeometry, safeZoneGroundMaterial);
                safeZoneGround.rotation.x = -Math.PI / 2;
                safeZoneGround.position.y = 0.1;
                scene.add(safeZoneGround);

                const safeZoneBarrierGeometry = new THREE.BoxGeometry(1200, 50, 1200);
                const safeZoneBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                const safeZoneBarrier = new THREE.Mesh(safeZoneBarrierGeometry, safeZoneBarrierMaterial);
                safeZoneBarrier.position.set(0, 25, 0);
                scene.add(safeZoneBarrier);
                enemyWalls.push(safeZoneBarrier);

                const initialSettlementWalls = createSettlementWalls();
                scene.add(initialSettlementWalls);
                        
                const shrineGroup = new THREE.Group();

                const floorGeometry = new THREE.CircleGeometry(20, 32);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1;
                shrineGroup.add(floor);

                const teleportPadGeometry = new THREE.CircleGeometry(5, 32);
                const teleportPadMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                teleportPad = new THREE.Mesh(teleportPadGeometry, teleportPadMaterial);
                teleportPad.rotation.x = -Math.PI / 2;
                teleportPad.position.y = 0.15;
                teleportPad.name = 'teleportPad';
                shrineGroup.add(teleportPad);

                shrineGroup.position.set(0, 0, 0);
                scene.add(shrineGroup);
                
                const structurePositions = [
                    // Row 1 (z = 200)
                    { x: -200, z: 200 },
                    { x: 0, z: 200 },
                    { x: 200, z: 200 },
                    // Row 2 (z = -200)
                    { x: -200, z: -200 },
                    { x: 0, z: -200 },
                    { x: 200, z: -200 },
                ];
                

                structurePositions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, 0, pos.z);
                    scene.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);


                    // Usage example
                    const npcInfo = getRandomNPC();
                    if (npcInfo) {
                        console.log(npcInfo);
                    } else {
                        console.log("No more unique NPCs left to select.");
                    }


                    // Create the NPC with the selected data
                    const npc = createFriendlyNPC(0x00ff00, npcInfo.name, npcInfo.dialogue);

                    // Position the NPC at the structure's position
                    npc.position.copy(structure.position);

                    // Add the NPC to the scene and friendlies array
                    scene.add(npc);
                    friendlies.push(npc);
                });

                player = createHumanoid(0x0000ff);
                player.position.y = 0; 
                scene.add(player);

                function checkEnemiesInSafeZone() {
                    const safeZoneRadius = 600; // Radius of the safe zone

                    enemies.forEach((enemy) => {
                        if (enemy.userData.isDead) return;

                        const distanceFromCenter = Math.sqrt(
                            enemy.position.x * enemy.position.x + enemy.position.z * enemy.position.z
                        );

                        if (distanceFromCenter < safeZoneRadius) {
                            const angle = Math.random() * Math.PI * 2;
                            const teleportDistance = 1000;
                            enemy.position.x = Math.cos(angle) * teleportDistance;
                            enemy.position.z = Math.sin(angle) * teleportDistance;
                            enemy.position.y = 0; 
                        }
                    });
                }

                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('keydown', onDocumentKeyDown, false);
                canvas.addEventListener('mousedown', onDocumentMouseDown, false);
                canvas.addEventListener('mouseup', onDocumentMouseUp, false);

            }
                
            function initMap() {
                const mapCanvas = document.getElementById('mapCanvas');
                mapRenderer = new THREE.WebGLRenderer({ canvas: mapCanvas, alpha: true });
                mapRenderer.setSize(window.innerWidth, window.innerHeight);
                mapScene = new THREE.Scene();

                // Orthographic camera for 2D map
                const aspect = window.innerWidth / window.innerHeight;
                const d = 5000; // Adjust based on your game world's size
                mapCamera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 10000);
                mapCamera.position.set(0, 1000, 0); // High above the game world
                mapCamera.up.set(0, 0, -1); // Adjust to match the game world's orientation
                mapCamera.lookAt(new THREE.Vector3(0, 0, 0));

                // Add similar lighting to the main scene
                const ambientLight = new THREE.AmbientLight(0x404040);
                mapScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 100, 0);
                mapScene.add(directionalLight);
            }
            // Function to add quadrupeds to the scene
            function addQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    const quadruped = createQuadruped();
                    quadruped.position.set(position.x, 0, position.z);
                    quadrupeds.push(quadruped);
                    scene.add(quadruped);
                    quadruped.userData.homePosition = quadruped.position.clone();
                    quadruped.userData.wanderRadius = 500; // Adjust as needed
                }
            }

            const purpleStructure = createPurpleStructure();
            purpleStructure.position.set(800, 0, -800); // Adjust position as desired
            scene.add(purpleStructure);

            // updateDisplays.js
            function updateStatsDisplay() {
                document.getElementById('level').innerText = characterStats.level;
                document.getElementById('experience').innerText = characterStats.experience;
                document.getElementById('nextLevelExperience').innerText = characterStats.nextLevelExperience;
                document.getElementById('strength').innerText = characterStats.strength;
                document.getElementById('dexterity').innerText = characterStats.dexterity;
                document.getElementById('vitality').innerText = characterStats.vitality;
                document.getElementById('energy').innerText = characterStats.energy;
                document.getElementById('statPoints').innerText = characterStats.statPoints;
            }

            function updateGoldDisplay() {
                document.getElementById('goldAmount').innerText = gold;
            }

            function updateHealthDisplay() {
                document.getElementById('lifeValue').innerText = `${playerHealth}/${playerMaxHealth}`;
                let healthPercent = (playerHealth / playerMaxHealth) * 100;
                document.getElementById('lifeFill').style.height = `${healthPercent}%`;
            }

            function updateEnergyDisplay() {
                document.getElementById('energyValue').innerText = `${playerEnergy}/${playerMaxEnergy}`;
                let energyPercent = (playerEnergy / playerMaxEnergy) * 100;
                document.getElementById('energyOrb').style.clipPath = `inset(${100 - energyPercent}% 0 0 0)`;
            }

            function updateDisplay() {
                document.getElementById('level').textContent = characterStats.level;
                document.getElementById('experience').textContent = characterStats.experience;
                document.getElementById('nextLevelExperience').textContent = characterStats.nextLevelExperience;
                document.getElementById('strength').textContent = characterStats.strength;
                document.getElementById('dexterity').textContent = characterStats.dexterity;
                document.getElementById('vitality').textContent = characterStats.vitality;
                document.getElementById('energy').textContent = characterStats.energy;
                document.getElementById('mana').textContent = characterStats.mana;
                document.getElementById('karma').textContent = characterStats.karma;
                document.getElementById('reputation').textContent = characterStats.reputation;
                document.getElementById('statPoints').textContent = characterStats.statPoints;
                

                renderCharacterSprite(); // Update the character sprite in the inventory
            }

            function renderCharacterSprite() {
            }

            updateGoldDisplay();
            updateHealthDisplay();
            updateEnergyDisplay();
            updateStatsDisplay();
            updateDisplay();


            // ui.js

            // Tooltip Element
            const tooltip = document.getElementById('tooltip');

            // Initialize UI Components
            function initializeUI() {
                initializeStatsUI();
                initializeSkillTreeUI();
                initializeBestiaryUI();
                initializeQuestLogUI();
                initializeHelpWindowUI();
                initializeAdminConsoleUI();
                initializeHotbarUI();
                initializeLootPopupUI();
                initializeNpcPopupUI();
                initializeChestPopupUI();
                initializeEnergyOrbUI();
                initializeLifeOrbUI();
                initializeTeleportationBarUI();
            }

            // --------------------------------------- Stats UI ---------------------------------------

            function initializeStatsUI() {
                updateStatsDisplay();
            }

            function updateStatsDisplay() {
                document.getElementById('level').innerText = characterStats.level;
                document.getElementById('experience').innerText = characterStats.experience;
                document.getElementById('nextLevelExperience').innerText = characterStats.nextLevelExperience;
                document.getElementById('strength').innerText = characterStats.strength;
                document.getElementById('dexterity').innerText = characterStats.dexterity;
                document.getElementById('vitality').innerText = characterStats.vitality;
                document.getElementById('energy').innerText = characterStats.energy;
                document.getElementById('statPoints').innerText = characterStats.statPoints;
            }

            function increaseStat(stat) {
                if (characterStats.statPoints > 0) {
                    characterStats[stat]++;
                    characterStats.statPoints--;
                    updateStatsDisplay();
                } else {
                    alert('No available stat points!');
                }
            }

            // --------------------------------------- Skill Tree UI ---------------------------------------


            function initializeSkillTreeUI() {
                // Skill Tree is initialized when opened
            }

            function openSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'block';
                populateSkillTree();
            }

            function closeSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'none';
            }

            function populateSkillTree() {
                const skillsContainer = document.getElementById('skillsContainer');
                skillsContainer.innerHTML = ''; // Clear existing skills

                for (const key in skillTreeData) {
                    if (skillTreeData.hasOwnProperty(key)) {
                        const skill = skillTreeData[key];
                        const skillDiv = document.createElement('div');
                        skillDiv.classList.add('skill');
                        if (skill.learned) {
                            skillDiv.classList.add('learned');
                        }
                        skillDiv.innerHTML = `<strong>${skill.name}</strong><br>${skill.description}<br>Cost: ${skill.cost} XP`;
                        
                        // Add click event to learn the skill
                        skillDiv.addEventListener('click', () => {
                            if (!skill.learned && characterStats.experience >= skill.cost * 100) { // Assuming 100 XP per cost unit
                                characterStats.experience -= skill.cost * 100;
                                characterStats[Object.keys(skillTreeData)[Object.keys(skillTreeData).indexOf(key)]] += 5; // Increase the relevant stat
                                skill.learned = true;
                                updateStatsDisplay();
                                populateSkillTree(); // Refresh the skill tree
                                alert(`You have learned ${skill.name}!`);
                            } else if (skill.learned) {
                                alert('Skill already learned.');
                            } else {
                                alert('Not enough experience to learn this skill.');
                            }
                        });

                        // Add CSS classes based on skill availability
                        if (!skill.learned && characterStats.experience < skill.cost * 100) {
                            skillDiv.classList.add('unavailable');
                        }

                        skillsContainer.appendChild(skillDiv);
                    }
                }
            }



            // --------------------------------------- Help Window UI ---------------------------------------



            function initializeHelpWindowUI() {
                // Help Window is initialized when opened
            }

            function toggleHelpWindow() {
                helpWindowOpen = !helpWindowOpen;
                document.getElementById('helpWindow').style.display = helpWindowOpen ? 'block' : 'none';
            }

            // --------------------------------------- Admin Console UI ---------------------------------------



            function initializeAdminConsoleUI() {
                // Admin Console is initialized when opened
            }

            function openAdminConsoleUI() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'block';
                if (isAdminLoggedIn) {
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminControls').style.display = 'block';
                } else {
                    document.getElementById('adminLogin').style.display = 'block';
                    document.getElementById('adminControls').style.display = 'none';
                }
            }

            function closeAdminConsoleUI() {
                const adminConsole = document.getElementById('adminConsole');
                adminConsole.style.display = 'none';
                isAdminLoggedIn = false;
                document.getElementById('adminControls').style.display = 'none';
                document.getElementById('adminLogin').style.display = 'block';
            }

            function checkAdminPasswordUI() {
                const passwordInput = document.getElementById('adminPassword').value;
                if (passwordInput === 'ltwelcome1') {
                    isAdminLoggedIn = true;
                    document.getElementById('adminLogin').style.display = 'none';
                    document.getElementById('adminControls').style.display = 'block';
                    document.getElementById('adminPassword').value = ''; // Clear password field

                    // Attach the change event listener only once
                    if (!document.getElementById('npcAdminCheckbox').hasAttribute('data-listener')) {
                        document.getElementById('npcAdminCheckbox').addEventListener('change', function() {
                            npcAdminEnabled = this.checked;
                            alert('NPC Admin Mode ' + (npcAdminEnabled ? 'Enabled' : 'Disabled'));
                        });
                        document.getElementById('npcAdminCheckbox').setAttribute('data-listener', 'true');
                    }
                } else {
                    alert('Incorrect password!');
                }
            }

            function updatePlayerOptionsUI() {
                playerInvulnerable = document.getElementById('invulnerabilityCheckbox').checked;
                alert('Player options updated.');
            }

            function updatePlayerStatsUI() {
                const healthInput = parseInt(document.getElementById('playerHealthInput').value);
                const goldInput = parseInt(document.getElementById('playerGoldInput').value);
                const experienceInput = parseInt(document.getElementById('playerExperienceInput').value);

                if (!isNaN(healthInput)) {
                    playerHealth = Math.min(healthInput, playerMaxHealth);
                    updateHealthDisplay();
                }
                if (!isNaN(goldInput)) {
                    gold = goldInput;
                    updateGoldDisplay();
                }
                if (!isNaN(experienceInput)) {
                    characterStats.experience = experienceInput;
                    if (characterStats.experience >= characterStats.nextLevelExperience) {
                        levelUp();
                    }
                    updateStatsDisplay();
                }
                alert('Player stats updated.');
            }

            function spawnEntitiesUI() {
                const entityType = document.getElementById('entityTypeSelect').value;
                const quantity = parseInt(document.getElementById('entityQuantityInput').value);

                if (isNaN(quantity) || quantity <= 0) {
                    alert('Invalid quantity!');
                    return;
                }

                for (let i = 0; i < quantity; i++) {
                    const offsetX = Math.random() * 50 - 25;
                    const offsetZ = Math.random() * 50 - 25;
                    const spawnPosition = {
                        x: player.position.x + offsetX,
                        y: player.position.y,
                        z: player.position.z + offsetZ
                    };

                    if (entityType === 'enemy') {
                        const enemy = createEnemy(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        enemies.push(enemy);
                        scene.add(enemy);
                        enemy.userData.homePosition = enemy.position.clone();
                        enemy.userData.wanderRadius = 500; // Adjust as needed
                    } else if (entityType === 'friendlyNPC') {
                        const npc = createFriendlyNPC();
                        npc.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        friendlies.push(npc);
                        scene.add(npc);
                    } else if (entityType === 'structure') {
                        const structure = createStructure();
                        structure.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        scene.add(structure);
                        walls.push(...structure.userData.walls);
                    } else if (entityType === 'treasureChest') {
                        createTreasureChest(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Treasure Chest spawned.');
                    } else if (entityType === 'settlement') {
                        createSettlement(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        alert('Settlement spawned.');
                    } else if (entityType === 'quadruped') {
                        const quadruped = createQuadruped();
                        quadruped.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
                        quadrupeds.push(quadruped);
                        scene.add(quadruped);
                        alert('Quadruped spawned.');
                    }
                }
            }

            function updateGameSettingsUI() {
                const enemySpeedInput = parseFloat(document.getElementById('enemySpeedInput').value);

                if (!isNaN(enemySpeedInput) && enemySpeedInput > 0) {
                    globalEnemySpeed = enemySpeedInput;
                    alert('Game settings updated.');
                } else {
                    alert('Invalid enemy speed!');
                }
            }

            function teleportPlayerUI() {
                const x = parseFloat(document.getElementById('teleportXInput').value);
                const z = parseFloat(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    player.position.set(x, player.position.y, z);
                    destination = null;
                    isTeleporting = false; // Reset teleporting state
                    document.getElementById('teleportationBarContainer').style.display = 'none'; // Hide progress bar
                    document.getElementById('teleportationBar').style.width = '0%'; // Reset progress bar
                    alert(`Player teleported to (${x}, ${z}).`);
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // --------------------------------------- Hotbar UI ---------------------------------------

            function initializeHotbarUI() {
                const slots = document.querySelectorAll('.slot');
                slots.forEach(slot => {
                    slot.addEventListener('click', () => {
                        const slotNumber = slot.getAttribute('data-slot');
                        handleHotbarSelection(slotNumber);
                    });
                });
            }

            function handleHotbarSelection(slotNumber) {
                const selectedSlot = document.querySelector(`.slot[data-slot="${slotNumber}"]`);
                if (selectedSlot) {
                    // Add a visual indicator for selection (e.g., a border)
                    document.querySelectorAll('.slot').forEach(slot => slot.style.borderColor = '#555'); // Reset all borders
                    selectedSlot.style.borderColor = '#FFD700'; // Highlight selected slot with gold color

                    // Implement the action you want when a slot is selected
                    // For example, equip the item in the slot or activate its ability
                    console.log(`Hotbar slot ${slotNumber} selected.`);
                    // Add your custom action here
                }
            }

            // --------------------------------------- Loot Popup UI ---------------------------------------

            function initializeLootPopupUI() {
                // Loot Popup is initialized when opened
            }

            function openLootPopupUI() {
                lootedItems = generateRandomItems(2);

                const lootItemsDiv = document.getElementById('lootItems');
                lootItemsDiv.innerHTML = '';
                lootedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.innerText = item.name;
                    lootItemsDiv.appendChild(itemDiv);
                });

                document.getElementById('lootPopup').style.display = 'block';
            }

            function lootAllItemsUI() {
                lootedItems.forEach(item => {
                    addItemToInventory(item);
                });
                lootedItems = [];
                document.getElementById('lootPopup').style.display = 'none';

                if (currentLootingEnemy) {
                    // Change enemy color to black
                    currentLootingEnemy.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(0x000000); // Black color
                        }
                    });

                    // Set the hasBeenLooted flag to true
                    currentLootingEnemy.userData.hasBeenLooted = true;

                    // Prevent further looting by disabling the enemy
                    // For now, we just mark it as looted

                    currentLootingEnemy = null;
                }

                isLooting = false;
                document.getElementById('lootBarContainer').style.display = 'none';
                document.getElementById('lootBar').style.width = '0%';
                alert('Items looted and added to your inventory.');
            }

            // --------------------------------------- NPC Popup UI ---------------------------------------


            function initializeNpcPopupUI() {
                // NPC Popup is initialized when opened
            }

            function openNpcPopupUI(npc) {
                if (npcPopupOpen) {
                    closeNpcPopupUI();
                    return;
                }
                document.getElementById('npcPopup').querySelector('h2').innerText = npc.userData.name || 'Friendly NPC';
                document.getElementById('npcPopup').querySelector('p').innerText = npc.userData.dialogue || 'Hello, traveler! Stay awhile and listen...';
                document.getElementById('npcPopup').style.display = 'block';
                npcPopupOpen = true;
            }

            function closeNpcPopupUI() {
                document.getElementById('npcPopup').style.display = 'none';
                npcPopupOpen = false;
            }

            // --------------------------------------- Chest Popup UI ---------------------------------------



            function initializeChestPopupUI() {
                // Chest Popup is initialized when opened
            }

            function openChestPopupUI(chest) {
                currentOpenedChest = chest;
                const chestPopup = document.getElementById('chestPopup');
                chestPopup.style.display = 'block';

                const chestInventoryGrid = document.getElementById('chestInventoryGrid');
                const playerInventoryGrid = document.getElementById('playerInventoryInChestGrid');

                const chestColumns = 7;
                const chestRows = 4;
                const playerColumns = 7;
                const playerRows = 8;

                generateInventoryGrid(chestInventoryGrid, chestColumns, chestRows);
                generateInventoryGrid(playerInventoryGrid, playerColumns, playerRows);

                // Ensure items arrays have correct length for chests but not for playerInventory
                if (!chest.userData.items) chest.userData.items = [];
                chest.userData.items.length = chestColumns * chestRows;


                populateInventoryGridChest(chestInventoryGrid, chest.userData.items);
                populateInventoryGridChest(playerInventoryGrid, playerInventory);

                setupInventorySlotEventListeners(chestInventoryGrid, chest.userData.items, playerInventory, playerInventoryGrid);
                setupInventorySlotEventListeners(playerInventoryGrid, playerInventory, chest.userData.items, chestInventoryGrid);
            }

            function generateInventoryGrid(gridElement, numColumns, numRows) {
                gridElement.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                gridElement.innerHTML = '';
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    gridElement.appendChild(slot);
                }
            }

            function populateInventoryGridChest(gridElement, items) {
                gridElement.innerHTML = ''; // Clear existing items
                items.forEach((item, index) => {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    slot.innerText = item ? item.name : '';

                    if (item) {
                        slot.setAttribute('data-name', item.name);
                        slot.setAttribute('data-description', item.description || 'No description available.');

                        // Event listeners for tooltip
                        slot.addEventListener('mouseenter', showTooltip);
                        slot.addEventListener('mousemove', moveTooltip);
                        slot.addEventListener('mouseleave', hideTooltip);
                    }

                    gridElement.appendChild(slot);
                });
            }

            function setupInventorySlotEventListeners(sourceGrid, sourceItems, targetItems, targetGrid) {
                const slots = sourceGrid.querySelectorAll('.inventory-slot');
                slots.forEach((slot, index) => {
                    slot.addEventListener('click', () => {
                        if (sourceItems[index]) {
                            // Find first empty slot in targetItems
                            let emptyIndex = targetItems.findIndex(item => item == null);
                            if (emptyIndex === -1) {
                                alert('No space in target inventory.');
                                return;
                            }
                            // Transfer item
                            targetItems[emptyIndex] = sourceItems[index];
                            sourceItems[index] = null;

                            // Update grids
                            populateInventoryGrid(sourceGrid, sourceItems);
                            populateInventoryGrid(targetGrid, targetItems);
                        }
                    });
                });
            }

            function closeChestPopupUI() {
                document.getElementById('chestPopup').style.display = 'none';
                currentOpenedChest = null;

                // Update the main inventory display if it's open
                if (inventoryOpen) {
                    populateInventoryGrid(document.getElementById('inventoryGridTab1'), playerInventory);
                }
            }

            function takeAllChestItemsUI() {
                const chest = currentOpenedChest;
                chest.userData.items.forEach(item => {
                    addItemToInventory(item);
                });
                chest.userData.items = [];
                gold += chest.userData.gold;
                updateGoldDisplay();
                chest.userData.gold = 0;

                scene.remove(chest);

                closeChestPopupUI();
            }

            // --------------------------------------- Additional UI Initializations ---------------------------------------

            function initializeEnergyOrbUI() {
                updateEnergyDisplay();
            }

            function initializeLifeOrbUI() {
                updateHealthDisplay();
            }

            function initializeTeleportationBarUI() {
                // Teleportation Bar is handled in main.js
            }

            function initializeAllUI() {
                initializeUI();
                initializeHotbarUI();
                initializeLootPopupUI();
                initializeNpcPopupUI();
                initializeChestPopupUI();
            }

            // Initialize all UI components
            document.addEventListener('DOMContentLoaded', () => {
                initializeAllUI();
            });


            // trading.js

            // Track trade state
            let tradeWindowOpen = false;
            let currentTradeNPC = null;

            // Initialize trade UI elements
            function initializeTradeWindow() {
                const tradeContainer = document.createElement('div');
                tradeContainer.id = 'tradeWindow';
                tradeContainer.style.display = 'none';
                tradeContainer.innerHTML = `
                    <h2 id="tradeNPCName">Trade with NPC</h2>
                    <div id="npcInventoryGrid" class="inventoryGrid"></div>
                    <div id="playerInventoryGrid" class="inventoryGrid"></div>
                    <div>
                        <button id="confirmTradeButton">Confirm Trade</button>
                        <button onclick="closeTradeWindow()">Cancel</button>
                    </div>
                `;
                document.body.appendChild(tradeContainer);

                // Set up event listeners
                document.getElementById('confirmTradeButton').addEventListener('click', confirmTrade);
            }

            // Open the trade window with a specified NPC
            function openTradeWindow(npc) {
                if (tradeWindowOpen) {
                    closeTradeWindow();
                    return;
                }
                
                currentTradeNPC = npc;
                document.getElementById('tradeNPCName').innerText = `Trade with ${npc.userData.name}`;
                
                // Populate NPC and player inventories
                populateInventoryGrid(document.getElementById('npcInventoryGrid'), npc.userData.inventory || []);
                populateInventoryGrid(document.getElementById('playerInventoryGrid'), playerInventory);
                
                document.getElementById('tradeWindow').style.display = 'block';
                tradeWindowOpen = true;
            }

            // Populate inventory grids
            function populateInventoryGrid(gridElement, items) {
                gridElement.innerHTML = '';
                items.forEach(item => {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    slot.innerText = item.name;
                    slot.addEventListener('click', () => selectItemForTrade(item, gridElement));
                    gridElement.appendChild(slot);
                });
            }

            // Close trade window
            function closeTradeWindow() {
                document.getElementById('tradeWindow').style.display = 'none';
                tradeWindowOpen = false;
                currentTradeNPC = null;
            }

            // Handle trade item selection and confirmation
            function selectItemForTrade(item, gridElement) {
                // Implement selection behavior (e.g., highlight selected items for trade)
            }

            function confirmTrade() {
                // Implement trade confirmation logic: update inventories based on selections
                alert('Trade confirmed!');
                closeTradeWindow();
            }

            // Initialize the trade window UI on load
            document.addEventListener('DOMContentLoaded', initializeTradeWindow);

            // Event listener to open trade with NPC on interaction
            document.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'e' && currentTradeNPC) {  // Assuming 'E' key to open trade when near NPC
                    openTradeWindow(currentTradeNPC);
                }
            });


            // tooltips.js

            // Create a tooltip element
            const entityTooltip = document.createElement('div');
            entityTooltip.id = 'entityTooltip';
            entityTooltip.style.position = 'absolute';
            entityTooltip.style.pointerEvents = 'none';
            entityTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            entityTooltip.style.color = '#fff';
            entityTooltip.style.padding = '5px 10px';
            entityTooltip.style.borderRadius = '5px';
            entityTooltip.style.fontSize = '14px';
            entityTooltip.style.display = 'none';
            entityTooltip.style.zIndex = '1000'; // Ensure tooltip is above other elements
            document.body.appendChild(entityTooltip);

            // Helper function to find the ancestor with userData.name
            function getEntityWithName(object) {
                while (object) {
                    if (object.userData && object.userData.name) {
                        return object;
                    }
                    object = object.parent;
                }
                return null;
            }

            // Function to handle mouse move and show tooltip for entities
            function onMouseMove(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                // Separate checks for different entity types
                const enemyIntersects = raycaster.intersectObjects(enemies, true);
                const friendlyIntersects = raycaster.intersectObjects(friendlies, true);
                const quadrupedIntersects = raycaster.intersectObjects(quadrupeds, true);

                // Display tooltip based on the first intersected object
                if (enemyIntersects.length > 0) {
                    const intersectedObject = enemyIntersects[0].object;
                    const enemy = getEntityWithName(intersectedObject);
                    entityTooltip.innerHTML = `<strong>${(enemy && enemy.userData.name) || 'Enemy'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else if (friendlyIntersects.length > 0) {
                    const intersectedObject = friendlyIntersects[0].object;
                    const friendly = getEntityWithName(intersectedObject);
                    entityTooltip.innerHTML = `<strong>${(friendly && friendly.userData.name) || 'Friendly NPC'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else if (quadrupedIntersects.length > 0) {
                    const intersectedObject = quadrupedIntersects[0].object;
                    const quadruped = getEntityWithName(intersectedObject);
                    entityTooltip.innerHTML = `<strong>${(quadruped && quadruped.userData.name) || 'Creature'}</strong>`;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else {
                    entityTooltip.style.display = 'none';
                }
            }

            // Function to handle tooltips for inventory items
            function onInventoryItemHover(event) {
                const itemSlot = event.target; // The inventory slot being hovered over
                const itemName = itemSlot.getAttribute('data-name');
                const itemDescription = itemSlot.getAttribute('data-description');
                const itemStats = itemSlot.getAttribute('data-stats');
                const itemRarity = itemSlot.getAttribute('data-rarity');

                if (itemName) {
                    entityTooltip.innerHTML = `
                        <strong>${itemName}</strong><br>
                        <em>${itemRarity || 'Common'}</em><br>
                        ${itemDescription || 'No description available.'}<br>
                        ${itemStats || 'No stats available.'}
                    `;
                    entityTooltip.style.left = `${event.clientX + 10}px`;
                    entityTooltip.style.top = `${event.clientY + 10}px`;
                    entityTooltip.style.display = 'block';
                } else {
                    entityTooltip.style.display = 'none';
                }
            }

            // Add event listener for mouse move on inventory items
            function setupInventoryTooltips() {
                const inventorySlots = document.querySelectorAll('.inventory-slot');
                inventorySlots.forEach(slot => {
                    slot.addEventListener('mouseenter', onInventoryItemHover);
                    slot.addEventListener('mousemove', onInventoryItemHover);
                    slot.addEventListener('mouseleave', () => {
                        entityTooltip.style.display = 'none';
                    });
                });
            }

            // Add event listeners for mouse move in the game world
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseleave', () => {
                entityTooltip.style.display = 'none';
            }, false);

            // Function to Show Tooltip
            function showTooltip(event) {
                const name = this.getAttribute('data-name');
                const description = this.getAttribute('data-description');
                tooltip.innerHTML = `<strong>${name}</strong><br>${description}`;
                tooltip.style.display = 'block';
            }

            // Function to Move Tooltip with Mouse
            function moveTooltip(event) {
                const tooltipWidth = tooltip.offsetWidth;
                const tooltipHeight = tooltip.offsetHeight;
                const pageWidth = window.innerWidth;
                const pageHeight = window.innerHeight;

                let x = event.clientX + 10;
                let y = event.clientY + 10;

                // Prevent tooltip from going off-screen
                if (x + tooltipWidth > pageWidth) {
                    x = event.clientX - tooltipWidth - 10;
                }
                if (y + tooltipHeight > pageHeight) {
                    y = event.clientY - tooltipHeight - 10;
                }

                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            }

            // Function to Hide Tooltip
            function hideTooltip() {
                tooltip.style.display = 'none';
                tooltip.innerHTML = '';
            }

            // terrain.js

            // Ensure that THREE.js and SimplexNoise are loaded before this script.
            // Include this script after including Three.js and SimplexNoise in your HTML.

            // TerrainGenerator Class: Responsible for generating and managing the terrain
            class TerrainGenerator {
                constructor(scene, settings) {
                    this.scene = scene;
                    this.settings = settings;
                    this.chunks = new Map();
                    this.simplex = new SimplexNoise();
                    this.simplexDetail = new SimplexNoise();
                    this.chunkGeometry = new THREE.PlaneGeometry(this.settings.chunkSize, this.settings.chunkSize, this.settings.chunkResolution, this.settings.chunkResolution);
                    this.chunkGeometry.rotateX(-Math.PI / 2); // Rotate to make it horizontal

                    // Create a green material for the terrain with vertex colors
                    this.terrainMaterial = new THREE.MeshStandardMaterial({
                        vertexColors: true,
                        flatShading: false, // Smooth shading for better elevation visuals
                    });

                    // Initialize texture for grass (optional)
                    const textureLoader = new THREE.TextureLoader();
                    this.grassTexture = textureLoader.load('path/to/grass-texture.jpg'); // Replace with your grass texture path
                    this.grassTexture.wrapS = this.grassTexture.wrapT = THREE.RepeatWrapping;
                    this.grassTexture.repeat.set(10, 10);
                    this.terrainMaterial.map = this.grassTexture;
                    this.terrainMaterial.needsUpdate = true;

                    // Initialize any additional features like trees or rocks here if needed
                }

                // Generates or retrieves an existing terrain chunk
                generateChunk(chunkX, chunkZ) {
                    const chunkKey = `${chunkX},${chunkZ}`;
                    if (this.chunks.has(chunkKey)) {
                        return this.chunks.get(chunkKey);
                    }

                    // Clone the base geometry to modify for this chunk
                    const geometry = this.chunkGeometry.clone();
                    const vertices = geometry.attributes.position.array;
                    const colors = new Float32Array(vertices.length); // Initialize color array

                    // Parameters for noise layers
                    const baseFrequency = this.settings.noiseScale;
                    const detailFrequency = this.settings.noiseScale * 2;
                    const baseAmplitude = this.settings.terrainHeight;
                    const detailAmplitude = this.settings.terrainHeight / 2;

                    // Iterate over each vertex to set elevation and color
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i] + chunkX * this.settings.chunkSize;
                        const z = vertices[i + 2] + chunkZ * this.settings.chunkSize;

                        // Generate elevation using multiple layers of simplex noise
                        const elevation = (
                            this.simplex.noise2D(x / baseFrequency, z / baseFrequency) * baseAmplitude +
                            this.simplexDetail.noise2D(x / detailFrequency, z / detailFrequency) * detailAmplitude
                        );

                        vertices[i + 1] = elevation;

                        // Assign green color based on elevation (optional gradient)
                        // For uniform green, uncomment the following lines:
                        colors[i] = 34 / 255;      // R component for ForestGreen (0x228B22)
                        colors[i + 1] = 139 / 255; // G component
                        colors[i + 2] = 34 / 255;  // B component

                        // Optional: Gradient based on elevation for visual depth
                        /*
                        const normalizedElevation = (elevation - this.settings.minElevation) / (this.settings.maxElevation - this.settings.minElevation);
                        const color = new THREE.Color();
                        color.setHSL(0.33, 1, 0.5 + 0.5 * normalizedElevation); // Adjust hue and lightness as needed
                        colors[i] = color.r;
                        colors[i + 1] = color.g;
                        colors[i + 2] = color.b;
                        */
                    }

                    geometry.computeVertexNormals(); // Recompute normals for accurate lighting
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                    // Create the terrain mesh
                    const terrain = new THREE.Mesh(geometry, this.terrainMaterial);
                    terrain.receiveShadow = true;
                    terrain.castShadow = false; // Terrain typically doesn't cast shadows onto itself

                    // Create a group for the chunk (useful if adding more objects like trees)
                    const chunkGroup = new THREE.Group();
                    chunkGroup.add(terrain);

                    // Position the chunk correctly in the world
                    chunkGroup.position.set(chunkX * this.settings.chunkSize, 0, chunkZ * this.settings.chunkSize);

                    // Add the chunk to the scene and the chunks map
                    this.scene.add(chunkGroup);
                    this.chunks.set(chunkKey, chunkGroup);

                    return chunkGroup;
                }

                // Updates terrain chunks based on the player's current position
                update(playerPosition) {
                    const playerChunkX = Math.floor(playerPosition.x / this.settings.chunkSize);
                    const playerChunkZ = Math.floor(playerPosition.z / this.settings.chunkSize);

                    // Determine which chunks should be visible based on render distance
                    for (let x = playerChunkX - this.settings.renderDistance; x <= playerChunkX + this.settings.renderDistance; x++) {
                        for (let z = playerChunkZ - this.settings.renderDistance; z <= playerChunkZ + this.settings.renderDistance; z++) {
                            this.generateChunk(x, z);
                        }
                    }

                    // Remove chunks that are outside the render distance to optimize performance
                    for (const [key, chunk] of this.chunks.entries()) {
                        const [chunkX, chunkZ] = key.split(',').map(Number);
                        if (Math.abs(chunkX - playerChunkX) > this.settings.renderDistance || Math.abs(chunkZ - playerChunkZ) > this.settings.renderDistance) {
                            this.scene.remove(chunk);
                            this.chunks.delete(key);
                        }
                    }
                }
            }

            // Example usage:

            // Assuming you have a Three.js scene already set up
            // const scene = new THREE.Scene();

            // Define terrain settings
            const terrainSettings = {
                chunkSize: 100,           // Size of each terrain chunk
                chunkResolution: 100,     // Number of segments per chunk
                terrainHeight: 30,        // Maximum height of the terrain
                noiseScale: 100,          // Scale of the noise (adjust for different terrain roughness)
                renderDistance: 3,        // Number of chunks to render around the player
                minElevation: -10,        // Minimum elevation (for gradient if needed)
                maxElevation: 30          // Maximum elevation (for gradient if needed)
            };

            // Initialize the terrain generator
            const terrainGenerator = new TerrainGenerator(scene, terrainSettings);

            // Function to add diverse plants to the terrain
            function addPlantsToTerrain() {
                const numElements = 3000; // Total number of natural elements

                const elementTypes = [
                    {
                        // Tree
                        geometry: new THREE.ConeGeometry(20, 200, 20),
                        material: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
                        yOffset: 5,
                    },
                    {
                        geometry: new THREE.CylinderGeometry(0.5, 0.5, 5, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                        yOffset: 2.5,
                    },
                    {
                        geometry: new THREE.SphereGeometry(3, 8, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                        yOffset: 3,
                    },
                    {
                        //Large Bush
                        geometry: new THREE.SphereGeometry(4, 12, 13),
                        material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                        yOffset: 3,
                    },
                    {
                        //Rock
                        geometry: new THREE.DodecahedronGeometry(3, 2),
                        material: new THREE.MeshLambertMaterial({ color: 0x808080 }),
                        yOffset: 3,
                    },
                ];

                for (let i = 0; i < numElements; i++) {
                    const typeIndex = Math.floor(Math.random() * elementTypes.length);
                    const element = new THREE.Mesh(
                        elementTypes[typeIndex].geometry,
                        elementTypes[typeIndex].material
                    );

                    // Random position within the terrain bounds, avoiding the safe zone
                    let x = Math.random() * 10000 - 5000;
                    let z = Math.random() * 10000 - 5000;
                    while (Math.sqrt(x * x + z * z) < 800) { // Ensure elements are not in the safe zone
                        x = Math.random() * 10000 - 5000;
                        z = Math.random() * 10000 - 5000;
                    }

                    element.position.set(x, elementTypes[typeIndex].yOffset, z);
                    element.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                    scene.add(element);
                }
            }

            addPlantsToTerrain();


            // teleport.js
            function startTeleportation() {
                isTeleporting = true;
                teleportProgress = 0;
                document.getElementById('teleportationBarContainer').style.display = 'block';
            }

            function updateTeleportation(delta) {
                if (isTeleporting) {
                    teleportProgress += delta;
                    const progressBar = document.getElementById('teleportationBar');
                    progressBar.style.width = (teleportProgress / teleportationDuration) * 100 + '%';
                    if (teleportProgress >= teleportationDuration) {
                        isTeleporting = false;
                        document.getElementById('teleportationBarContainer').style.display = 'none';
                        progressBar.style.width = '0%';
                        teleportToSafeZone();
                    }
                }
            }

            function teleportToSafeZone() {
                previousPosition = player.position.clone(); // Save current position
                player.position.set(0, 0, 0); // Teleport to the center of the shrine
                destination = null; // Stop any movement
            }

            function teleportPlayer() {
                const x = parseFloat(document.getElementById('teleportXInput').value);
                const z = parseFloat(document.getElementById('teleportZInput').value);

                if (!isNaN(x) && !isNaN(z)) {
                    player.position.set(x, player.position.y, z);
                    destination = null;
                    isTeleporting = false; // Reset teleporting state
                    document.getElementById('teleportationBarContainer').style.display = 'none'; // Hide progress bar
                    document.getElementById('teleportationBar').style.width = '0%'; // Reset progress bar
                    alert(`Player teleported to (${x}, ${z}).`);
                } else {
                    alert('Invalid coordinates!');
                }
            }

            // spawnzone.js

            function createSpawnZone(scene, walls, enemyWalls, structures, friendlies, npcData) {
                // Create ground and safe zone
                const { ground, safeZoneGround, safeZoneBarrier } = createGroundAndSafeZone(scene, enemyWalls);

                // Create settlement walls
                createSettlementWalls(scene, walls, enemyWalls);

                // Create shrine and teleport pad
                const teleportPad = createShrine(scene);

                // Create structures and NPCs
                createStructuresAndNPCs(scene, walls, structures, friendlies, npcData);

                // Return references if needed
                return {
                    ground: ground,
                    safeZoneGround: safeZoneGround,
                    teleportPad: teleportPad
                };
            }


            function createGroundAndSafeZone(scene, enemyWalls) {
                const groundShape = new THREE.Shape();
                groundShape.moveTo(-5000, -5000);
                groundShape.lineTo(5000, -5000);
                groundShape.lineTo(5000, 5000);
                groundShape.lineTo(-5000, 5000);
                groundShape.lineTo(-5000, -5000);

                const safeZoneSize = 600;
                const holePath = new THREE.Path();
                holePath.moveTo(-safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, safeZoneSize);
                holePath.lineTo(safeZoneSize, -safeZoneSize);
                holePath.lineTo(-safeZoneSize, -safeZoneSize);
                groundShape.holes.push(holePath);

                const groundGeometry = new THREE.ShapeGeometry(groundShape);

                // Create a CanvasTexture as a replacement for the ground texture
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const context = canvas.getContext('2d');
                
                // Fill with a base color
                context.fillStyle = '#654321'; // Example ground color
                context.fillRect(0, 0, canvas.width, canvas.height);

                // Optional: Add grid pattern for texture effect
                context.strokeStyle = '#4c3a2b';
                for (let i = 0; i < canvas.width; i += 16) {
                    context.moveTo(i, 0);
                    context.lineTo(i, canvas.height);
                    context.moveTo(0, i);
                    context.lineTo(canvas.width, i);
                }
                context.stroke();

                // Create a Three.js texture from the canvas
                const groundTexture = new THREE.CanvasTexture(canvas);
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(50, 50);

                // Create material with the generated CanvasTexture
                const groundMaterial = new THREE.MeshLambertMaterial({
                    map: groundTexture,
                    side: THREE.DoubleSide
                });

                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.name = 'ground';
                scene.add(ground);

                // Create safe zone ground
                const safeZoneGroundGeometry = new THREE.PlaneGeometry(1200, 1200);
                const safeZoneGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const safeZoneGround = new THREE.Mesh(safeZoneGroundGeometry, safeZoneGroundMaterial);
                safeZoneGround.rotation.x = -Math.PI / 2;
                safeZoneGround.position.y = 0.1;
                scene.add(safeZoneGround);

                // Create invisible barrier for safe zone
                const safeZoneBarrierGeometry = new THREE.BoxGeometry(1200, 50, 1200);
                const safeZoneBarrierMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000, 
                    transparent: true, 
                    opacity: 0 
                });
                const safeZoneBarrier = new THREE.Mesh(safeZoneBarrierGeometry, safeZoneBarrierMaterial);
                safeZoneBarrier.position.set(0, 25, 0);
                scene.add(safeZoneBarrier);
                enemyWalls.push(safeZoneBarrier);

                return { ground, safeZoneGround, safeZoneBarrier };
            }


            function createSafeZoneWall(width, height, depth, x, y, z) {
                const wallGeometry = new THREE.BoxGeometry(width, height, depth);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x, y, z);
                return wall;
            }

            function createShrine(scene) {
                const shrineGroup = new THREE.Group();

                const floorGeometry = new THREE.CircleGeometry(20, 32);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1;
                shrineGroup.add(floor);

                const teleportPadGeometry = new THREE.CircleGeometry(5, 32);
                const teleportPadMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const teleportPad = new THREE.Mesh(teleportPadGeometry, teleportPadMaterial);
                teleportPad.rotation.x = -Math.PI / 2;
                teleportPad.position.y = 0.11;
                teleportPad.name = 'teleportPad';
                shrineGroup.add(teleportPad);

                shrineGroup.position.set(0, 0, 0);
                scene.add(shrineGroup);

                return teleportPad;
            }

            function createStructuresAndNPCs(scene, walls, structures, friendlies, npcData) {
                const buildingTypes = [1, 2, 3, 4, 5]; // Define 5 building types
                const structurePositions = getSpawnZonePositions(); // Generate positions

                structurePositions.forEach((pos, index) => {
                    const type = buildingTypes[index % buildingTypes.length];
                    const structure = createBuilding(type);
                    structure.position.set(pos.x, 0, pos.z);
                    scene.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    // NPC and other logic...
                    const npcInfo = getRandomNPC();
                    if (npcInfo) {
                        const npc = createFriendlyNPC(0x00ff00, npcInfo.name, npcInfo.dialogue);
                        npc.position.copy(structure.position);
                        scene.add(npc);
                        friendlies.push(npc);
                    }
                });
            }



            function createStructure() {
                const building = new THREE.Group();

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;
                const wallColor = 0x8B4513;

                const frontWallShape = new THREE.Shape();
                frontWallShape.moveTo(-wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, 0);

                const doorWidth = 10;
                const doorHeight = 20;
                const doorX = -doorWidth / 2;
                const doorY = 0;

                const doorHole = new THREE.Path();
                doorHole.moveTo(doorX, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY);
                frontWallShape.holes.push(doorHole);

                const frontWallGeometry = new THREE.ShapeGeometry(frontWallShape);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                const backWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.z = wallLength / 2;
                backWall.position.y = wallHeight / 2;
                building.add(backWall);

                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                rightWall.position.x = wallLength / 2;
                rightWall.position.y = wallHeight / 2;
                building.add(rightWall);

                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                return building;
            }



            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }

            // Function to add diverse plants to the terrain
            function addPlantsToTerrain() {
                const numElements = 3000; // Total number of natural elements

                const elementTypes = [
                    {
                        // Tree
                        geometry: new THREE.ConeGeometry(20, 200, 20),
                        material: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
                        yOffset: 5,
                    },
                    {
                        geometry: new THREE.CylinderGeometry(0.5, 0.5, 5, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                        yOffset: 2.5,
                    },
                    {
                        geometry: new THREE.SphereGeometry(3, 8, 8),
                        material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                        yOffset: 3,
                    },
                    {
                        //Large Bush
                        geometry: new THREE.SphereGeometry(4, 12, 13),
                        material: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                        yOffset: 3,
                    },
                    {
                        //Rock
                        geometry: new THREE.DodecahedronGeometry(3, 2),
                        material: new THREE.MeshLambertMaterial({ color: 0x808080 }),
                        yOffset: 3,
                    },
                ];

                for (let i = 0; i < numElements; i++) {
                    const typeIndex = Math.floor(Math.random() * elementTypes.length);
                    const element = new THREE.Mesh(
                        elementTypes[typeIndex].geometry,
                        elementTypes[typeIndex].material
                    );

                    // Random position within the terrain bounds, avoiding the safe zone
                    let x = Math.random() * 10000 - 5000;
                    let z = Math.random() * 10000 - 5000;
                    while (Math.sqrt(x * x + z * z) < 800) { // Ensure elements are not in the safe zone
                        x = Math.random() * 10000 - 5000;
                        z = Math.random() * 10000 - 5000;
                    }

                    element.position.set(x, elementTypes[typeIndex].yOffset, z);
                    element.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                    scene.add(element);
                }
            }

            addPlantsToTerrain();

            // skilltree.js
            function openSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'block';
                populateSkillTree();
            }

            // Function to Close Skill Tree
            function closeSkillTree() {
                const skillTreeDiv = document.getElementById('skillTree');
                skillTreeDiv.style.display = 'none';
            }


            // Function to Populate Skill Tree UI
            function populateSkillTree() {
                const skillsContainer = document.getElementById('skillsContainer');
                skillsContainer.innerHTML = ''; // Clear existing skills

                for (const key in skillTreeData) {
                    if (skillTreeData.hasOwnProperty(key)) {
                        const skill = skillTreeData[key];
                        const skillDiv = document.createElement('div');
                        skillDiv.classList.add('skill');
                        if (skill.learned) {
                            skillDiv.classList.add('learned');
                        }
                        skillDiv.innerHTML = `<strong>${skill.name}</strong><br>${skill.description}<br>Cost: ${skill.cost} Stat Points`;
                        
                        // Add click event to learn the skill
                        skillDiv.addEventListener('click', () => {
                            if (!skill.learned && characterStats.statPoints >= skill.cost) {
                                // Learn the skill
                                characterStats.statPoints -= skill.cost;
                                skill.learned = true;
                                applySkillEffects(key);
                                updateDisplay();
                                populateSkillTree(); // Refresh the skill tree
                                alert(`You have learned ${skill.name}!`);
                            } else if (skill.learned) {
                                alert('Skill already learned.');
                            } else {
                                alert('Not enough stat points to learn this skill.');
                            }
                        });

                        // Add CSS classes based on skill availability
                        if (!skill.learned && characterStats.statPoints < skill.cost) {
                            skillDiv.classList.add('unavailable');
                        }

                        skillsContainer.appendChild(skillDiv);
                    }
                }
            }

            // Function to learn a skill
            function learnSkill(skillKey) {
                const skill = skillTreeData[skillKey];
                if (skill && !skill.learned && characterStats.statPoints >= skill.cost) {
                    skill.learned = true;
                    characterStats.statPoints -= skill.cost;
                    applySkillEffects(skillKey);
                    updateSkillTreeUI();
                    updateDisplay();
                } else {
                    alert('Cannot learn this skill.');
                }
            }

            // Function to apply skill effects
            function applySkillEffects(skillKey) {
                const skill = skillTreeData[skillKey];
                if (skill && skill.effects) {
                    Object.keys(skill.effects).forEach(stat => {
                        characterStats[stat] += skill.effects[stat];
                    });
                }
            }


            // settlement.js

            function createSettlement(x, y, z) {
                const settlementGroup = new THREE.Group();

                // Create settlement walls
                const wallsGroup = createSettlementWalls();
                wallsGroup.position.set(x, y, z);
                settlementGroup.add(wallsGroup);

                // Create structures and NPCs
                const positions = [
                    { x: x + 50, z: z + 50 },
                    { x: x - 50, z: z + 50 },
                    { x: x + 50, z: z - 50 },
                    { x: x - 50, z: z - 50 },
                    { x: x, z: z + 70 },
                ];

                positions.forEach(pos => {
                    const structure = createStructure();
                    structure.position.set(pos.x, y, pos.z);
                    settlementGroup.add(structure);
                    walls.push(...structure.userData.walls);
                    structures.push(structure);

                    const npc = createFriendlyNPC();
                    npc.position.set(pos.x, y, pos.z);
                    settlementGroup.add(npc);
                    friendlies.push(npc);
                });

                scene.add(settlementGroup);
            }

            function createSettlementWalls() {
                const safeZoneSize = 1200;  // Match the exact size of the grey safe zone
                const wallHeight = 30;
                const wallThickness = 2;
                const gateWidth = 100;

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

                // North Wall (Split into two segments)
                const sideLength = (safeZoneSize - gateWidth) / 2;
                
                // North Walls
                const northLeftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(sideLength, wallHeight, wallThickness),
                    wallMaterial
                );
                northLeftWall.position.set(-safeZoneSize/4 - gateWidth/4, wallHeight/2, -safeZoneSize/2);
                scene.add(northLeftWall);
                walls.push(northLeftWall);

                const northRightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(sideLength, wallHeight, wallThickness),
                    wallMaterial
                );
                northRightWall.position.set(safeZoneSize/4 + gateWidth/4, wallHeight/2, -safeZoneSize/2);
                scene.add(northRightWall);
                walls.push(northRightWall);

                // South Walls
                const southLeftWall = northLeftWall.clone();
                southLeftWall.position.set(-safeZoneSize/4 - gateWidth/4, wallHeight/2, safeZoneSize/2);
                scene.add(southLeftWall);
                walls.push(southLeftWall);

                const southRightWall = northRightWall.clone();
                southRightWall.position.set(safeZoneSize/4 + gateWidth/4, wallHeight/2, safeZoneSize/2);
                scene.add(southRightWall);
                walls.push(southRightWall);

                // Side Walls
                const eastWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, safeZoneSize),
                    wallMaterial
                );
                eastWall.position.set(safeZoneSize/2, wallHeight/2, 0);
                scene.add(eastWall);
                walls.push(eastWall);

                const westWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, safeZoneSize),
                    wallMaterial
                );
                westWall.position.set(-safeZoneSize/2, wallHeight/2, 0);
                scene.add(westWall);
                walls.push(westWall);

                // Gates (enemy barriers only - transparent)
                const gateMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3
                });

                const northGate = new THREE.Mesh(
                    new THREE.BoxGeometry(gateWidth, wallHeight, wallThickness),
                    gateMaterial
                );
                northGate.position.set(0, wallHeight/2, -safeZoneSize/2);
                scene.add(northGate);
                enemyWalls.push(northGate);  // Only add to enemyWalls

                const southGate = northGate.clone();
                southGate.position.set(0, wallHeight/2, safeZoneSize/2);
                scene.add(southGate);
                enemyWalls.push(southGate);  // Only add to enemyWalls
            }

            function createStructure() {
                const building = new THREE.Group();

                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;
                const wallColor = 0x8B4513;

                const frontWallShape = new THREE.Shape();
                frontWallShape.moveTo(-wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, 0);
                frontWallShape.lineTo(wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, wallHeight);
                frontWallShape.lineTo(-wallLength / 2, 0);

                const doorWidth = 10;
                const doorHeight = 20;
                const doorX = -doorWidth / 2;
                const doorY = 0;

                const doorHole = new THREE.Path();
                doorHole.moveTo(doorX, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY);
                doorHole.lineTo(doorX + doorWidth, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY + doorHeight);
                doorHole.lineTo(doorX, doorY);
                frontWallShape.holes.push(doorHole);

                const frontWallGeometry = new THREE.ShapeGeometry(frontWallShape);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                const backWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
                backWall.position.z = wallLength / 2;
                backWall.position.y = wallHeight / 2;
                building.add(backWall);

                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                rightWall.position.x = wallLength / 2;
                rightWall.position.y = wallHeight / 2;
                building.add(rightWall);

                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                return building;
            }

            function createBuilding(type) {
                const building = new THREE.Group();
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });

                switch(type) {
                    case 1:
                        // Type 1: Standard Building
                        addStandardWalls(building, wallMaterial);
                        addStandardRoof(building, roofMaterial);
                        break;
                    case 2:
                        // Type 2: Large Building
                        addLargeWalls(building, wallMaterial);
                        addLargeRoof(building, roofMaterial);
                        break;
                    case 3:
                        // Type 3: L-shaped Building
                        addLShapedWalls(building, wallMaterial);
                        addFlatRoof(building, roofMaterial);
                        break;
                    case 4:
                        // Type 4: Circular Building
                        addCircularWalls(building, wallMaterial);
                        addDomeRoof(building, roofMaterial);
                        break;
                    case 5:
                        // Type 5: Corner Building with Ramp
                        addCornerBuilding(building, wallMaterial, roofMaterial);
                        break;
                    default:
                        addStandardWalls(building, wallMaterial);
                        addStandardRoof(building, roofMaterial);
                }

                return building;
            }

            function addStandardWalls(building, material) {
                const wallLength = 50;
                const wallHeight = 30;
                const wallThickness = 2;

                // Front Wall
                const frontWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const frontWall = new THREE.Mesh(frontWallGeometry, material);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                // Back Wall
                const backWall = frontWall.clone();
                backWall.position.z = wallLength / 2;
                building.add(backWall);

                // Left Wall
                const sideWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(sideWallGeometry, material);
                leftWall.position.x = -wallLength / 2;
                building.add(leftWall);

                // Right Wall
                const rightWall = leftWall.clone();
                rightWall.position.x = wallLength / 2;
                building.add(rightWall);
            }

            function addStandardRoof(building, material) {
                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roof = new THREE.Mesh(roofGeometry, material);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = 30 + 7.5; // wallHeight + half of roof height
                building.add(roof);
            }
            function addCornerBuilding(building, wallMaterial, roofMaterial) {
                // Base Floor
                const baseFloorGeometry = new THREE.BoxGeometry(200, 30, 200); // 4x standard size
                const baseFloor = new THREE.Mesh(baseFloorGeometry, wallMaterial);
                baseFloor.position.y = 15; // Half of wallHeight
                building.add(baseFloor);

                // Second Floor
                const secondFloorGeometry = new THREE.BoxGeometry(200, 30, 200);
                const secondFloor = new THREE.Mesh(secondFloorGeometry, wallMaterial);
                secondFloor.position.y = 45; // wallHeight + second floor height
                building.add(secondFloor);

                // Diagonal Ramp (Ramp can be a simple inclined plane or a detailed ramp)
                const rampGeometry = new THREE.BoxGeometry(50, 5, 100);
                const ramp = new THREE.Mesh(rampGeometry, wallMaterial);
                ramp.rotation.x = Math.atan(50 / 100); // Adjust slope as needed
                ramp.position.set(75, 15, 50); // Position ramp appropriately
                building.add(ramp);

                // Roof for the second floor
                const roofGeometry = new THREE.ConeGeometry(50, 20, 4);
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = 60; // Position above the second floor
                building.add(roof);
            }
            function getSpawnZonePositions() {
                const positions = [];
                const rowCount = 2;
                const buildingsPerRow = 5;
                const spacing = 300; // Adjust based on building sizes and desired spacing
                const startX = -((buildingsPerRow - 1) * spacing) / 2;
                const zOffset = 500; // Distance between rows

                for (let row = 0; row < rowCount; row++) {
                    for (let i = 0; i < buildingsPerRow; i++) {
                        const x = startX + i * spacing;
                        const z = row === 0 ? zOffset : -zOffset;
                        positions.push({ x, z });
                    }
                }

                // Add corner building at one of the corners
                positions.push({ x: startX - spacing, z: zOffset + spacing });

                return positions;
            }
            const structurePositions = [
                { x: -200, z: 200 },
                { x: 0, z: 200 },
                { x: 200, z: 200 },
                { x: -200, z: -200 },
                { x: 0, z: -200 },
                { x: 200, z: -200 },
            ];


            function generateRandomItems(count) {
                const items = [
                    // ----------------------
                    // Consumables
                    // ----------------------
                    {
                        name: 'Small Health Potion',
                        description: 'Restores 50 health points.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 25,
                        stats: { healthRestore: 50 }
                    },
                    {
                        name: 'Large Health Potion',
                        description: 'Restores 150 health points.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 75,
                        stats: { healthRestore: 150 }
                    },
                    {
                        name: 'Elixir of Vitality',
                        description: 'Restores 300 health points and increases maximum health temporarily.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 200,
                        stats: { healthRestore: 300, maxHealthIncrease: 50, duration: '5 minutes' }
                    },
                    {
                        name: 'Mana Potion',
                        description: 'Restores 30 mana points.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 20,
                        stats: { manaRestore: 30 }
                    },
                    {
                        name: 'Greater Mana Potion',
                        description: 'Restores 100 mana points.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { manaRestore: 100 }
                    },
                    {
                        name: 'Elixir of Wisdom',
                        description: 'Restores 200 mana points and increases intelligence temporarily.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 180,
                        stats: { manaRestore: 200, intelligenceIncrease: 20, duration: '5 minutes' }
                    },
                    {
                        name: 'Stamina Potion',
                        description: 'Replenishes stamina for enhanced physical performance.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 30,
                        stats: { staminaRestore: 40 }
                    },
                    {
                        name: 'Elixir of Strength',
                        description: 'Temporarily boosts your strength.',
                        type: 'Consumable',
                        rarity: 'Uncommon',
                        value: 90,
                        stats: { strengthIncrease: 15, duration: '10 minutes' }
                    },
                    {
                        name: 'Antidote',
                        description: 'Cures poison effects.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 20,
                        stats: { poisonCure: true }
                    },
                    {
                        name: 'Rejuvenation Elixir',
                        description: 'Gradually restores health and mana over time.',
                        type: 'Consumable',
                        rarity: 'Rare',
                        value: 220,
                        stats: { healthRestore: 50, manaRestore: 30, duration: '10 minutes' }
                    },
                    
                    // ----------------------
                    // Weapons
                    // ----------------------
                    {
                        name: 'Rusty Sword',
                        description: 'A worn-out sword with minimal damage.',
                        type: 'Weapon',
                        rarity: 'Common',
                        value: 15,
                        stats: { damage: 10, speed: 5 }
                    },
                    {
                        name: 'Iron Sword',
                        description: 'A sturdy iron sword dealing moderate damage.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 50,
                        stats: { damage: 25, speed: 7 }
                    },
                    {
                        name: 'Steel Sword',
                        description: 'A sharp steel sword with high damage.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 120,
                        stats: { damage: 40, speed: 8 }
                    },
                    {
                        name: 'Longbow',
                        description: 'A bow suitable for long-range attacks.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { damage: 20, range: 50 }
                    },
                    {
                        name: 'Crossbow',
                        description: 'A mechanical bow that fires bolts with precision.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 70,
                        stats: { damage: 22, range: 55 }
                    },
                    {
                        name: 'Dagger',
                        description: 'A small blade for quick strikes.',
                        type: 'Weapon',
                        rarity: 'Common',
                        value: 10,
                        stats: { damage: 8, speed: 10 }
                    },
                    {
                        name: 'Battle Axe',
                        description: 'A heavy axe capable of dealing significant damage.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 150,
                        stats: { damage: 45, speed: 6 }
                    },
                    {
                        name: 'War Hammer',
                        description: 'A mighty hammer designed to crush armor.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 160,
                        stats: { damage: 50, armorPenetration: 10 }
                    },
                    {
                        name: 'Short Sword',
                        description: 'A versatile sword suitable for both offense and defense.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { damage: 18, speed: 8 }
                    },
                    {
                        name: 'Magic Staff',
                        description: 'A staff imbued with magical properties for spellcasting.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 200,
                        stats: { damage: 30, intelligence: 15, magicDamage: 25 }
                    },
                    {
                        name: 'Spear',
                        description: 'A long-reaching weapon effective against multiple foes.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 55,
                        stats: { damage: 20, range: 40 }
                    },
                    {
                        name: 'Halberd',
                        description: 'A versatile polearm useful in both melee and ranged combat.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 140,
                        stats: { damage: 35, range: 30 }
                    },
                    {
                        name: 'Twin Daggers',
                        description: 'A pair of daggers allowing for dual-wielding attacks.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 65,
                        stats: { damage: 16, speed: 12 }
                    },
                    {
                        name: 'Greatsword',
                        description: 'A massive sword that delivers devastating blows.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 300,
                        stats: { damage: 60, speed: 4 }
                    },
                    {
                        name: 'Blunderbuss',
                        description: 'A short firearm effective at close range.',
                        type: 'Weapon',
                        rarity: 'Uncommon',
                        value: 80,
                        stats: { damage: 25, range: 35 }
                    },
                    {
                        name: 'Flaming Sword',
                        description: 'A sword engulfed in flames, adding fire damage to attacks.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 350,
                        stats: { damage: 50, fireDamage: 20 }
                    },
                    {
                        name: 'Frozen Bow',
                        description: 'A bow that shoots arrows imbued with ice, slowing targets.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 340,
                        stats: { damage: 28, iceDamage: 15, slowEffect: true }
                    },
                    {
                        name: 'Shadow Blade',
                        description: 'A blade forged from shadows, dealing dark damage.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 360,
                        stats: { damage: 55, darkDamage: 25 }
                    },
                    {
                        name: 'Lightning Staff',
                        description: 'A staff that channels lightning to strike enemies.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 380,
                        stats: { damage: 35, lightningDamage: 30 }
                    },
                    // ----------------------
                    // Armor
                    // ----------------------
                    {
                        name: 'Cloth Armor',
                        description: 'Offers minimal defense but allows easy movement.',
                        type: 'Armor',
                        rarity: 'Common',
                        value: 25,
                        stats: { defense: 10, agility: 5 }
                    },
                    {
                        name: 'Leather Armor',
                        description: 'Provides better protection while maintaining flexibility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 55,
                        stats: { defense: 25, agility: 10 }
                    },
                    {
                        name: 'Chainmail Armor',
                        description: 'A robust armor made of interlocking metal rings.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 120,
                        stats: { defense: 50, agility: -5 }
                    },
                    {
                        name: 'Plate Armor',
                        description: 'Heavy armor that offers excellent protection.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 80, agility: -15 }
                    },
                    {
                        name: 'Mage Robes',
                        description: 'Light robes that enhance magical abilities.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 130,
                        stats: { defense: 15, intelligence: 20 }
                    },
                    {
                        name: 'Hunter\'s Garb',
                        description: 'Lightweight armor designed for stealth and agility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 70,
                        stats: { defense: 20, agility: 15 }
                    },
                    {
                        name: 'Knight\'s Armor',
                        description: 'Standard issue armor for knights, balancing protection and mobility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 90,
                        stats: { defense: 40, agility: -5 }
                    },
                    {
                        name: 'Dragon Scale Armor',
                        description: 'Armor made from dragon scales, offering superior protection.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 300,
                        stats: { defense: 90, fireResistance: 25 }
                    },
                    {
                        name: 'Shadow Cloak',
                        description: 'A cloak that allows the wearer to blend into shadows.',
                        type: 'Armor',
                        rarity: 'Rare',
                        value: 150,
                        stats: { defense: 25, stealth: 20 }
                    },
                    {
                        name: 'Guardian Plate',
                        description: 'Plate armor imbued with protective magic.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 320,
                        stats: { defense: 85, magicDefense: 30 }
                    },
                    // ----------------------
                    // Shields
                    // ----------------------
                    {
                        name: 'Old Shield',
                        description: 'Provides basic protection against attacks.',
                        type: 'Shield',
                        rarity: 'Common',
                        value: 20,
                        stats: { defense: 15 }
                    },
                    {
                        name: 'Iron Shield',
                        description: 'A sturdy iron shield offering good defense.',
                        type: 'Shield',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { defense: 25 }
                    },
                    {
                        name: 'Steel Shield',
                        description: 'A strong steel shield that can block powerful attacks.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 100,
                        stats: { defense: 45 }
                    },
                    {
                        name: 'Tower Shield',
                        description: 'A large shield providing excellent protection.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 220,
                        stats: { defense: 70, blockChance: 15 }
                    },
                    {
                        name: 'Buckler',
                        description: 'A small shield offering agility and quick defense.',
                        type: 'Shield',
                        rarity: 'Uncommon',
                        value: 35,
                        stats: { defense: 20, speed: 5 }
                    },
                    {
                        name: 'Magic Barrier Shield',
                        description: 'A shield that can generate magical barriers.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 60, magicDefense: 40, barrier: true }
                    },
                    {
                        name: 'Enchanted Shield',
                        description: 'A shield imbued with enchantments to enhance its protective capabilities.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 240,
                        stats: { defense: 65, magicDefense: 35 }
                    },
                    {
                        name: 'Reinforced Shield',
                        description: 'A shield reinforced with metal plates for extra durability.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 130,
                        stats: { defense: 50, durability: 100 }
                    },
                    {
                        name: 'Spiked Shield',
                        description: 'A shield equipped with spikes to inflict damage upon attackers.',
                        type: 'Shield',
                        rarity: 'Rare',
                        value: 140,
                        stats: { defense: 40, damage: 10 }
                    },
                    {
                        name: 'Reflective Shield',
                        description: 'A shield that can reflect certain types of magic spells.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 260,
                        stats: { defense: 55, magicReflection: 20 }
                    },
                    
                    // ----------------------
                    // Boots
                    // ----------------------
                    {
                        name: 'Leather Boots',
                        description: 'Increases movement speed slightly.',
                        type: 'Boots',
                        rarity: 'Common',
                        value: 20,
                        stats: { speed: 5 }
                    },
                    {
                        name: 'Swift Boots',
                        description: 'Greatly increase movement speed.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { speed: 20 }
                    },
                    {
                        name: 'Heavy Boots',
                        description: 'Provide stability but reduce movement speed.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 50,
                        stats: { speed: -5, defense: 10 }
                    },
                    {
                        name: 'Boots of Silence',
                        description: 'Reduce the noise you make while moving, enhancing stealth.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 110,
                        stats: { stealth: 20 }
                    },
                    {
                        name: 'Firewalkers',
                        description: 'Allow the wearer to walk on hot surfaces without taking damage.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 130,
                        stats: { fireResistance: 25 }
                    },
                    {
                        name: 'Boots of the Eagle',
                        description: 'Enhance jumping ability and vision.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 200,
                        stats: { jumpHeight: 15, visionRange: 10 }
                    },
                    {
                        name: 'Shadowstep Boots',
                        description: 'Allow the wearer to move swiftly and leave behind shadows.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 220,
                        stats: { speed: 25, stealth: 25 }
                    },
                    {
                        name: 'Frostwalk Boots',
                        description: 'Enable the wearer to walk on ice without slipping.',
                        type: 'Boots',
                        rarity: 'Rare',
                        value: 140,
                        stats: { iceResistance: 20 }
                    },
                    {
                        name: 'Boots of Fortitude',
                        description: 'Increase overall endurance and reduce fatigue.',
                        type: 'Boots',
                        rarity: 'Uncommon',
                        value: 75,
                        stats: { endurance: 15 }
                    },
                    {
                        name: 'Traveler\'s Boots',
                        description: 'Provide comfort and reduce travel fatigue.',
                        type: 'Boots',
                        rarity: 'Common',
                        value: 30,
                        stats: { comfort: 10, fatigueReduction: 10 }
                    },
                    
                    // ----------------------
                    // Helmets
                    // ----------------------
                    {
                        name: 'Iron Helmet',
                        description: 'Protects the head from minor attacks.',
                        type: 'Helmet',
                        rarity: 'Uncommon',
                        value: 40,
                        stats: { defense: 20 }
                    },
                    {
                        name: 'Steel Helmet',
                        description: 'A strong helmet offering good protection.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 100,
                        stats: { defense: 35 }
                    },
                    {
                        name: 'Wizard Hat',
                        description: 'Enhances magical abilities.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 90,
                        stats: { intelligence: 15 }
                    },
                    {
                        name: 'Helmet of Insight',
                        description: 'Grants the wearer enhanced perception and awareness.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 210,
                        stats: { perception: 20, intelligence: 10 }
                    },
                    {
                        name: 'Beastmaster Helm',
                        description: 'Allows communication with and control over beasts.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 230,
                        stats: { animalControl: 25 }
                    },
                    {
                        name: 'Helmet of Fortification',
                        description: 'Provides additional defense against physical and magical attacks.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 250,
                        stats: { defense: 40, magicDefense: 20 }
                    },
                    {
                        name: 'Shadow Hood',
                        description: 'Enhances stealth and dark vision.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 120,
                        stats: { stealth: 25, darkVision: 15 }
                    },
                    {
                        name: 'Helmet of the Ancients',
                        description: 'An ancient helmet that bestows wisdom and power.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 300,
                        stats: { wisdom: 30, power: 20 }
                    },
                    {
                        name: 'Nightmare Helm',
                        description: 'A helmet that instills fear into the hearts of enemies.',
                        type: 'Helmet',
                        rarity: 'Epic',
                        value: 280,
                        stats: { fearInduction: 20 }
                    },
                    {
                        name: 'Helm of the Phoenix',
                        description: 'Allows the wearer to resurrect upon death once.',
                        type: 'Helmet',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1 }
                    },
                    
                    // ----------------------
                    // Accessories
                    // ----------------------
                    {
                        name: 'Silver Ring',
                        description: 'A simple silver ring.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 30,
                        stats: {}
                    },
                    {
                        name: 'Gold Ring',
                        description: 'A shiny gold ring.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 80,
                        stats: {}
                    },
                    {
                        name: 'Ring of Strength',
                        description: 'Increases the wearer\'s strength.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 150,
                        stats: { strength: 10 }
                    },
                    {
                        name: 'Basic Amulet',
                        description: 'A simple amulet with no special properties.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 40,
                        stats: {}
                    },
                    {
                        name: 'Amulet of Protection',
                        description: 'Provides a shield against magical attacks.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 100,
                        stats: { magicDefense: 20 }
                    },
                    {
                        name: 'Amulet of the Mage',
                        description: 'Enhances the wearer\'s magical abilities.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 180,
                        stats: { intelligence: 20, manaRestore: 10 }
                    },
                    {
                        name: 'Charm Bracelet',
                        description: 'A bracelet adorned with various charms for luck.',
                        type: 'Accessory',
                        rarity: 'Common',
                        value: 35,
                        stats: { luck: 5 }
                    },
                    {
                        name: 'Necklace of Fire',
                        description: 'Allows the wearer to unleash fire spells.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 200,
                        stats: { fireDamage: 25 }
                    },
                    {
                        name: 'Ring of Invisibility',
                        description: 'Grants temporary invisibility to the wearer.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 300,
                        stats: { invisibilityDuration: '30 seconds' }
                    },
                    {
                        name: 'Pendant of Healing',
                        description: 'Gradually restores health over time.',
                        type: 'Accessory',
                        rarity: 'Uncommon',
                        value: 120,
                        stats: { healthRegen: 5 }
                    },
                    // ----------------------
                    // Miscellaneous Items
                    // ----------------------
                    {
                        name: 'Torch',
                        description: 'Provides light in dark areas.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 5,
                        stats: { lightRadius: 10 }
                    },
                    {
                        name: 'Lockpick Set',
                        description: 'Used to unlock doors and chests.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 25,
                        stats: { lockpickingSkill: 15 }
                    },
                    {
                        name: 'Rope',
                        description: 'A sturdy rope useful for climbing and tying.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 10,
                        stats: { length: '30 meters' }
                    },
                    {
                        name: 'Map',
                        description: 'Shows the layout of the surrounding area.',
                        type: 'Miscellaneous',
                        rarity: 'Common',
                        value: 15,
                        stats: { areaCovered: 'Local region' }
                    },
                    {
                        name: 'Compass',
                        description: 'Helps in navigation by pointing north.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 20,
                        stats: { accuracy: 'High' }
                    },
                    {
                        name: 'Healing Herb',
                        description: 'A herb used to make health potions.',
                        type: 'Consumable',
                        rarity: 'Common',
                        value: 5,
                        stats: { healthRestore: 10 }
                    },
                    {
                        name: 'Mana Crystal',
                        description: 'A crystal used to enhance magical items.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 150,
                        stats: { magicBoost: 20 }
                    },
                    {
                        name: 'Scroll of Fireball',
                        description: 'Casts a powerful fireball spell.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 200,
                        stats: { spell: 'Fireball', damage: 50 }
                    },
                    {
                        name: 'Gemstone',
                        description: 'A precious gemstone used in crafting.',
                        type: 'Miscellaneous',
                        rarity: 'Uncommon',
                        value: 60,
                        stats: { gemType: 'Ruby' }
                    },
                    {
                        name: 'Antique Key',
                        description: 'An old key that might unlock a hidden treasure.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 80,
                        stats: { unlocks: 'Unknown' }
                    },
                    // ----------------------
                    // More Items to Reach 70
                    // ----------------------
                    {
                        name: 'Bronze Shield',
                        description: 'A basic shield made of bronze.',
                        type: 'Shield',
                        rarity: 'Common',
                        value: 25,
                        stats: { defense: 18 }
                    },
                    {
                        name: 'Silver Sword',
                        description: 'A shiny sword effective against dark creatures.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 160,
                        stats: { damage: 35, darkDamageBonus: 15 }
                    },
                    {
                        name: 'Golden Armor',
                        description: 'Radiant armor that dazzles enemies.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 270,
                        stats: { defense: 55, magicDefense: 25, blindingEffect: true }
                    },
                    {
                        name: 'Mystic Ring',
                        description: 'A ring that enhances magical abilities.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 190,
                        stats: { intelligence: 25, manaRestore: 15 }
                    },
                    {
                        name: 'Thief\'s Cloak',
                        description: 'A cloak that enhances stealth and agility.',
                        type: 'Armor',
                        rarity: 'Uncommon',
                        value: 85,
                        stats: { stealth: 20, agility: 15 }
                    },
                    {
                        name: 'Berserker Helm',
                        description: 'A helmet that boosts attack power at the cost of defense.',
                        type: 'Helmet',
                        rarity: 'Rare',
                        value: 170,
                        stats: { attackPower: 20, defense: -10 }
                    },
                    {
                        name: 'Arcane Robe',
                        description: 'Robes that amplify magical spells.',
                        type: 'Armor',
                        rarity: 'Epic',
                        value: 210,
                        stats: { intelligence: 30, magicDamage: 20 }
                    },
                    {
                        name: 'Hunter\'s Bow',
                        description: 'A bow crafted for precision and long-range attacks.',
                        type: 'Weapon',
                        rarity: 'Rare',
                        value: 180,
                        stats: { damage: 28, range: 65 }
                    },
                    {
                        name: 'Sorcerer\'s Staff',
                        description: 'A staff that channels potent magical energies.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 240,
                        stats: { damage: 40, intelligence: 25, magicDamage: 30 }
                    },
                    {
                        name: 'Guardian Pendant',
                        description: 'An amulet that provides a protective aura.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 160,
                        stats: { defense: 20, magicDefense: 15 }
                    },
                    {
                        name: 'Dragonbone Dagger',
                        description: 'A dagger made from dragon bones, inflicting severe damage.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 280,
                        stats: { damage: 45, fireDamage: 10 }
                    },
                    {
                        name: 'Enchanted Boots',
                        description: 'Boots that grant the ability to walk on air for short durations.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 250,
                        stats: { speed: 20, flightDuration: '10 seconds' }
                    },
                    {
                        name: 'Phoenix Feather',
                        description: 'A rare feather that can resurrect the bearer once.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1 }
                    },
                    {
                        name: 'Shadow Amulet',
                        description: 'An amulet that enhances dark magic.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 220,
                        stats: { darkDamage: 20, stealth: 15 }
                    },
                    {
                        name: 'Crystal Shield',
                        description: 'A shield made of crystal that absorbs magic.',
                        type: 'Shield',
                        rarity: 'Epic',
                        value: 260,
                        stats: { defense: 50, magicAbsorption: 30 }
                    },
                    {
                        name: 'Titanium Armor',
                        description: 'Superior armor made from titanium, offering unmatched protection.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 400,
                        stats: { defense: 100, magicDefense: 50 }
                    },
                    {
                        name: 'Ethereal Blade',
                        description: 'A blade that exists partially in the ethereal plane, allowing it to bypass armor.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 450,
                        stats: { damage: 60, armorPenetration: 30 }
                    },
                    {
                        name: 'Ring of the Phoenix',
                        description: 'Grants the wearer the ability to revive once after death.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { resurrection: 1, fireResistance: 50 }
                    },
                    {
                        name: 'Dragon Scale Boots',
                        description: 'Boots made from dragon scales, providing fire resistance and increased speed.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 240,
                        stats: { speed: 15, fireResistance: 25 }
                    },
                    {
                        name: 'Amulet of the Titans',
                        description: 'An amulet that significantly boosts strength and endurance.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 520,
                        stats: { strength: 30, endurance: 25 }
                    },
                    {
                        name: 'Ring of the Archmage',
                        description: 'Enhances all magical abilities and reduces mana consumption.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { intelligence: 35, manaEfficiency: 20 }
                    },
                    {
                        name: 'Celestial Robe',
                        description: 'Robes that grant celestial protection and amplify light magic.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 480,
                        stats: { defense: 60, magicDamage: 30, lightResistance: 25 }
                    },
                    {
                        name: 'Infinity Staff',
                        description: 'A staff that never degrades and continuously channels magical energy.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { damage: 70, magicDamage: 50, intelligence: 40 }
                    },
                    {
                        name: 'Shadow Cloak',
                        description: 'A cloak that grants complete invisibility when in darkness.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { stealth: 50, invisibility: true }
                    },
                    {
                        name: 'Guardians Shield',
                        description: 'A shield that summons guardians to protect the bearer.',
                        type: 'Shield',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { defense: 80, summonGuardians: true }
                    },
                    {
                        name: 'Eagle Eye Goggles',
                        description: 'Enhance vision, allowing the wearer to see great distances clearly.',
                        type: 'Accessory',
                        rarity: 'Epic',
                        value: 200,
                        stats: { visionRange: 50 }
                    },
                    {
                        name: 'Berserker Gauntlets',
                        description: 'Gauntlets that increase attack speed and damage at the cost of defense.',
                        type: 'Accessory',
                        rarity: 'Rare',
                        value: 170,
                        stats: { attackSpeed: 20, damage: 15, defense: -10 }
                    },
                    {
                        name: 'Titan Gauntlets',
                        description: 'Gauntlets that grant immense strength and durability.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 400,
                        stats: { strength: 40, defense: 30 }
                    },
                    {
                        name: 'Phoenix Wings',
                        description: 'Grant the ability to fly for short periods.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { flightDuration: '30 seconds' }
                    },
                    {
                        name: 'Arcane Crystal',
                        description: 'A crystal that amplifies magical spells.',
                        type: 'Miscellaneous',
                        rarity: 'Rare',
                        value: 180,
                        stats: { magicBoost: 25 }
                    },
                    {
                        name: 'Vampire Dagger',
                        description: 'A dagger that steals health from enemies with each hit.',
                        type: 'Weapon',
                        rarity: 'Epic',
                        value: 280,
                        stats: { damage: 35, lifeSteal: 10 }
                    },
                    {
                        name: 'Holy Sword',
                        description: 'A sword blessed with holy magic, effective against undead.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { damage: 50, holyDamage: 30 }
                    },
                    {
                        name: 'Necromancer\'s Staff',
                        description: 'A staff that allows control over the dead.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 520,
                        stats: { damage: 40, necromancy: 25 }
                    },
                    {
                        name: 'Shadowstep Boots',
                        description: 'Allow the wearer to move swiftly and leave behind shadows.',
                        type: 'Boots',
                        rarity: 'Epic',
                        value: 220,
                        stats: { speed: 25, stealth: 25 }
                    },
                    {
                        name: 'Ember Blade',
                        description: 'A sword that burns with eternal flames.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { damage: 55, fireDamage: 35 }
                    },
                    {
                        name: 'Guardian Angel Wings',
                        description: 'Grant the ability to fly and provide a protective aura.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { flightDuration: '60 seconds', defenseAura: 20 }
                    },
                    {
                        name: 'Astral Armor',
                        description: 'Armor forged from celestial materials, offering superior protection.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 500,
                        stats: { defense: 95, magicDefense: 60, lightResistance: 40 }
                    },
                    {
                        name: 'Orb of Eternity',
                        description: 'A mystical orb that grants timelessness to its bearer.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { immortality: true }
                    },
                    {
                        name: 'Dragonfire Amulet',
                        description: 'An amulet that channels dragonfire into spells.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 550,
                        stats: { fireDamage: 40, magicDamage: 20 }
                    },
                    {
                        name: 'Celestial Shield',
                        description: 'A shield that harnesses the power of the stars to protect the bearer.',
                        type: 'Shield',
                        rarity: 'Legendary',
                        value: 600,
                        stats: { defense: 85, starPower: 30 }
                    },
                    {
                        name: 'Eclipse Blade',
                        description: 'A blade that balances light and darkness, adaptable to any combat situation.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 650,
                        stats: { damage: 65, lightDamage: 25, darkDamage: 25 }
                    },
                    {
                        name: 'Phoenix Feather Cloak',
                        description: 'A cloak made from phoenix feathers, granting the ability to resurrect once.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { resurrection: 1, fireResistance: 50 }
                    },
                    {
                        name: 'Starfall Staff',
                        description: 'A staff that calls down meteor showers upon enemies.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 680,
                        stats: { damage: 60, magicDamage: 40, areaEffect: true }
                    },
                    {
                        name: 'Dragonheart Pendant',
                        description: 'An amulet containing the heart of a dragon, bestowing immense power.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 750,
                        stats: { strength: 50, fireDamage: 40 }
                    },
                    {
                        name: 'Infinity Ring',
                        description: 'A ring that grants unlimited power to the wearer.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 800,
                        stats: { unlimitedPower: true }
                    },
                    {
                        name: 'Titanium Greatsword',
                        description: 'A colossal sword made from titanium, dealing unparalleled damage.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 700,
                        stats: { damage: 80, armorPenetration: 40 }
                    },
                    {
                        name: 'Ethereal Cloak',
                        description: 'A cloak that allows the wearer to phase through solid objects.',
                        type: 'Armor',
                        rarity: 'Legendary',
                        value: 720,
                        stats: { phaseThrough: true, stealth: 30 }
                    },
                    {
                        name: 'Scepter of the Archmage',
                        description: 'A scepter that amplifies all forms of magic.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 750,
                        stats: { magicDamage: 50, intelligence: 35 }
                    },
                    {
                        name: 'Guardians Blade',
                        description: 'A blade that summons guardians to fight alongside the bearer.',
                        type: 'Weapon',
                        rarity: 'Legendary',
                        value: 770,
                        stats: { damage: 55, summonGuardians: true }
                    },
                    {
                        name: 'Celestial Gauntlets',
                        description: 'Gauntlets that harness celestial energy to enhance strength and magic.',
                        type: 'Accessory',
                        rarity: 'Legendary',
                        value: 730,
                        stats: { strength: 30, magicDamage: 25 }
                    },
                    {
                        name: 'Orb of Power',
                        description: 'A powerful orb that significantly boosts all attributes.',
                        type: 'Miscellaneous',
                        rarity: 'Legendary',
                        value: 800,
                        stats: { strength: 20, intelligence: 20, defense: 20, magicDamage: 20 }
                    }
                ];

                const randomItems = [];
                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * items.length);
                    // Clone the item to avoid reference issues
                    randomItems.push({ ...items[randomIndex] });
                }
                return randomItems;
            }


            function addItemsToInventory(items) {
                console.log('Items added to inventory:', items);
                playerInventory.push(...items);
            }


            function initializeQuestLog() {
                // Initialize quests or other necessary setup
                quests = []; // Example initialization
                questLogOpen = false;
                // Optionally, preload some quests
            }

            // Add a quest to the quest log
            function addQuest(quest) {
                quests.push(quest);
                updateQuestLogDisplay();
            }

            // Update a quest's details
            function updateQuest(questId, updates) {
                const quest = quests.find(q => q.id === questId);
                if (quest) {
                    Object.assign(quest, updates);
                    updateQuestLogDisplay();
                }
            }

            // Mark a quest as completed
            function completeQuest(questId) {
                updateQuest(questId, { completed: true });
            }

            function initializeQuestLogUI() {
                // Initialize quests or other necessary setup
                quests = []; // Example initialization
                questLogOpen = false;
                // Optionally, preload some quests
            }

            // Open the quest log
            function openQuestLog() {
                questLogOpen = true;
                const questLog = document.getElementById('questLog');
                if (questLog) {
                    questLog.style.display = 'block';
                    updateQuestLogDisplay();
                } else {
                    console.error("Element with ID 'questLog' not found.");
                }
            }

            // Close the quest log
            function closeQuestLog() {
                questLogOpen = false;
                const questLog = document.getElementById('questLog');
                if (questLog) {
                    questLog.style.display = 'none';
                } else {
                    console.error("Element with ID 'questLog' not found.");
                }
            }

            function populateQuestLog() {
                const questList = document.getElementById('questList');
                questList.innerHTML = ''; // Clear existing quests

                quests.forEach(quest => {
                    const questItem = document.createElement('li');
                    questItem.innerText = `${quest.name}: ${quest.description}`;
                    questList.appendChild(questItem);
                });

                // Add more quest details as needed
            }

            // Initialize the quest log on script load
            initializeQuestLog();

    
            // Function to Create Purple Structure
            function createPurpleStructure() {
                const building = new THREE.Group();

                // Define wall material and dimensions
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Purple color
                const wallThickness = 2;
                const wallHeight = 30;
                const wallLength = 50;

                // Front Wall
                const frontWallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.z = -wallLength / 2;
                building.add(frontWall);

                // Back Wall
                const backWall = frontWall.clone();
                backWall.position.z = wallLength / 2;
                building.add(backWall);

                // Left Wall
                const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
                const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                leftWall.position.x = -wallLength / 2;
                leftWall.position.y = wallHeight / 2;
                building.add(leftWall);

                // Right Wall
                const rightWall = leftWall.clone();
                rightWall.position.x = wallLength / 2;
                building.add(rightWall);

                // Roof
                const roofGeometry = new THREE.ConeGeometry(35, 15, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Purple color
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = wallHeight + 7.5;
                building.add(roof);

                // Add walls to userData for collision detection
                building.userData.walls = [frontWall, backWall, leftWall, rightWall];

                // Add a black floor
                const floorGeometry = new THREE.PlaneGeometry(50, 50);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.1; // Slightly above ground to avoid z-fighting
                building.add(floor);

                return building;
            }

            function openNpcPopup(npc) {
                if (npcPopupOpen) {
                    closeNpcPopup();
                    return;
                }
                document.getElementById('npcPopup').querySelector('h2').innerText = npc.userData.name || 'Friendly NPC';
                document.getElementById('npcPopup').querySelector('p').innerText = npc.userData.dialogue || 'Hello, traveler! Stay awhile and listen...';
                document.getElementById('npcPopup').style.display = 'block';
                npcPopupOpen = true;
            }

            function closeNpcPopup() {
                document.getElementById('npcPopup').style.display = 'none';
                npcPopupOpen = false;
            }

            function openNpcAdminPopup(npc) {
                currentNpc = npc;
                document.getElementById('npcNameInput').value = npc.userData.name || '';
                document.getElementById('npcHealthInput').value = npc.userData.health || 100;
                document.getElementById('npcDialogueInput').value = npc.userData.dialogue || '';

                // Set initial colors
                document.getElementById('npcHeadColorInput').value = '#' + npc.head.material.color.getHexString();
                document.getElementById('npcBodyColorInput').value = '#' + npc.body.material.color.getHexString();
                document.getElementById('npcArmColorInput').value = '#' + npc.leftArm.material.color.getHexString();
                document.getElementById('npcLegColorInput').value = '#' + npc.leftLeg.material.color.getHexString();

                document.getElementById('npcAdminPopup').style.display = 'block';
            }

            function closeNpcAdminPopup() {
                document.getElementById('npcAdminPopup').style.display = 'none';
                currentNpc = null;
            }

            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }

            function saveNpcChanges() {
                if (currentNpc) {
                    currentNpc.userData.name = document.getElementById('npcNameInput').value;
                    currentNpc.userData.health = parseInt(document.getElementById('npcHealthInput').value) || 100;
                    currentNpc.userData.dialogue = document.getElementById('npcDialogueInput').value;

                    // Update colors
                    const headColor = new THREE.Color(document.getElementById('npcHeadColorInput').value);
                    const bodyColor = new THREE.Color(document.getElementById('npcBodyColorInput').value);
                    const armColor = new THREE.Color(document.getElementById('npcArmColorInput').value);
                    const legColor = new THREE.Color(document.getElementById('npcLegColorInput').value);

                    currentNpc.head.material.color.set(headColor);
                    currentNpc.body.material.color.set(bodyColor);
                    currentNpc.leftArm.material.color.set(armColor);
                    currentNpc.rightArm.material.color.set(armColor);
                    currentNpc.leftLeg.material.color.set(legColor);
                    currentNpc.rightLeg.material.color.set(legColor);

                    alert('NPC changes saved.');
                    closeNpcAdminPopup();
                }
            }


            // Function to animate quadrupeds
            function animateQuadruped(quadruped, delta) {
                if (quadruped.isMoving) {
                    quadruped.animationTime += delta * quadruped.animationSpeed;
                    const angle = Math.sin(quadruped.animationTime) * (Math.PI / 6);

                    // Front Left & Back Right Legs
                    quadruped.legs[0].rotation.x = angle;
                    quadruped.legs[3].rotation.x = angle;

                    // Front Right & Back Left Legs
                    quadruped.legs[1].rotation.x = -angle;
                    quadruped.legs[2].rotation.x = -angle;
                } else {
                    // Reset leg rotations
                    quadruped.legs.forEach(leg => leg.rotation.x = 0);
                }
            }

            // Function to move quadrupeds
function moveQuadrupeds(delta) {
    quadrupeds.forEach((quadruped) => {
        if (quadruped.userData.isDead) return; // Optional: Handle dead quadrupeds

        // Simple wandering logic
        if (!quadruped.isMoving) {
            // Decide to move or stay
            if (Math.random() < 0.01) { // 1% chance to start moving each frame
                quadruped.isMoving = true;
                // Random direction
                const angle = Math.random() * 2 * Math.PI;
                quadruped.userData.direction.set(Math.cos(angle), 0, Math.sin(angle));
                // Rotate to face direction
                quadruped.rotation.y = angle;
            }
        } else {
            // Move in the set direction
            const moveDistance = globalEnemySpeed * delta * 10; // Adjust speed as needed
            quadruped.position.add(quadruped.userData.direction.clone().multiplyScalar(moveDistance));

            // Clamp quadruped's position within -5000 to 5000 on both axes
            quadruped.position.x = Math.max(-5000, Math.min(5000, quadruped.position.x));
            quadruped.position.z = Math.max(-5000, Math.min(5000, quadruped.position.z));

            // Check for collisions with walls
            let collided = false;
            for (let wall of walls) {
                const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (quadrupedBox.intersectsBox(wallBox)) {
                    collided = true;
                    break;
                }
            }

            for (let wall of enemyWalls) {
                const quadrupedBox = new THREE.Box3().setFromObject(quadruped);
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (quadrupedBox.intersectsBox(wallBox)) {
                    collided = true;
                    break;
                }
            }

            if (collided) {
                quadruped.position.sub(quadruped.userData.direction.clone().multiplyScalar(moveDistance));
                quadruped.isMoving = false;
            } else {
                quadruped.isMoving = true;
            }

            // Stop moving after a certain distance or time
            if (Math.random() < 0.005) { // 0.5% chance to stop moving each frame
                quadruped.isMoving = false;
            }
        }

        // Animate quadruped
        animateQuadruped(quadruped, delta);
    });
}

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();

                if (isMouseDown && mouseDestination) {
                    destination = mouseDestination.clone();
                }

                if (destination) {
                    movePlayerTowardsDestination();
                } else {
                    player.isMoving = false;
                }

                maintainEnemyCount();
                animateHumanoid(player, delta);
                moveEnemies(delta);
                animateDeadEnemies(delta);
                moveQuadrupeds(delta); // Ensure quadrupeds are moving
                updateTeleportation(delta);
                updateLooting(delta);

                // Animate quadrupeds
                quadrupeds.forEach(quadruped => {
                    animateQuadruped(quadruped, delta);
                });

                // Handle camera rotation
                if (rotateLeft) {
                    cameraTargetAngle -= cameraRotationSpeed;
                }
                if (rotateRight) {
                    cameraTargetAngle += cameraRotationSpeed;
                }

                // Smoothly interpolate current angle towards target angle
                currentCameraAngle += (cameraTargetAngle - currentCameraAngle) * 0.1;


                // Update camera position based on current angle
                const cameraRadius = 100;
                const cameraHeight = 50;

                const cameraOffset = new THREE.Vector3(
                    Math.sin(currentCameraAngle) * cameraRadius,
                    cameraHeight,
                    Math.cos(currentCameraAngle) * cameraRadius
                );

                camera.position.copy(player.position).add(cameraOffset);
                camera.lookAt(player.position);


                // Render Main Scene
                renderer.clear();
                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissorTest(false);
                renderer.render(scene, camera);

                // Render Minimap
                minimapCamera.position.x = player.position.x;
                minimapCamera.position.z = player.position.z;

                const minimapContainer = document.getElementById('minimapContainer');
                const mapWidth = minimapContainer.clientWidth;
                const mapHeight = minimapContainer.clientHeight;
                const minimapRect = minimapContainer.getBoundingClientRect();
                const canvasRect = renderer.domElement.getBoundingClientRect();
                const minimapX = minimapRect.left - canvasRect.left;
                const minimapY = minimapRect.top - canvasRect.top;

                renderer.setViewport(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
                renderer.setScissor(minimapX, canvasRect.height - minimapY - mapHeight, mapWidth, mapHeight);
                renderer.setScissorTest(true);
                renderer.render(scene, minimapCamera);

                // Render Fullscreen Map if visible
                const fullscreenMap = document.getElementById('fullscreenMap');
                if (fullscreenMap.style.display === 'block') {
                    renderMap();
                }
            }

            function onDocumentKeyDown(event) {
                if (inventoryOpen || statsOpen || adminConsoleOpen) {
                    if (inventoryOpen && (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b')) {
                        inventoryOpen = false;
                        document.getElementById('inventory').style.display = 'none';
                    } else if (statsOpen && event.key.toLowerCase() === 'c') {
                        statsOpen = false;
                        document.getElementById('stats').style.display = 'none';
                    } else if (adminConsoleOpen && event.key === '`') {
                        closeAdminConsole();
                    }
                    return;
                            
                }
                        
                if (event.key === 'Escape') { // Handle Esc key
                    closeAllMenus();
                    return;
                }

                if (event.key.toLowerCase() === 'y') {
                    openBestiary();
                    return;
                }


                if (event.key.toLowerCase() === 'i' || event.key.toLowerCase() === 'b') {
                    inventoryOpen = !inventoryOpen;
                    document.getElementById('inventory').style.display = inventoryOpen ? 'block' : 'none';
                    return;
                }

                if (event.key.toLowerCase() === 'c') {
                    statsOpen = !statsOpen;
                    document.getElementById('stats').style.display = statsOpen ? 'block' : 'none';
                    return;
                }

                if (event.key === '`') {
                    if (adminConsoleOpen) {
                        closeAdminConsole();
                    } else {
                        openAdminConsole();
                    }
                    return;
                }


                // Handle toggling of admin window
                if (event.key === '`') {
                    if (!isAdminLoggedIn) {
                        openAdminConsole();
                    } else {
                        closeAdminConsole();
                    }
                    return;
                }

                // Handle toggling of help window
                if (event.key.toLowerCase() === 'h') {
                    helpWindowOpen = !helpWindowOpen;
                    document.getElementById('helpWindow').style.display = helpWindowOpen ? 'block' : 'none';
                    return;
                }

                // Set rotation flags
                if (event.key.toLowerCase() === 'a') {
                    rotateLeft = true;
                    return;
                }
                if (event.key.toLowerCase() === 'd') {
                    rotateRight = true;
                    return;
                }

                if (isTeleporting || isLooting) return;

                if (event.key.toLowerCase() === 't') {
                    if (!isTeleporting) {
                        startTeleportation();
                    }
                }
                        
                if (event.key.toLowerCase() === 'q') {
                    questLogOpen = !questLogOpen;
                    document.getElementById('questLog').style.display = questLogOpen ? 'block' : 'none';
                    return;
                }


                if (event.key.toLowerCase() === 'k') {
                    if (document.getElementById('skillTree').style.display === 'block') {
                        closeSkillTree();
                    } else {
                        openSkillTree();
                    }
                    return;
                }
            }

            function onDocumentKeyUp(event) {
                if (event.key.toLowerCase() === 'a') {
                    rotateLeft = false;
                    return;
                }
                if (event.key.toLowerCase() === 'd') {
                    rotateRight = false;
                    return;
                }
            }

            document.getElementById('closeHelp').addEventListener('click', function() {
                document.getElementById('helpWindow').style.display = 'none';
                helpWindowOpen = false; // Ensure the variable tracks the state properly
            });

            // Add keyup event listener
            document.addEventListener('keyup', onDocumentKeyUp, false);

            function onDocumentMouseDown(event) {
                // Set destination if clicking on ground
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                const chestIntersects = raycaster.intersectObjects(treasureChests, true);
                if (chestIntersects.length > 0) {
                    const chestObject = chestIntersects[0].object;
                    openChestPopup(chestObject);
                    return;
                }

                // If any popups are open or other conditions are met, don't process other keys
                if (inventoryOpen || statsOpen || adminConsoleOpen || isTeleporting || isLooting || helpWindowOpen) return;

                const objects = [ground, safeZoneGround, teleportPad, ...enemies, ...friendlies];
                const intersects = raycaster.intersectObjects([ground, safeZoneGround, teleportPad, ...enemies, ...friendlies], true);

                if (intersects.length > 0) {
                    const intersectedObject = intersects[0].object;
                    const parent = intersectedObject.parent;

                    if (intersectedObject === ground || intersectedObject === safeZoneGround) {
                        const point = intersects[0].point;
                        mouseDestination = new THREE.Vector3(point.x, player.position.y, point.z);
                        destination = new THREE.Vector3(point.x, player.position.y, point.z);
                    } else if (intersectedObject === teleportPad) {
                        if (previousPosition) {
                            player.position.copy(previousPosition);
                            destination = null;
                            previousPosition = null;
                            alert('Teleported back to your previous location.');
                        } else {
                            alert('No previous location to teleport to.');
                        }
                    } else if (parent.userData && parent.userData.type === 'hostile') {
                        if (parent.userData.isDead) {
                            lootEnemy(parent);
                        } else {
                            attackEnemy(parent);
                        }
                    } else if (friendlies.includes(parent)) {
                        if (npcAdminEnabled) {
                            openNpcAdminPopup(parent);
                            return;
                        }
                        openNpcPopup(parent);
                    } else if (parent.userData && parent.userData.type === 'nonHostile') {
                        alert('You see a peaceful creature.');
                    } else if (npcAdminEnabled) {
                        if (structures.includes(parent)) {
                            openStructureAdminPopup(parent);
                            return;
                        }
                        if (settlementWalls.includes(intersectedObject)) {
                            openSettlementWallAdminPopup(intersectedObject);
                            return;
                        }
                    } else if (friendlies.includes(parent)) {
                        if (npcAdminEnabled) {
                            openNpcAdminPopup(parent);
                            return;
                        }
                        openNpcPopup(parent);
                    }
                }
            }

            function onDocumentMouseUp(event) {
                isMouseDown = false;
                mouseDestination = null;
            }

            function saveStructureChanges() {
                if (currentStructure) {
                    const scale = parseFloat(document.getElementById('structureScaleInput').value);
                    const colorValue = document.getElementById('structureColorInput').value;
                    const color = new THREE.Color(colorValue);

                    currentStructure.scale.set(scale, scale, scale);

                    // Update color of all child meshes
                    currentStructure.traverse(child => {
                        if (child.isMesh) {
                            child.material.color.set(color);
                        }
                    });

                    currentStructure.userData.color = color; // Store the new color

                    alert('Structure changes saved.');
                    closeStructureAdminPopup();
                }
            }

            // Implement Map Rendering:
            function renderMap() {
                mapRenderer.render(mapScene, mapCamera);

                // Optionally, add markers for player, enemies, etc.
                addMapMarkers();
            }

            function addMapMarkers() {
                // Clear existing markers
                mapScene.children = mapScene.children.filter(child => !child.userData.isMapMarker);

                // Player Marker
                const playerMarkerGeometry = new THREE.SphereGeometry(10, 16, 16);
                const playerMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const playerMarker = new THREE.Mesh(playerMarkerGeometry, playerMarkerMaterial);
                playerMarker.position.set(player.position.x, 0, player.position.z);
                playerMarker.userData.isMapMarker = true;
                mapScene.add(playerMarker);

                // Enemy Markers
                enemies.forEach(enemy => {
                    if (!enemy.userData.isDead) { // Only mark active enemies
                        const enemyMarkerGeometry = new THREE.SphereGeometry(5, 8, 8);
                        const enemyMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const enemyMarker = new THREE.Mesh(enemyMarkerGeometry, enemyMarkerMaterial);
                        enemyMarker.position.set(enemy.position.x, 0, enemy.position.z);
                        enemyMarker.userData.isMapMarker = true;
                        mapScene.add(enemyMarker);
                    }
                });

                // Add other markers as needed (e.g., friendly NPCs, settlements)
            }

            // Function to create a quadruped
            function createQuadruped(color = 0x996633) {
                const group = new THREE.Group();

                // Body
                const bodyMaterial = new THREE.MeshLambertMaterial({ color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 5), bodyMaterial);
                body.position.y = 5;
                group.add(body);

                // Head
                const headMaterial = new THREE.MeshLambertMaterial({ color });
                const head = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), headMaterial);
                head.position.set(7, 7, 0);
                group.add(head);

                // Legs
                const legMaterial = new THREE.MeshLambertMaterial({ color });
                const legGeometry = new THREE.BoxGeometry(1, 5, 1);

                const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontLeftLeg.position.set(4, 2.5, 2);
                group.add(frontLeftLeg);

                const frontRightLeg = frontLeftLeg.clone();
                frontRightLeg.position.z = -2;
                group.add(frontRightLeg);

                const backLeftLeg = frontLeftLeg.clone();
                backLeftLeg.position.x = -4;
                group.add(backLeftLeg);

                const backRightLeg = frontRightLeg.clone();
                backRightLeg.position.x = -4;
                group.add(backRightLeg);

                // Tail
                const tailMaterial = new THREE.MeshLambertMaterial({ color });
                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 5), tailMaterial);
                tail.position.set(-7, 6, 0);
                tail.rotation.y = Math.PI / 4;
                group.add(tail);

                // Animation properties
                group.isMoving = false;
                group.animationTime = 0;
                group.animationSpeed = 5.0;

                // Store legs for animation
                group.legs = [frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg];

                // Direction for movement
                group.userData.direction = new THREE.Vector3();

                // Assign user data
                group.userData.type = 'nonHostile';
                group.userData.name = 'Quadruped';

                return group;
            }
            // Create an array to track previously selected NPCs
            let selectedNPCs = [];

            // Function to select a random NPC that hasn't been selected before
            function getRandomNPC() {
                if (selectedNPCs.length === npcData.length) {
                    console.log("All NPCs have been selected.");
                    return null; // All NPCs have already been selected
                }

                let npc;
                do {
                    npc = npcData[Math.floor(Math.random() * npcData.length)];
                } while (selectedNPCs.includes(npc));

                // Add the selected NPC to the array
                selectedNPCs.push(npc);
                return npc;
            }

            // Combined createHumanoid function
            function createHumanoid(color, texture, pattern, height, bodyShape) {
                const group = new THREE.Group();

                // Define realistic colors
                const skinColor = 0xf5cba7;  // Light skin tone
                const hairColor = 0x4b3621;  // Dark brown for hair
                const shirtColor = 0x1e90ff; // Blue shirt
                const pantsColor = 0x556b2f; // Dark olive green shorts
                const shoeColor = 0x333333;  // Dark gray for shoes

                // Torso (Adjusted to fit between shirt and head)
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const bodyGeometry = new THREE.BoxGeometry(5, 7, 2); // Shortened height of torso
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 11.5; // Positioned to align with shirt and head
                group.add(body);

                // Head (Positioned just above the shirt)
                const headGeometry = new THREE.BoxGeometry(3, 3, 3);
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 18; // Positioned to rest on top of the shirt
                group.add(head);

                // Hair
                const hairGeometry = new THREE.BoxGeometry(3.2, 0.5, 3.2);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 1.5;  // Slightly above head
                head.add(hair);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.5, 0.5, 1.5);
                head.add(leftEye);

                const rightEye = leftEye.clone();
                rightEye.position.x = 0.5;
                head.add(rightEye);

                // Nose
                const noseGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
                const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
                nose.position.set(0, 0, 1.6);
                head.add(nose);

                // Arms (Adjusted to Swing from Shoulder)
                const armGeometry = new THREE.BoxGeometry(1, 8, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                
                const createArm = (side) => {
                    const armGroup = new THREE.Group();

                    // Arm (entire length)
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -4; // Position the arm to pivot from the shoulder
                    armGroup.add(arm);

                    // Position the entire arm group based on side
                    armGroup.position.set(side === 'left' ? -3.5 : 3.5, 15, 0); // Attach at shoulder level
                    return armGroup;
                };

                const leftArm = createArm('left');
                group.add(leftArm);

                const rightArm = createArm('right');
                group.add(rightArm);

                // Legs (Segmented into two parts with shorts and shoes)
                const legMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const pantsMaterial = new THREE.MeshLambertMaterial({ color: pantsColor });
                const shoeMaterial = new THREE.MeshLambertMaterial({ color: shoeColor });

                const createLeg = () => {
                    const legGroup = new THREE.Group();

                    // Top half of the leg (Invisible)
                    const upperLegGeometry = new THREE.BoxGeometry(2, 5, 2);
                    const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
                    upperLeg.position.y = 2.5;
                    upperLeg.visible = false; // Make the top half invisible
                    legGroup.add(upperLeg);

                    // Bottom half of the leg (Visible)
                    const lowerLegGeometry = new THREE.BoxGeometry(2, 5, 2);
                    const lowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
                    lowerLeg.position.y = -2.5;
                    legGroup.add(lowerLeg);

                    // Longer shorts segment
                    const shortsGeometry = new THREE.BoxGeometry(2.1, 4, 2.1); // Lengthened shorts
                    const shorts = new THREE.Mesh(shortsGeometry, pantsMaterial);
                    shorts.position.y = 0.5; // Positioned to cover more of the leg
                    legGroup.add(shorts);

                    // Shoes at the bottom of each leg
                    const shoeGeometry = new THREE.BoxGeometry(2.5, 1, 2.5); // Larger than leg
                    const shoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                    shoe.position.y = -5.5; // Positioned at the end of the leg
                    legGroup.add(shoe);

                    return legGroup;
                };

                // Positioning the legs slightly higher so shoes don't touch the ground
                const leftLeg = createLeg();
                leftLeg.position.set(-1.5, 6, 0); // Raised by 1 unit
                group.add(leftLeg);

                const rightLeg = createLeg();
                rightLeg.position.set(1.5, 6, 0); // Raised by 1 unit
                group.add(rightLeg);

                // Shirt (Shortened to not overlap with shorts)
                const shirtGeometry = new THREE.BoxGeometry(6, 8, 3); // Shortened height
                const shirtMaterial = new THREE.MeshLambertMaterial({ color: shirtColor });
                const shirt = new THREE.Mesh(shirtGeometry, shirtMaterial);
                shirt.position.y = 12; // Positioned higher to avoid overlapping with shorts
                group.add(shirt);

                // Assign Parts for Animation
                group.head = head;
                group.body = body;
                group.leftArm = leftArm;
                group.rightArm = rightArm;
                group.leftLeg = leftLeg;
                group.rightLeg = rightLeg;

                // Animation Properties
                group.animationTime = 0;
                group.animationSpeed = 10.0;      // Default speed for general movements
                group.armSwingSpeed = 0.5;        // 30% slower speed for arm swinging
                group.isMoving = false;
                group.isAttacking = false;
                group.attackTime = 0;

                // User Data
                group.userData = {
                    name: 'Friendly NPC',
                    health: 100,
                    dialogue: 'Hello!',
                    weight: 1,
                    type: 'friendly' // Default type
                };

                // Apply Body Shape and Pattern if needed
                applyBodyShape(group, bodyShape);
                group.traverse(child => {
                    if (child.isMesh) {
                        applyPattern(child, pattern);
                    }
                });

                return group;
            }

            const npc = createHumanoid(color);

            function animateHumanoid(humanoid, delta) {
                if (humanoid.isAttacking) {
                    humanoid.attackTime += delta * humanoid.animationSpeed;
                    const angle = Math.sin(humanoid.attackTime * 20) * (Math.PI / 4);

                    humanoid.rightArm.rotation.x = -angle;

                    if (humanoid.attackTime > 0.5) {
                        humanoid.rightArm.rotation.x = 0;
                        humanoid.isAttacking = false;
                        humanoid.attackTime = 0;
                    }
                } else if (humanoid.isMoving) {
                    humanoid.animationTime += delta * humanoid.animationSpeed;
                    const angle = Math.sin(humanoid.animationTime) * (Math.PI / 6);

                    humanoid.leftArm.rotation.x = angle;
                    humanoid.rightArm.rotation.x = -angle;
                    humanoid.leftLeg.rotation.x = -angle;
                    humanoid.rightLeg.rotation.x = angle;
                } else {
                    humanoid.leftArm.rotation.x = 0;
                    humanoid.rightArm.rotation.x = 0;
                    humanoid.leftLeg.rotation.x = 0;
                    humanoid.rightLeg.rotation.x = 0;
                }
            }

            function createFriendlyNPC(color = 0x00ff00, name = 'Friendly NPC', dialogue = 'Hello!') {
                const npc = createHumanoid(color);
                npc.userData.type = 'friendly';
                npc.userData.name = name;
                npc.userData.dialogue = dialogue;
                return npc;
            }


                    
            function toggleFullscreenMap() {
                const fullscreenMap = document.getElementById('fullscreenMap');
                if (fullscreenMap.style.display === 'none') {
                    fullscreenMap.style.display = 'block';
                    renderMap(); // Initial render
                } else {
                    fullscreenMap.style.display = 'none';
                }
            }

            function closeFullscreenMap() {
                const fullscreenMap = document.getElementById('fullscreenMap');
                fullscreenMap.style.display = 'none';
            }
                    
            function addQuadrupeds() {
                for (let i = 0; i < 5; i++) {
                    let position = getRandomPositionOutsideTown(300, 1000);
                    const quadruped = createQuadruped();
                    quadruped.position.set(position.x, 0, position.z);
                    quadrupeds.push(quadruped);
                    scene.add(quadruped);
                }
            }

            function movePlayerTowardsDestination() {
                const direction = new THREE.Vector3().subVectors(destination, player.position);
                const distance = direction.length();
                if (distance > 0.1) {
                    direction.normalize();
                    const moveDistance = Math.min(speed, distance);
                    const oldPosition = player.position.clone();
                    player.position.add(direction.multiplyScalar(moveDistance));

                    let collided = false;
                    for (let wall of walls) {
                        const playerBox = new THREE.Box3().setFromObject(player);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        if (playerBox.intersectsBox(wallBox)) {
                            collided = true;
                            break;
                        }
                    }

                    if (collided) {
                        player.position.copy(oldPosition);
                        destination = null;
                        player.isMoving = false;
                    } else {
                        player.isMoving = true;
                        // Rotate player to face the direction of movement
                        player.rotation.y = Math.atan2(direction.x, direction.z);
                    }
                } else {
                    player.position.copy(destination);
                    destination = null;
                    player.isMoving = false;
                }
            }

            function createWhiteWall() {
                const wallGeometry = new THREE.BoxGeometry(10, 30, 2); // Adjust size as needed
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White color
                const whiteWall = new THREE.Mesh(wallGeometry, wallMaterial);
                whiteWall.userData.isWhiteWall = true; // Flag to identify white walls
                return whiteWall;
            }

            // Ensure the help window properly adjusts when the window is resized
            window.addEventListener('resize', onWindowResize);

            // Adjusting for window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                minimapCamera.left = -200;
                minimapCamera.right = 200;
                minimapCamera.top = 200;
                minimapCamera.bottom = -200;
                minimapCamera.updateProjectionMatrix();
            }



            initMap();
            init();
            animate();



            
            function addItemToInventory(item) {
                playerInventory.push(item);
                updateInventoryDisplay();
            }

            function updateInventoryDisplay() {
                for (let i = 1; i <= 6; i++) {
                    const grid = document.getElementById(`inventoryGridTab${i}`);
                    grid.innerHTML = ''; // Clear previous content
                    for (let j = 0; j < 56; j++) { // Ensures a full grid
                        const slot = document.createElement('div');
                        slot.classList.add('inventory-slot');
                        if (playerInventory[j]) {
                            slot.innerText = playerInventory[j].name;
                            slot.setAttribute('data-name', playerInventory[j].name);
                            slot.setAttribute('data-description', playerInventory[j].description || 'No description');
                        }
                        grid.appendChild(slot);
                    }
                }
            }


            function loadInventory() {
                if (inventoryLoaded) {
                    toggleInventoryDisplay();
                    return;
                }

                fetch('inventory.html')
                    .then(response => response.text())
                    .then(html => {
                        const inventoryPlaceholder = document.getElementById('inventoryPlaceholder');
                        inventoryPlaceholder.innerHTML = html;
                        inventoryLoaded = true;
                        initializeInventory();
                        toggleInventoryDisplay();
                    })
                    .catch(error => console.error('Error loading inventory:', error));
            }

            // In inventory.js, modify the populateInventoryGrid function:

            function populateInventoryGrid(gridElement, items) {
                gridElement.innerHTML = '';
                for (let i = 0; i < 56; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    if (items[i]) {
                        slot.innerText = items[i].name;
                        
                        // Add data attributes for tooltip
                        slot.setAttribute('data-name', items[i].name);
                        slot.setAttribute('data-description', items[i].description || 'No description available');
                        if (items[i].stats) {
                            const statsText = Object.entries(items[i].stats)
                                .map(([key, value]) => `${key}: ${value}`)
                                .join('\n');
                            slot.setAttribute('data-stats', statsText);
                        }
                        slot.setAttribute('data-rarity', items[i].rarity || 'Common');

                        // Add event listeners for tooltip
                        slot.addEventListener('mouseenter', onInventoryItemHover);
                        slot.addEventListener('mousemove', onInventoryItemHover);
                        slot.addEventListener('mouseleave', () => {
                            entityTooltip.style.display = 'none';
                        });
                    }
                    gridElement.appendChild(slot);
                }
            }

            // Modify onInventoryItemHover in tooltips.js:
            function onInventoryItemHover(event) {
                const itemSlot = event.target;
                const itemName = itemSlot.getAttribute('data-name');
                if (!itemName) return;

                const itemDescription = itemSlot.getAttribute('data-description');
                const itemStats = itemSlot.getAttribute('data-stats');
                const itemRarity = itemSlot.getAttribute('data-rarity');

                // Create tooltip content with styling
                entityTooltip.innerHTML = `
                    <div style="font-size: 14px; padding: 8px;">
                        <div style="color: ${getRarityColor(itemRarity)}; font-weight: bold; margin-bottom: 4px;">
                            ${itemName}
                        </div>
                        <div style="color: #aaa; font-style: italic; margin-bottom: 4px;">
                            ${itemRarity}
                        </div>
                        <div style="margin-bottom: 4px;">
                            ${itemDescription}
                        </div>
                        ${itemStats ? `<div style="color: #88ff88;">${itemStats.replace(/\n/g, '<br>')}</div>` : ''}
                    </div>
                `;

                // Position tooltip
                const rect = event.target.getBoundingClientRect();
                entityTooltip.style.left = `${rect.right + 10}px`;
                entityTooltip.style.top = `${rect.top}px`;
                entityTooltip.style.display = 'block';
            }

            // Add helper function for rarity colors
            function getRarityColor(rarity) {
                const rarityColors = {
                    'Common': '#ffffff',
                    'Uncommon': '#1eff00',
                    'Rare': '#0070dd',
                    'Epic': '#a335ee',
                    'Legendary': '#ff8000'
                };
                return rarityColors[rarity] || rarityColors.Common;
            }

            // Event listeners for inventory tabs
            function setupInventoryTabs() {
                const tabs = document.querySelectorAll('.inventory-tab');
                const tabContents = document.querySelectorAll('.inventory-tab-content');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(tc => tc.classList.remove('active'));

                        tab.classList.add('active');
                        const activeTabContent = document.getElementById(tab.dataset.tab);
                        activeTabContent.classList.add('active');
                    });
                });

                tabs[0].classList.add('active');
                tabContents[0].classList.add('active');
            }

            function generatePlayerInventoryGrid() {
                const grid = document.getElementById('playerInventoryGrid');
                grid.innerHTML = '';
                const numColumns = 7;
                const numRows = Math.ceil(playerInventory.length / numColumns); // Adjust rows based on items
                grid.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    grid.appendChild(slot);
                }
            }

            function generateInventoryGrid(gridElement, numColumns, numRows) {
                gridElement.style.gridTemplateColumns = `repeat(${numColumns}, 50px)`;
                gridElement.innerHTML = '';
                for (let i = 0; i < numColumns * numRows; i++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    gridElement.appendChild(slot);
                }
            }

            function generateInventorySlots() {
                for (let i = 1; i <= 6; i++) {
                    const grid = document.getElementById('inventoryGridTab' + i);
                    grid.innerHTML = '';
                    for (let j = 0; j < 56; j++) {
                        const slot = document.createElement('div');
                        slot.classList.add('inventory-slot');
                        grid.appendChild(slot);
                    }
                }
            }

            function setupInventorySlotEventListeners(sourceGrid, sourceItems, targetItems, targetGrid) {
                const slots = sourceGrid.querySelectorAll('.inventory-slot');
                slots.forEach((slot, index) => {
                    slot.addEventListener('click', () => {
                        if (sourceItems[index]) {
                            // Find first empty slot in targetItems
                            let emptyIndex = targetItems.findIndex(item => item == null);
                            if (emptyIndex === -1) {
                                alert('No space in target inventory.');
                                return;
                            }
                            // Transfer item
                            targetItems[emptyIndex] = sourceItems[index];
                            sourceItems[index] = null;

                            // Update grids
                            populateInventoryGrid(sourceGrid, sourceItems);
                            populateInventoryGrid(targetGrid, targetItems);
                        }
                    });
                });
            }

            function addItemToInventory(item) {
                // Assuming item includes name and description
                playerInventory.push(item);
                updateInventoryDisplay();
            }

            function toggleInventoryDisplay() {
                const inventory = document.getElementById('inventory');
                if (inventory) {
                    inventory.style.display = inventory.style.display === 'none' ? 'block' : 'none';
                }
            }

            // Load inventory when 'I' key is pressed
            document.addEventListener('keydown', (event) => {
                if (event.key === 'I' || event.key === 'i') {
                    loadInventory();
                }
            });

            function setupInventorySlots() {
                const slots = document.querySelectorAll('.inventory-slot');
                slots.forEach(slot => {
                    slot.addEventListener('mouseenter', (event) => {
                        const item = slot.getAttribute('data-item');
                        if (item) {
                            const itemData = JSON.parse(item);
                            showItemTooltip(event, itemData);
                        }
                    });

                    slot.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });

                    slot.addEventListener('mousemove', (event) => {
                        updateTooltipPosition(event);
                    });
                });
            }

            function showItemTooltip(event, itemData) {
                const tooltip = document.getElementById('entityTooltip');
                tooltip.innerHTML = `
                    <div class="item-tooltip">
                        <div class="item-name ${itemData.rarity.toLowerCase()}">${itemData.name}</div>
                        <div class="item-type">${itemData.type}</div>
                        <div class="item-description">${itemData.description}</div>
                        ${generateStatsHTML(itemData.stats)}
                        <div class="item-value">Value: ${itemData.value} gold</div>
                    </div>
                `;
                tooltip.style.display = 'block';
                updateTooltipPosition(event);
            }

            function updateTooltipPosition(event) {
                const tooltip = document.getElementById('entityTooltip');
                const padding = 10;
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                // Prevent tooltip from going off-screen
                const rect = tooltip.getBoundingClientRect();
                if (x + rect.width > window.innerWidth) {
                    x = event.clientX - rect.width - padding;
                }
                if (y + rect.height > window.innerHeight) {
                    y = event.clientY - rect.height - padding;
                }

                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            }

            function generateStatsHTML(stats) {
                if (!stats) return '';
                return Object.entries(stats)
                    .map(([stat, value]) => `<div class="item-stat">${stat}: ${value}</div>`)
                    .join('');
            }


            setupInventoryTabs();
            generateInventorySlots();

        </script>
        <!-- <script src="terrain.js"></script>
        <script src="settlement.js"></script>
        <script src="init.js"></script>
        <script src="inventory.js"></script>
        <script src="enemies.js"></script>
        <script src="neutralanimals.js"></script>
        <script src="teleport.js"></script>
        <script src="bestiary.js"></script>
        
        <script src="main.js"></script>
        <script src="npc.js"></script>
        <script src="admin.js"></script>
        <script src="purplestructure.js"></script>
        <script src="ui.js"></script>
        <script src="spawnzone.js"></script>
        <script src="questLog.js"></script>
        <script src="tooltips.js"></script>
        <script src="skilltree.js"></script>
        <script src="randomitems.js"></script>
        <script src="chest.js"></script>
        <script src="hostilequadrupeds.js"></script>
        <script src="characterCreation.js"></script>
        <script src="trading.js"></script>
        <!-- <script src="characterSprite.js"></script> -->
        <script src="updatedisplays.js"></script>
         -->
        <script>
            // Audio Widget Toggle Script
            document.addEventListener('DOMContentLoaded', function() {
                const audioWidgetContainer = document.getElementById('audioWidgetContainer');
                const toggleButton = document.getElementById('toggleAudioWidget');
        
                // Initialize button based on the initial state
                if (audioWidgetContainer.classList.contains('minimized')) {
                    toggleButton.textContent = '+';
                    toggleButton.title = 'Maximize Audio Widget';
                } else {
                    toggleButton.textContent = '_';
                    toggleButton.title = 'Minimize Audio Widget';
                }
        
                toggleButton.addEventListener('click', function() {
                    audioWidgetContainer.classList.toggle('minimized');
                    
                    // Change the button symbol based on state
                    if (audioWidgetContainer.classList.contains('minimized')) {
                        toggleButton.textContent = '+';
                        toggleButton.title = 'Maximize Audio Widget';
                    } else {
                        toggleButton.textContent = '_';
                        toggleButton.title = 'Minimize Audio Widget';
                    }
                });
            });

            // Help Window Script
            document.addEventListener('DOMContentLoaded', function() {
                const helpWindow = document.getElementById('helpWindow');
                const openHelpButton = document.getElementById('openHelp'); // Button to open help
                const closeHelpButton = document.getElementById('closeHelp');
                const focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), ' +
                    'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';
                let focusableElements;
                let firstFocusableElement;
                let lastFocusableElement;
                let previousActiveElement = null;

                // Function to open the Help Window
                function openHelpWindow() {
                    helpWindow.classList.add('show');
                    helpWindow.setAttribute('aria-hidden', 'false');
                    // Save the previously focused element
                    previousActiveElement = document.activeElement;
                    // Find all focusable elements inside the modal
                    focusableElements = helpWindow.querySelectorAll(focusableElementsString);
                    firstFocusableElement = focusableElements[0];
                    lastFocusableElement = focusableElements[focusableElements.length - 1];
                    // Set focus to the first focusable element
                    if (firstFocusableElement) firstFocusableElement.focus();
                    // Prevent background scrolling
                    document.body.classList.add('modal-open');
                }

                // Function to close the Help Window
                function closeHelpWindow() {
                    helpWindow.classList.remove('show');
                    helpWindow.classList.add('hide');
                    helpWindow.setAttribute('aria-hidden', 'true');
                    // Remove hide class after animation
                    helpWindow.addEventListener('animationend', function handleAnimationEnd() {
                        helpWindow.classList.remove('hide');
                        helpWindow.removeEventListener('animationend', handleAnimationEnd);
                    });
                    // Restore focus to the previously focused element
                    if (previousActiveElement) {
                        previousActiveElement.focus();
                    }
                    // Allow background scrolling
                    document.body.classList.remove('modal-open');
                }

                // Event listener for opening the Help Window
                if (openHelpButton) {
                    openHelpButton.addEventListener('click', openHelpWindow);
                }

                // Event listener for closing the Help Window
                if (closeHelpButton) {
                    closeHelpButton.addEventListener('click', closeHelpWindow);
                }

                // Close the modal when clicking outside the modal content
                helpWindow.addEventListener('click', function(event) {
                    if (event.target === helpWindow) {
                        closeHelpWindow();
                    }
                });

                // Handle keyboard navigation and Esc key
                helpWindow.addEventListener('keydown', function(event) {
                    const isTabPressed = (event.key === 'Tab' || event.keyCode === 9);
                    const isEscPressed = (event.key === 'Escape' || event.keyCode === 27);

                    if (isEscPressed) {
                        closeHelpWindow();
                        return;
                    }

                    if (!isTabPressed) {
                        return;
                    }

                    // If Shift + Tab
                    if (event.shiftKey) {
                        if (document.activeElement === firstFocusableElement) {
                            event.preventDefault();
                            lastFocusableElement.focus();
                        }
                    } else { // Tab
                        if (document.activeElement === lastFocusableElement) {
                            event.preventDefault();
                            firstFocusableElement.focus();
                        }
                    }
                });
            });
            document.addEventListener('DOMContentLoaded', function() {
                const darkModeToggle = document.getElementById('darkModeToggle');
                
                // Load saved theme preference
                if (localStorage.getItem('theme') === 'dark') {
                    document.body.classList.add('dark-mode');
                }
                
                darkModeToggle.addEventListener('click', function() {
                    document.body.classList.toggle('dark-mode');
                    // Save preference
                    if (document.body.classList.contains('dark-mode')) {
                        localStorage.setItem('theme', 'dark');
                        darkModeToggle.textContent = '';
                    } else {
                        localStorage.setItem('theme', 'light');
                        darkModeToggle.textContent = '';
                    }
                });
            });
            function showNotification(message, type = 'info') {
                const notificationContainer = document.getElementById('notificationContainer');
                const notification = document.createElement('div');
                notification.classList.add('notification', type);
                notification.textContent = message;
                notificationContainer.appendChild(notification);
                
                // Remove notification after animation
                notification.addEventListener('animationend', () => {
                    notification.remove();
                });
            }
            document.addEventListener('DOMContentLoaded', function() {
                // Function to open the music modal
                function openMusicModal() {
                    const musicModal = document.getElementById('musicModal');
                    musicModal.style.display = 'flex';
                }

                // Function to close the music modal
                function closeMusicModal() {
                    const musicModal = document.getElementById('musicModal');
                    musicModal.style.display = 'none';
                }

                // Add event listeners
                document.getElementById('openMusic').addEventListener('click', openMusicModal);
                document.getElementById('closeMusicModal').addEventListener('click', closeMusicModal);

                // Keydown event for opening modal with 'M'
                document.addEventListener('keydown', (event) => {
                    if (event.key.toLowerCase() === 'm') {
                        openMusicModal();
                    }
                });
            });
            
        </script>        
        <!-- Audio Widget Container -->
        <div id="audioWidgetContainer" class="minimized">
            <iframe id="audio_iframe" 
                src="https://widget.synthflow.ai/widget/v2/1730479220818x147425180103026180/1730479218515x247472567511716860" 
                allow="microphone" 
                scrolling="no"
                title="Audio Control Widget" 
                loading="lazy">
            </iframe>
            <!-- Minimize/Maximize Button -->
            <button id="toggleAudioWidget" class="toggle-button">_</button>
        </div>
    </body>
</html>